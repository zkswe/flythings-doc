{"./":{"url":"./","title":"关于我们","keywords":"","body":"关于我们 目标 让开发更加简单，高效；让普通用户拥有更便易的客制化开发方案。 价值 专业：用专业的技术铸造专业的产品 创新：不断的开拓创新为客户提供源源不断的价值 责任：用技术改变生活 关于显示屏模组 我们为什么做Linux的显示解决方案 目前随着技术的发展，人机交互方案一直在升级。而目前在一些传统领域人机交互发展相对比较缓慢。传统领域里面有不少基于单片机，单片机+FPGA的显示解决方案为不少客户解决了彩屏显示交互开发困难的问题；但是随着用户需求和交互内容的增多，传统的硬件限制已经无法满足大部分的客户需求，所以我们做了这个产品。赋能传统领域便捷的人机交互体验方案+物联网的接入能力，助力物联网的发展。 产品优势 对比传统的单片机串口屏或者单片机+FPGA显示屏的解决方案 提供了类手机，平板电脑一样的最新交互体验方式，客户接受程度高，产品使用学习成本低，显示效果好的优势 通过软件实现了多图层虚拟的技术，解决传统显示方案限制图层数目的问题 支持png 格式的解码能力，让图片图层叠加效果更佳 从系统层支持WiFi，以太网，2G，4G的接入能力为客户更加便捷的接入网络；同时方便快速的接入深智云，微信物联，微信支付，支付宝支付等平台，可以为共享行业提供快速的物联终端解决方案。 提供视频解码的能力，更方便的向用户展示信息。 对比Android和传统的Linux解决方案 提供测试稳定的硬件基础，节省了硬件开发的测试验证的周期 提供针对物联+显示的系统开发工作，节省系统在物联和显示上再次开发和调试系统的时间 提供低成本高效率的运行能力：目前系统运行于 1G单核的CPU,64MBDDR2,16MB的Flash上，节省50%以上的硬件成本 提供组态+用户逻辑源码的开发工具，方便客户快速完成客制化的开发；开发周期至少比传统的方式节省60%以上。 深度定制的系统具备了3秒快速启动和24小时*365天安全运行的能力。 应用场景 智能家居： 智能家电 共享行业 电梯指示牌 广告机 充电桩 评价机 只要您有需要显示，可能我们就能帮助您 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"system_introdoction.html":{"url":"system_introdoction.html","title":"FlyThings 系统介绍","keywords":"","body":"FlyThings系统框架介绍 本系统基于Linux系统开发，加入了自主开发的系统框架和GUI交互系统。 我们称之为FlyThings系统。 寓意为：物联网添加一个飞翔的能力 系统目标场景： 当前物联网行业发展迅速，液晶显示的发展中国的水平也不断提高并且已经进入了世界领先的地位了。随着液晶显示价格的下降，用户视窗展示的需求，screening正在到来。所有的展示都将变成显示屏。 中科世为针对目前的发展，提出了目前阶段更加适合的显示解决方案。 替换Android在以下小应用场景下的使用，比如家电，门禁等功能简单，系统稳定性要求高，性价比要求高的产品场景 替换传统的黑白显示或者MCU驱动的彩色显示方案，用低成本的方式提高交互体验性。 物联网和共享场景的到来，带来了更多展示视窗和交互的需求。提供高性价比，高稳定性的系统支持。 系统的组成 内核 基于开源的Liunx3.4的内核版本 针对物联网行业裁剪优化 系统 自主的GUI框架 网络API 多媒体服务 物联网平台接入 支付平台接入能力 远程更新系统能力 远程推送消息的能力 开发支持 提供所见即所得组态式GUI开发工具 提供完整的逻辑代码开放编写部分 不断更新的文档和样例支持 不断更新的控件包和系统升级服务 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"docs_brief.html":{"url":"docs_brief.html","title":"入门须知","keywords":"","body":"入门须知 对于新手，这里提供了一份入门指南。 工具篇 在开始使用我们的屏之前，得先把开发工具安装好； 打开工具，简单的熟悉一下开发环境，可以尝试着新建个工程，浏览一下有哪些内容，不必深究里边的细节; 新建的工程UI上面是没有东西的，我们可以先拖放个文本控件上去，然后编译、运行到我们的屏上看效果；注意：如果你的是wifi版本的机器，务必配置好ADB IP，才能正常下载；参考该文档; 我们已经提供了大量的样例代码，选择相应平台尺寸的代码包下载下来，解压出来，导入到工具里边；工程比较多，这些后边章节会具体介绍，这里我们可以选择自己感兴趣的例子运行到我们的屏上看效果； 至此，工具的简单使用相信你也就会了； 规则篇 熟悉了一下工具后，我们接下来再来了解一下这屏的开发规则; 了解工程的目录结构，可以知道工程包含了哪些内容，我们的代码、UI及资源分别存放在什么目录下； 接下来我们再来了解一下哪些内容是工具自动生成的，UI文件与源码之间是怎样的一个对应关系以及UI上面的控件命名规则；了解了这些之后，我们就清楚自己的代码需要填在什么地方，怎么操作控件； 控件篇 开发界面，离不开各个控件的使用，在文档的导航栏里，有专门的大章介绍各个控件的使用 —— 控件介绍； 串口篇 首先得清楚串口在我们屏上的通讯模型； 然后根据提供的案例动手试验一下，再在这基础上，增加点协议，增添点功能； 之后再去研究通讯框架的实现； 升级篇 有两种升级方式： 制作镜像文件 —— update.img文件；通过这种方式将程序固化到机器里边，掉电了程序还在，注意与普通的下载调试的区别；这种方式也是我们最常用的； 制作刷机卡 —— 格式化整机；系统有新版本更新，我们官方会提供相应的sd文件，制作成刷机卡刷机即可升级；像：系统开不了机、需要系统支持新功能或修复相关bug等等，这些情况下才需要刷机； 调试篇 目前只能通过添加日志的方式调试程序； 模组篇 参见核心模组使用说明 硬件篇 参见硬件使用说明 问题篇 这里汇总了一些常见的问题及解决方案； 联系我们 QQ群：371608200 论坛：SuperV powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"download.html":{"url":"download.html","title":"环境安装","keywords":"","body":"搭建开发环境 集成开发环境下载 FlyThings IDE（20210526-0806） SDK [!TIP] 对于新用户，FlyThings IDE安装包中已包含此SDK部分，无需重复下载。 安装的IDE并不包含所有平台的SDK，如果需要，可单独下载指定平台的SDK压缩包，使IDE可以支持更多的平台。 首先下载平台的SDK压缩包，然后解压到ide安装路径下的 sdk/platforms文件夹下， 在IDE的新建项目向导中，即可看到对应平台的选项。 （如果未加载成功，请检查解压的位置是否正确，或者下载安装最新的IDE） Z11S Z6 / Z6S A33NOR H500S SSD Z20 Z21 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"flythings_ide_snapshot.html":{"url":"flythings_ide_snapshot.html","title":"初次使用","keywords":"","body":"初次使用FlyThings 集成开发工具 如果你已经成功安装了FlyThings IDE,那么在你的桌面上，找到 快捷方式，双击运行。如果你删除了快捷方式，你还可以在安装目录中的bin文件夹下，找到 直接运行。 选择工作空间 当你运行工具之后会弹出如下界面。 工作空间 用于存储相关设置及历史纪录，你可以将它理解为一个容器，它可以同时管理多个项目，这样不用同时运行多个开发工具。 欢迎界面 如果你第一次打开该软件，或者选择了一个新的工作空间，那么，你会看到下图这样的欢迎界面。 它提供了两个快捷功能： 新建项目 和 导入项目 新建项目它会逐步引导你 如何新建FlyThings项目 导入项目通过它，你可以将现有的项目导入到目前的工作空间，继续之前的开发。如何导入项目 我们现在不着急 新建项目 ，先在左上角选择 关闭欢迎界面。如果你想重新打开欢迎界面，在顶部 菜单栏 上，依次选择 帮助 -> 欢迎 菜单即可。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"flythings_ide_layout_introduce.html":{"url":"flythings_ide_layout_introduce.html","title":"工作区域介绍","keywords":"","body":" FlyThings IDE 工作区域使用介绍 当你新建项目完成后，你将看到如下界面 编辑器大致分为六个区域。分别的作用如下： ① 区域 - 项目资源管理器 它将项目文件夹内的资源文件、代码文件等以树形图的形式显示。你可以自由展开/收起，双击文件可以直接打开编辑。具体演示如下： ② 区域 - UI编辑框 主要负责UI界面的编辑和即时预览，他是开发中主要的操作区域 ③ 区域 - 控件画板 它包含了所有内置的控件，你可以点击选择需要的的控件，将其拖拽到 ②区域 即可完成控件的创建。具体演示如下： ④ 区域 - 属性表 当你在 区域② 中选择了某个控件后，它的所有属性将在这里以表格的形式显示，你可以在表格中自定义修改。例如修改文字大小，具体演示如下： ⑤ 区域 - 大纲视图 它将已经创建的所有控件以树形图的形式展示；同样支持自由展开/收起； 可以清晰的了解控件之间的层级关系；并且可以直接拖拽某个节点，快速调整层级位置；双击节点可以快速显示/隐藏控件，这个在层级关系复杂后，非常好用。 具体演示如下： ⑥ 区域 - 控制台 编译代码时，这个位置将输出编译日志。如果编译失败，双击错误提示内容，可直接跳转到对应代码。如下图，演示双击错误提示内容，直接跳转代码。 有了以上的基础后，现在，我们可以正式开始开发。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"new_flythings_project.html":{"url":"new_flythings_project.html","title":"新建项目","keywords":"","body":"如何新建FlyThings项目 新建一个FlyThings项目十分简单。具体步骤如下： 在编辑器顶部的菜单栏中，依次选择 文件 -> 新建 -> FlyThings项目 上一步选择完成后，将弹出 FlyThings创建向导 提示框。 按要求填写新建项目相关的参数。 这些参数分别是： 项目名项目的名称；可以是字母、数字的组合，不能出现中文及空格。 位置项目的存储路径；同样不推荐路径中出现中文，防止编译异常。 平台类型根据购买的串口屏选择相应的平台，目前有 Z11S Z6S 规范填写如上必须参数后，你可以直接选择 完成 ，来快速完成创建。但是现在，我们选择 下一步 来自定义更多的参数。 点击下一步之后，我们将看到更多的参数定义 项目各个属性的含义及作用： 屏保超时时间FlyThings系统提供屏保的功能。如果在指定的时间内，串口屏没有任何触摸操作，或者你没有通过代码重置屏保计时，那么，系统将自动进入屏保。如果时间为 -1 秒， 表示禁止屏保功能。 串口指定通讯串口，一般情况下不需要修改。 波特率指定通讯串口的波特率 分辨率以像素为单位，指定屏幕的宽高 屏幕旋转针对某些屏幕坐标轴方向不同，可勾选该选项，将显示内容旋转90°，达到正常显示。 字体FlyThings支持自定义字体，如果你不满意默认字体，可取消默认，再选择你的字体文件。 输入法如果你有中文输入的需求，可以勾选它， 配合 编辑输入框 控件，就可以解决中文输入了。 以上属性后续都可以再次修改，所以不必过分担心填写错误。(如何修改已有项目的属性)属性都填写确认后，点击 完成 结束创建，创建过程会花费些许时间，耐心等待。 项目创建完成后，你应该先了解 FlyThings 项目代码结构介绍 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"import_project.html":{"url":"import_project.html","title":"导入项目","keywords":"","body":"如何导入FlyThings项目 我们可以将下载的示例代码导入到目前的工作空间中。导入步骤如下。 找到工具顶部的菜单栏，依次选择菜单 文件 -> 导入 。 在弹出框中， 依次选择 常规 -> 现有项目到工作空间中， 再选择 下一步。 在弹出框中 选择 浏览 按钮，指定需要导入项目的文件夹。 点击 确定, 它会自动解析文件夹内包含的项目。 如果项目文件没有损坏，你可以看到已经识别出来的项目，然后直接点击 完成 ，导入的项目就会出现在 项目资源管理器中，你可以继续查看/编辑它。 具体导入动画 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"new_flythings_ui_file.html":{"url":"new_flythings_ui_file.html","title":"新建UI文件","keywords":"","body":"如何新建FlyThings UI 文件 新建UI文件与 新建FlyThings 项目类似。 在项目资源管理器中，展开需要创建UI文件的项目，选中项目下的 ui 文件夹，然后点击右键，在弹出菜单中，依次选择菜单 新建 -> FlyThings UI 文件。 以上操作后，会弹出一个 新建FlyThings UI 文件向导 框，如下所示： ( 有三个参数你要你指定： 文件名你需要指定UI文件的文件名，文件名以字母、数字命名，以 ftu (FlyThings UI File) 为后缀名。 分辨率你可以通过调整分辨率来控制UI界面的宽高，以像素为单位； 窗口类型目前有四种窗口类型，分别为 普通、状态栏、导航栏、屏保。一般情况下我们保持 普通 选项就可以。其他三种类型的具体讲解，可以参考系统应用介绍 确定参数后，选择 完成 ，创建过程结束。你可以在项目资源管理器中，项目的ui文件夹下看到新创建的UI文件。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"how_to_compile_flythings.html":{"url":"how_to_compile_flythings.html","title":"编译项目","keywords":"","body":"如何编译FlyThings项目 编译FlyThings项目十分简单。根据操作方式的不同，如下有三种方式可以编译。 1. 从项目资源管理器选择编译 具体步骤是： 在项目资源管理器中，左键选中需要编译的项目名，然后右键，在弹出菜单中，选择 编译FlyThings 选项即可自动编译该项目。 操作的动画如下： 2. 通过工具栏选择编译 在软件顶部的工具栏上有编译的快捷方式。 同样，先在项目资源管理器中，左键选中需要编译的项目名，然后再工具栏上找到 该绿色三角符号按钮，点击它，即可编译选中的项目。 3. 通过快捷键编译 你可能在上面的两个步骤中，已经注意到了编译的快捷键，也就是 Ctrl + Alt + Z，强烈推荐使用该方式编译。 在编辑了代码后，直接 Ctrl + Alt + Z 快速完成编译，十分方便。 如何清理项目 在项目编译过后，通常会留下些编译的目标文件和中间文件。比如 libs 和 obj文件夹 ，它们的存在是为了加快编译速度，达到增量编译。 你可以手动删除它们，或者通过菜单来自动清理。 手动删除先选中需要删除的文件夹，右键，在弹出菜单中，选择 删除 选项。 自动清理如果总是手动执行删除，可能会造成误操作，造成重要文件的丢失。所以，利用自动清理，可以有效避免这种情况。 同样是先选中需要操作的项目名，右键，在弹出菜单中，选择 清空项目 选项。它会自动删除 libs 文件夹和 obj 文件夹里的编译中间文件。推荐使用此方式来清理文件。 注意：如果编译时遇到奇怪的问题，或者遇到源码没有编译进程序的问题时，可以尝试先清理项目后，再重新编译。特别是当你导入他人的项目时，这种情况容易频发。 如何重新编译 如果你想完全重新编译代码，那么你可以先清理项目后，再次编译即可 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"run_project.html":{"url":"run_project.html","title":"运行项目","keywords":"","body":"如何运行项目 项目通过编译后，就可以放到真机运行。根据设备型号的不同，有如下几种运行方式： 使用WIFI连接设备快速运行 该方式 仅支持带WIFI 的机型，暂支持的设备型号有 sw480272043B_CW 4.3普清电容带wifi sw480272043B_CWM 4.3普清wifi网络多媒体 sw80480043B_CW 4.3高清电容带wifi sw48854050B_CW 5寸普清电容带wifi sw80480070A_CW 7寸普清电容带wifi sw80480070A_CWM 7寸普清wifi网络多媒体 sw80480070AI_CW 7寸普清电容带wifi sw80480070AI_CWM 7寸普清>电容wifi网络多媒体 sw10600070A_CW 7寸高清电容带wifi 产品型号说明 确定设备支持WIFI后，按照以下步骤完成配置： 先进入设备的WIFI设置界面，将设备连接到与电脑相同的无线网络，也就是说，电脑和机器必须接入同一个WIFI。（如果不同的网络会导致后续下载程序失败）。 无线网络连接成功后，点击WIFI设置界面右上角的菜单，查看设备的IP地址。 这时，回到电脑上的开发工具，在菜单栏上，依次选择菜单 调试配置 -> ADB配置， 在弹出框中，ADB连接方式选择WIFI， 并填入设备的IP地址，应用保存。 完成连接配置后，再选择下载调试菜单项，它会暂时将项目代码同步到连接的设备中运行。 使用USB连接设备快速运行 对于不带WIFI功能的型号，几乎都支持USB线连接。 注意：如果带有WIFI功能，USB线连接是无效的。 将设备与电脑通过USB线连接，如果电脑能将设备识别为Android设备，表示连接正常。 如果不能正常连接，电脑提示驱动问题，可尝试下载驱动。 当电脑正确识别设备后，回到电脑上的开发工具，在菜单栏，依次选择菜单 调试配置 -> ADB配置， 在弹出框中，ADB连接方式选择USB，应用保存。 配置完成后，再选择下载调试菜单项，它会暂时将项目代码同步到连接的设备中运行。 借助TF卡，从TF卡启动 如果由于其他原因，USB和WIFI都不能正常使用、或者被占用，此可借助TF卡，从TF卡启动程序。 具体步骤参考教程-从TF卡启动程序 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"project_structure.html":{"url":"project_structure.html","title":"项目结构介绍","keywords":"","body":"FlyThings项目代码结构介绍 开始编写代码之前，首先要了解一个FlyThings项目的基本构成，然后你就能知道自己的代码应该添加到哪个位置。对于一个基本的FlyThings项目，它的目录结构是这样的： 大致分为 jni 、resources 、 ui 三个文件夹。下面分别解释各个文件夹的作用。 ui 文件夹 展开 ui 文件夹 可以看到默认包含了一个 main.ftu 文件。ftu 是FlyThings 项目UI文件的后缀名。每一个 ftu 文件对应一个应用界面。通常，一个应用包含多个界面，所以你需要在 ui 文件夹下创建多个 ftu 文件。添加新的 ftu 文件，可以参考 如何新建FlyThings UI文件。 为了描述方便，以后的教程中，统一将 ftu 文件称为 UI文件。你可以双击打开 UI文件 ，并对它进行编辑，并且可以即时预览效果。编辑 UI 文件的具体步骤，可以参考控件介绍的教程。编辑结束后，你就可以开始 “编译” (如何编译） [!Note] 注意： 这里所说的编译不仅仅是编译源代码，还包括对 ui文件的预处理，以及生成模板代码等一系列操作，但是这些都是自动化的，你无需手动操作。编译这一动作背后的所有具体操作，请参考 具体编译过程以及UI文件与源代码的对应关系，看完后，相信你会更容易理解，并且快速上手开发 resources 文件夹 这个文件夹的内容就比较简单，主要用来存放项目的各种资源文件，包括 图片、字体、输入法配置文件等。如果你还有其他资源文件也可以添加到该文件夹，该文件夹会完全拷贝到机器中。 但是，由于机器自身存储空间的限制，不建议将大文件存放到该目录，更推荐你将较大的资源文件存放到TF卡中。 我们可以在代码中获取resources目录下的某个文件的绝对路径。 例如： 如下代码可以获取resources/test.txt的绝对路径。 #include \"manager/ConfigManager.h\" std::string resPath = CONFIGMANAGER->getResFilePathEx(\"test.txt\"); jni 文件夹 该文件夹主要为存放代码文件，她还包含了多个部分的代码。我们将 jni 文件夹展开 可以看到，它包含了 activity 、 include 、logic 、uart 、Main.cpp、 Makefile 共6个部分，每个部分作用如下： activity 子文件夹 存放UI文件的基础类代码。每一个UI文件，经过编译后，都会生成相同前缀名的Activity类和Logic.cc文件。例如：ui文件夹下有一个 main.ftu，那么经过编译后，会生成 mainActivity.h、mainActivity.cpp以及mainLogic.cc， mainActivity类会存放在 activity 文件夹中，mainLogic.cc文件会存放在 logic 文件夹中。 [!Warning] 强烈推荐不要手动修改 activity 文件夹下的代码，特殊情况除外 logic 子文件夹 存放具体的逻辑代码。与上面的描述相同，每一个UI文件在编译后都会生成相对应前缀名的 Logic.cc 文件，注意：我们的自定义代码，主要就是添加在这些 Logic.cc文件中。 include 子文件夹 这里主要存放系统相关的头文件、所有控件相关的头文件。便于编译。 uart 子文件夹 顾名思义，该文件夹存放串口操作相关的代码，包括读写串口，协议解析等。 Main.cpp 整个FlyThings应用的入口代码，包括选择开机的界面以及一些初始化，一般情况不需要修改该文件。 Makefile/Android.mk、Application.mk 编译配置文件，包含了具体的源码编译过程，一般情况下不需要修改 在编译通过后，会在项目下生成 libs目录，和 obj 目录，它们分别是编译的目标存放目录和编译的中间文件目录，这两个都可以自行清理或者直接删除都没有关系。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"ftu_and_source_relationships.html":{"url":"ftu_and_source_relationships.html","title":"UI文件与生成代码讲解","keywords":"","body":"FlyThings编译过程以及UI文件与源代码的对应关系 UI文件中的控件是如何与指针变量关联的 FlyThings 将UI与代码区分开来，方便管理。 下文中，UI文件是指项目 ui 文件夹下的 所有 ftu 文件。 为了减少开发中编写重复代码，我们改进了编译过程。在真正的源码编译之前，工具会根据 UI文件生成相同前缀名的Logic.cc 文件，例如main.ftu会生成配对的mainLogic.cc文件，这里需要注意的是：Logic.cc文件的生成，并不是直接覆盖，而是增量修改。编译时，工具会遍历每个UI文件，读取UI文件中包含的控件。并且为这个控件声明指针变量，在代码中，通过这个指针，就可以操作对应的控件。 指针变量定义在同前缀名的 Activity.cpp 文件中。以main.ftu为例，就像这样： 图中可以看到， 所有指针为静态全局变量，它们都具有相同的命名规则，具体命名规则请参考控件ID名与指针变量名的命名规则；并且，你还应该注意到截图中 #include \"logic/mainLogic.cc\" 这条语句，它将 mainLogic.cc文件include到mainActivity.cpp当中，而我们的业务代码就是写在mainLogic.cc文件里，所以，我们可以在mainLogic.cc中完全使用这些控件指针。如果你对这些指针的初始化感兴趣，可以在mainActivity的onCreate方法中找到。 UI文件与Logic.cc文件的关系 现在，你大概已经知道了UI文件里的控件是如何与这些指针联系起来的。 让我们再来看看mainLogic.cc文件里又为我们自动生成了哪些代码。如果你的UI文件中没有添加任何控件，那你的mainLogic.cc文件将是这样的: /** * 注册定时器 * 填充数组用于注册定时器 * 注意：id不能重复 */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //定时器id=0, 时间间隔6秒 //{1, 1000}, }; /** * 当界面构造时触发 */ static void onUI_init(){ //Tips :添加 UI初始化的显示代码到这里,如:mText1Ptr->setText(\"123\"); } /** * 当切换到该界面时触发 */ static void onUI_intent(const Intent *intentPtr) { if (intentPtr != NULL) { //TODO } } /* * 当界面显示时触发 */ static void onUI_show() { } /* * 当界面隐藏时触发 */ static void onUI_hide() { } /* * 当界面完全退出时触发 */ static void onUI_quit() { } /** * 串口数据回调接口 */ static void onProtocolDataUpdate(const SProtocolData &data) { } /** * 定时器触发函数 * 不建议在此函数中写耗时操作，否则将影响UI刷新 * 参数： id * 当前所触发定时器的id，与注册时的id相同 * 返回值: true * 继续运行当前定时器 * false * 停止运行当前定时器 */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } /** * 有新的触摸事件时触发 * 参数：ev * 新的触摸事件 * 返回值：true * 表示该触摸事件在此被拦截，系统不再将此触摸事件传递到控件上 * false * 触摸事件将继续传递到控件上 */ static bool onmainActivityTouchEvent(const MotionEvent &ev) { return false; } 这些函数的具体作用如下： REGISTER_ACTIVITY_TIMER_TAB[ ] 数组用于注册定时器； 数组成员类型为如下结构体 typedef struct { int id; // 定时器ID ， 不能重复 int time; // 定时器 时间间隔 单位 毫秒 }S_ACTIVITY_TIMEER; 实质上，这个数组将在 mainActivity.cpp的rigesterActivityTimer()函数中引用，通过调用 void registerTimer(int id, int time)方法依次注册到系统中。 void onUI_init()用于界面初始化，如果在打开这个UI界面的时候，你需要初始化一些内容，那么你可以将代码添加到这函数里。实质上，这个方法将在mainActivity.cpp的onCreate()方法中调用。你可以理解为mainActivity的构造。 void onUI_quit()用于界面的退出，如果你需要当UI界面退出的时候做一些操作，那么你可以将代码添加到这函数里。 实质上，这个方法将在mainActivity.cpp的析构函数中调用 void onProtocolDataUpdate(const SProtocolData &data)用于接收串口数据。当解析到串口数据帧时，会调用该函数。实质是， mainActivity.cpp的onCreate()中，会默认调用void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener)进行接收串口数据的注册， 在mainActivity.cpp的析构中取消注册。当串口读到数据时，通过ProtocolParser.cpp中的void notifyProtocolDataUpdate(const SProtocolData &data)依次调用已注册的UI界面。这是ProtocolParser.cpp中的串口解析函数，结合上面描述的过程，你应该就能理解串口数据是如何在各个界面分发的： /** * 解析每一帧数据 */ static void procParse(const BYTE *pData, UINT len) { switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; } // 通知协议数据更新 notifyProtocolDataUpdate(sProtocolData); } bool onUI_Timer(int id)定时器回调函数； 当某个定时器达到规定的时间间隔后，系统将调用该函数，当添加了多个定时器时，你可以通过 id 参数，区分定时器。这个 id 参数与 上面结构体数组中填写的 id 相同。返回 true 则继续运行当前定时器;返回 false 则停止运行当前定时器;如果你通过返回 false停止了定时器，那么如何再次开启它呢？可以参考 如何任意开启停止定时器 bool onmainActivityTouchEvent(const MotionEvent &ev)触摸事件回调函数。能够得到所有的触摸消息。同样，该函数也是在mainActivity.cpp中通过registerGlobalTouchListener方法默认注册；只有注册之后才能得到触摸消息。返回 true 则表示该触摸事件在此被拦截了，不再传递到控件上返回 false 则表示触摸事件将继续传递到控件上了解更多触摸事件的处理 以上是默认的UI文件编译生成的Logic.cc。当我们在UI文件中添加控件后，再次编译时，工具会根据不同的控件生成不同的关联函数到对应的Logic.cc文件中。例如：我在main.ftu 这个 UI文件中添加了两个按键控件，它们的ID分别是 Button1 、Button2，那么，经过编译之后，在 mainLogic.cc文件中会生成以下两个关联函数 static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } static bool onButtonClick_Button2(ZKButton *pButton) { //LOGD(\" ButtonClick Button2 !!!\\n\"); return false; } 注意函数的命名，函数名称中包含了控件的ID名，所以我们要求控件的ID命名需要符合C语言命名标准。如果你不断的添加控件，那么编译后会生成更多的关联函数到 mainLogic.cc 文件中。通常，在开发中，我们会在UI文件中多次增加、删除、修改控件，针对这些情况，目前的解决方案如下： 对于增加控件的情况，编译时工具会根据控件ID名生成关联函数，如果已经存在相同的关联函数，那么将略过。不会对Logic.cc文件造成任何影响。 对于删除控件的情况，如果在UI文件中，将已有的控件删除，工具并不会将它的关联函数也删除。如果将关联函数也删除，那么很可能会造成客户代码的丢失，所以，我们选择保留它。 对于修改控件的情况，关联函数的生成只与控件ID名有关，如果你在UI文件中，修改控件除了ID名的其他属性，将不会对关联函数造成影响；如果你修改了控件ID名属性，那么编译时，将按照增加控件的情况来处理，旧关联函数保留。 上面我们只以按键控件为例，讲述了UI文件中的控件与Logic.cc内生成的关联函数的关系，FlyThings还提供生成其他控件的关联函数，比如 滑动条、列表、滑动窗口等控件，了解其他控件的关联函数，请参考控件自动生成的关联函数讲解 最后用一张图来总结ftu文件与代码的对应关系： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"named_rule.html":{"url":"named_rule.html","title":"控件的命名规则","keywords":"","body":"控件的命名规则 我们在UI文件中添加的大部分控件，经过编译后，都会自动生成一个对应的指针变量以及一个宏定义整型值。 控件ID名称与指针变量名的命名规则 指针变量名由三部分构成。 分别为固定的小写 m 作为前缀 + ID名 + Ptr 作为结尾以ID属性为 Textview1 的控件为例 编译后，生成的对应的指针变量名为 mTextview1Ptr 指针变量的类型根据控件类型而定。 各个控件对应指针类型如下：各个类的头文件都可在项目 jni/include 文件夹下找到。 控件名 类名 ZKQRCode ZKEditText ZKButton ZKTextView ZKSeekBar ZKPointer ZKCircleBar ZKDigitalClock ZKVideoView ZKCameraView ZKWindow ZKListView ZKSlideWindow ZKDiagram 控件ID名称与宏定义整型值的命名规则 该宏定义表示 UI文件中控件的映射关系。 该宏定义由三部分构成。分别为固定的大写 ID 、大写的UI文件名、控件ID属性名称构成。以ID属性为 Textview1 的控件为例 编译后，生成的对应的宏语句为 #define ID_MAIN_TextView1 50001 [!Warning] 请勿随意更改宏定义的整型值，否则会造成程序异常。 控件自动生成的关联函数讲解 有些控件会自动生成关联函数。这些控件生成的关联函数的具体讲解如下： [!Note] 函数中出现的XXXX代表控件ID名称，实际过程中，请自行替换 按键控件 static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } 当点击按键时，会调用该函数。 参数ZKButton *pButton是被点击按键的指针，通过该指针的成员函数可以对控件进行一系列操作。 该指针与全局变量mXXXXPtr所指向的对象为同一对象。 编辑输入框控件 static void onEditTextChanged_XXXX(const std::string &text) { } 当输入框中的文字发生改变时，系统会自动调用该函数。 参数std::string &text是当前输入框中的完整字符串。 滑块控件 static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } 当滑块当前进度值发生变化时，系统会自动调用该函数。 参数ZKSeekBar *pSeekBar 是该滑块控件的指针，通过该指针的成员函数可以对控件进行一系列操作。 参数int progress是当前滑块的的进度值 滑动窗口控件 static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } 当点击滑动窗口控件中的某一个图标时，系统会自动调用该函数。 参数ZKSlideWindow *pSlideWindow 是该滑动窗口控件的指针，通过该指针的成员函数可以对控件进行一系列操作。 参数int index是当前被点击图标的索引值。例如该滑动窗口一共添加了10个图标，则索引值范围是[0, 9] 列表控件 列表控件是最复杂的一个控件，它会创建三个关联函数。虽然函数较多，但是按照下面的步骤理解起来也十分容易。 首先，系统想要绘制一个列表控件，需要知道它一共有多少项。于是有了下面这个关联函数 static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } 参数const ZKListView *pListView 是该列表控件的指针， 它与全局变量mXXXXPtr指向同一个对象。 返回值是整形， 表示该列表一共有多少项，可以根据你的需求来定义。 系统知道了需要绘制的数目后，还不够，还需要知道你每一项都分别显示哪些内容。于是有了下面这个函数，它会多次调用，让你设置每一项的显示内容，直到每一项都处理完毕。 static void obtainListItemData_XXXX(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } 参数ZKListView *pListView 是该列表控件的指针， 它与全局变量mXXXXPtr指向同一个对象。 参数ZKListView::ZKListItem *pListItem 是列表项的指针，与UI文件中的Item对应 参数int index是pListItem在整个列表中的索引值。它具有一定范围，例如：getListItemCount_XXXX函数返回值为10，则表示列表共有10项，那么index的范围是[0, 9]，结合pListItem和index,你就能知道现在设置的这个列表项处于整个列表的什么位置。 在这个函数里，你可以根据index分别设置每一项的显示内容。例如： 函数中注释的语句就表示：每一个列表项都显示它对应的索引号。 与按键控件类似，列表控件同样有点击事件，只不过它是根据索引值来判断当前点击的是哪一个列表项。 static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } 当点击列表控件时，系统会根据触摸的坐标，判断触点落在哪一个列表项上，计算出该列表项的索引号后，系统会自动调用该函数。 参数ZKListView *pListView 是该列表控件的指针， 它与全局变量mXXXXPtr指向同一个对象。 参数int index 是当前被点击的列表项在整个列表控件中的索引值 参数int id 是当前被点击的控件的整形id。注意，这个id与属性表中的ID名称不同。它的具体宏定义在相应的Activity.h文件中。 例如mainActivity.h中 这个id参数的作用在于，当列表项中有多个子项时，可以用来区分当前被点击的是哪一个子项。例如: 如下图，我在列表项中添加了两个列表子项,并添加了图片装饰，来作为开关按钮，属性ID名分别为SubItem1、SubItem2，当我点击SubItem1时，通过判断参数id与ID_MAIN_SubItem1、ID_MAIN_SubItem2的相等关系，就能确定点击的是哪一个开关。具体代码： static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"点击了列表第%d项的第一个子项\", index); break; case ID_MAIN_SubItem2: //LOGD(\"点击了列表第%d项的第二个子项\", index); break; } } 最后我们用一张图来总结它们之间的规则: 其他控件以此类推 [!Note] ### 技巧之：快速跳转至关联函数 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"editor_tip.html":{"url":"editor_tip.html","title":"开发工具常用技巧","keywords":"","body":"开发工具常用设置 快速跳转至关联函数 当我们在UI文件中添加了过多的控件时，Logic.cc文件中也会生成多个关联函数。如果想要查找某个控件的关联函数是相当费时的事。好在工具提供了一个从UI控件 快速跳转至相关代码 的功能。在预览图上，选中一个控件，右键，在弹出菜单中选择 跳转到相关代码，即可打开对应的Logic.cc文件，并且会将光标定位到该控件的关联函数的位置。 注意：该功能仅对会自动生成关联函数的控件类型有效，比如上文中提到的控件类型，如果你选择的是其他控件类型，那么功能只会跳转到相对应的Logic.cc文件，并将光标定位于文件底部。 修改字体/字体大小 在工具的菜单栏上， 选择 窗口 -> 首选项 在弹出框中， 依次按照下图选择，即可设置字体。 代码智能补全 编辑代码时，先需要输入起始部分，然后键入 Alt + / 可以打开代码补全功能。如下图， 我输入的 UA 两个字母， 然后键入 Alt + / 快捷键， 可以看到给出了多个补全选项， 用上下方向键可以进行选择。Enter键确认选择。 重建索引 如果出现代码补全功能失效，或者编辑器提示代码错误，但是编译却没有问题的情况，请尝试重建索引。 重建索引的步骤如下： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"ctrl_common.html":{"url":"ctrl_common.html","title":"通用属性","keywords":"","body":"通用属性 在开始介绍各个控件之前，我们先来基本的了解一下控件的一些通用的属性及设置接口； 控件ID值 ID值为控件的唯一标识，每一个ftu文件里的控件ID值是不允许重名的，不同的ftu文件里的控件ID值允许重名；设置ID值后，编译完会在activity目录下对应的头文件中生成相应的宏定义： 获取控件的ID值: /** * 该接口定义于控件基类ZKBase中 * 头文件位置： include/control/ZKBase.h * * 注意： 以下接口如未特殊说明，都表示定义在ZKBase类中 * 所有控件直接或间接的继承了ZKBase类，所以，所有的控件都可以调用ZKBase类中public接口 */ int getID() const; /* 操作样例： 点击按钮控件，打印该控件ID值 */ static bool onButtonClick_Button1(ZKButton *pButton) { int id = pButton->getID(); LOGD(\"onButtonClick_Button1 id %d\\n\", id); return false; } 控件位置 我们打开任一ftu文件，选中任一控件，在属性框中，我们可以看到坐标这一属性，该属性确定了该控件的显示位置： 其中左上角的坐标值是相对于父控件左上角位置； 通过代码设置和获取控件的位置： /* 接口说明 */ // 设置位置 void setPosition(const LayoutPosition &position); // 获取位置 const LayoutPosition& getPosition(); /* 操作样例 */ // 点击按钮控件，设置该按钮位置 static bool onButtonClick_Button1(ZKButton *pButton) { // 左：0，上：0，宽：100，高：200 LayoutPosition pos(0, 0, 100, 200); pButton->setPosition(pos); return false; } // 点击按钮控件，获取该按钮位置 static bool onButtonClick_Button2(ZKButton *pButton) { // pos的mLeft、mTop、mWidth、mHeight变量分别对应的就是坐标值 LayoutPosition pos = pButton->getPosition(); return false; } 背景色 这个比较简单，修改一下颜色就可以看到效果了； 代码设置背景颜色： /** * Z6、Z11、A33平台接口定义 * color为-1时，背景设置为透明；其他颜色值为0x RGB，颜色值不支持alpha */ void setBackgroundColor(int color); /** * H500S、Z20、Z21及以后平台接口定义 * color 颜色值为0x ARGB，支持alpha */ void setBackgroundColor(uint32_t color); /* 操作样例： 点击按钮控件，设置背景颜色为红色 */ static bool onButtonClick_Button1(ZKButton *pButton) { pButton->setBackgroundColor(0xFFFF0000); return false; } 背景图 选择好图片后就可以看到效果了 这里我们重点的来说明如何通过代码来设置背景图： /** * pPicPath参数可以有以下两种方式： * 1. 绝对路径，如：\"/mnt/extsd/pic/bg.png\" * 2. 相对资源目录路径，只需把图片放到项目工程resources目录下，编译打包后，就可以使用了，如resources目录下有bg.png图片，只需设置\"bg.png\"即可 */ void setBackgroundPic(const char *pPicPath); /* 操作样例 */ mButton1Ptr->setBackgroundPic(\"/mnt/extsd/pic/bg.png\"); // 设置绝对路径 mButton1Ptr->setBackgroundPic(\"bg.png\"); // 设置resources目录下bg.png图片 显示与隐藏 通过该属性，我们可以设置控件默认是显示还是隐藏状态；双击大纲视图中的控件可以快捷的修改该状态： 另外，我们还可以通过代码动态的设置控件显示和隐藏： void setVisible(bool isVisible); bool isVisible() const; /* 操作样例 */ mButton1Ptr->setVisible(true); // 显示按钮控件 mButton1Ptr->setVisible(false); // 隐藏按钮控件 /** * 窗口控件还可以使用下面的接口，功能一样 * 头文件位置： include/window/ZKWindow.h */ void showWnd(); // 显示窗口 void hideWnd(); // 隐藏窗口 bool isWndShow() const; // 窗口是否显示 /* 操作样例 */ mWindow1Ptr->showWnd(); mWindow1Ptr->hideWnd(); 控件状态 对于文本、按钮、列表子项它们有5种状态，这里我们需要讲解一下：正常显示状态、按下状态、选中状态、选中按下状态、无效状态，设置完后会影响到控件对应状态的背景颜色、文本颜色及显示图片； 按下状态不需要通过代码设置，触摸控件即为按下状态； 选中状态和无效状态的代码操作接口： // 设置选中状态 void setSelected(bool isSelected); bool isSelected() const; /* 操作样例 */ mButton1Ptr->setSelected(true); mButton1Ptr->setSelected(false); /** * 无效状态作用说明：控件设置为无效状态情况下，触摸控件没有作用，即不响应按下抬起事件 */ // 设置无效状态 void setInvalid(bool isInvalid); bool isInvalid() const; /* 操作样例 */ mButton1Ptr->setInvalid(true); mButton1Ptr->setInvalid(false); 样例说明 我们通过以下的小例子来了解通用属性的相关接口函数简单用法。 1.创建控件 首先，我们新建一个Flythings项目,双击打开项目UI文件夹下的main.ftu文件，在控件栏中分别拖出按键控件和文本控件。 2.编译项目 (如不清楚具体操作请看《如何编译FlyThings项目》章节) 3.调用控件属性函数 编译完成后，打开项目中jni/logic/mainLogic.cc文件,可以看到文件最下方生成了onButtonClick_Button1 函数。 我们将在该函数中调用getID()函数获取按键控件Button1的ID值，调用setText()函数在文本控件TextView1显示。 (如果你不清楚指针变量名与UI文件中控件ID的对应规则，点击这里) 4.下载调试 在项目管理器中，选择项目名，右键点击后，在弹出菜单中选择下载调试即可将程序暂时下载到屏上运行。 运行后，点击按键即可看到按键控件Button1的ID值为20001. 注意： 想要了解更多控件通用属性的设置接口函数可以打开/jni/include/control/ZKBase.h文件，主要的属性设置接口函数都已注释。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"textview.html":{"url":"textview.html","title":"文本","keywords":"","body":"文本类 TextView 注意 如果不清楚如何修改文本的通用属性请参考《通用属性》 我需要显示一段文字/标签，怎么办？ 如果需要显示文字，利用现有的Textview件就可以快速实现。具体操作步骤如下： 双击打开main.ftu文件 在右侧控件集合中找到文本控件 鼠标左键点击文本控件不放，然后将其拖拽到任意位置，松开左键，就能看到自动生成的文本控件。 如何通过代码动态更新文本内容？ 在串口屏的使用中，常常会动态更新文本内容。那么在代码中，我们可以通过文本控件对应的指针来动态更新文本控件的内容。具体操作步骤如下： 首先需要知道文本控件在代码中对应的指针变量（如果你不清楚指针变量名与UI文件中控件ID的对应规则，点击这里），这里以ID为Textview1的文本控件为例，它对应的指针变量为mTextview1Ptr， 如果我们想要将Textview1控件的文本内容修改为\"Hello World\",可以通过调用文本控件的成员方法void setText(const char *text)实现，在相应的Logic.cc文件中，具体代码为:mTextview1Ptr->setText(\"Hello World\"); 结合实际的使用情况举例。 下面代码的作用是：当ID为Button1的按键被按下时，将ID为Textview1的文本设置为“Hello World”static bool onButtonClick_Button1(ZKButton *pButton) { mTextview1Ptr->setText(\"Hello World\"); return false; } 文本控件除了可以设置字符串外，它还支持设置数字和字符： /* 接口定义见头文件: include/control/ZKTextView.h */ void setText(int text); // 设置数字 void setText(char text); // 设置字符 /* 操作样例 */ mTextview1Ptr->setText(123); // Textview1控件将显示\"123\"字符串 mTextview1Ptr->setText('c'); // Textview1控件将显示'c'字符 如何修改文字的颜色？ 默认的文本显示为白色，通常无法满足需求，那么可以通过以下两种方式来修改文本颜色。 在属性栏中直接修改控件的颜色 在项目资源管理器中，选择一个UI文件，双击打开； 在预览界面上，找到你要修改的控件，左键点击它，在编辑器的右侧就能看到该控件相应的属性表，这时候你就可以根据需要，填写自定义的属性值，就跟操作Excel一样, 找到你需要修改的属性，然后单击修改。 在文本控件中，可以看到有3个表项与颜色属性有关，分别是 颜色设置 该属性可以分别设置控件各个状态下文字的颜色值 背景色 设置控件整个矩形区域的背景颜色（不会根据控件状态的变化而变化） 背景颜色设置 对背景色属性的扩展，可以分别设置控件各个状态下的背景颜色 具体示例： 效果图： 上图是属性表颜色部分截图，其表示的含义为：背景颜色设置为黑色， 文字的颜色设置为白色，当控件设置为选中状态时，文字颜色变为红色。 通过代码控制颜色变化 在属性表中设置颜色具有直观、方便的特点，但是缺少灵活性，于是在代码中，通过控件指针，调用相应成员方法可以对颜色进行动态控制。 以ID为Textview1的文本控件为例，以下方法都可以达到修改颜色的目的。（如果你不清楚指针变量名与UI文件中控件ID的对应规则，点击这里） 以ID为Textview1的文本控件为例，以下方法都可以达到修改颜色的目的。 void setInvalid(BOOL isInvalid) //将控件Textview1 设置为无效状态；如果属性表中`无效时颜色`属性不为空，则将其设置为指定的颜色，否则无变化。 mTextview1Ptr->setInvalid(true); void setSelected(BOOL isSelected) //将控件Textview1 设置为选中状态；如果属性表中`选中时颜色`属性不为空，则将其设置为指定的颜色，否则无变化。 mTextview1Ptr->setSelected(true); void setPressed(BOOL isPressed) //将控件Textview1 设置为按下状态；如果属性表中`按下时颜色`属性不为空，则将其设置为指定的颜色，否则无变化。 mTextview1Ptr->setPressed(true); void setTextColor(int color) //参数color以16进制表示RGB颜色 //将控件Textview1 设置为红色。 mTextview1Ptr->setTextColor(0xFF0000); 如何显示小数 文本控件提供了设置string的接口。 /** * @brief 设置字符串文本 */ void setText(const char *text); 如果你想显示任何数字，都可以先用 snprintf 这个函数，将数字格式化为字符串，然后设置字符串，从而达到随意显示内容的目的。例如： float n = 3.1415; char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%.3f\", n); //固定显示3位小数，多余的小数位会忽略，不足则补0 mTextView1Ptr->setText(buf); snprintf 是一个C语言标准函数，你可以网上搜索相关资料了解，也可以查看这里的简要介绍及使用例子。 实现逐帧动画 由于文本控件可以添加背景图，我们可以利用它简单的显示一张图片。更近一步，如果我们在代码中动态切换文本控件的背景图，只要切换的时间间隔足够短，那么就能实现动画的效果。 图片资源准备一段流畅的帧动画必然需要多张图片资源。这里我们已经准备好了，共60张。 可以看到每张图片表示一帧，并且根据序号统一命名，这主要是方便后续使用。 注意： 系统加载图片时将消耗较多资源， 为了界面运行流畅，强烈建议图片不宜过大。 比如例子中的单张图片大小仅为5KB左右 将这些图片都拷贝到项目的 resources 目录下。你可以在 resources 目录下自行创建子文件夹，方便各种图片资源的整理归类。 创建文本控件在UI文件中任意创建一个文本控件。并将文本控件的背景图设置为其中一张图片。这里我将第一张图片设置为背景图。这一步仅仅是为了将文本控件的宽高自动调整为图片的宽高，你也可以选择不设置。完整属性如图： 编译项目，注册定时器 添加了文本控件后，再次编译项目，在生成的Logic.cc文件中，注册一个定时器，时间间隔设置为 50 ms。 我们利用定时器每隔50ms切换一张图片。 如何编译项目？ 如何注册定时器？ 动态切换文本控件的背景在相应的Logic.cc文件中，添加如下切换背景图的函数， 并在定时器的触发函数 bool onUI_Timer(int id) 中调用它。 static void updateAnimation(){ static int animationIndex = 0; char path[50] = {0}; snprintf(path, sizeof(path), \"animation/loading_%d.png\", animationIndex); mTextviewAnimationPtr->setBackgroundPic(path); animationIndex = ++animationIndex % 60; } 上面的函数中有两点我们需要注意： 切换文本控件的背景图是由 setBackgroundPic(char* path) 函数实现的。 setBackgroundPic(char* path)函数的参数是图片的相对路径。该路径是相对于项目中的 resources 文件夹而言。 例如：如下图，我们的图片是放在项目中 resources/animation/ 文件夹下，那么 loading_0.png 这张图片的相对路径为 animation/loading_0.png setBackgroundPic(char* path) 函数也可以接受绝对路径。例如：如果你将图片 example.png 放到TF的根目录下，那么它对应的绝对路径为 /mnt/extsd/example.png， 其中 /mnt/extsd/是TF卡的挂载目录。我们推荐所有图片资源放到项目的 resoources 文件夹下，或者其子文件夹下，因为其他路径的图片资源将不会被自动打包到软件中。 下载运行，查看效果 完整样例下载 特殊字符集的使用 我们知道，根据asc码的定义，字符 char 与 整形 int 存在着对应关系。比如字符 0 的asc码为48。 特殊字符集就是将asc码映射为图片的一种功能。设置该功能后，当我们显示一个字符串时，系统会尝试将字符串中的每一个字符映射为指定的图片，最终显示一串图片到屏幕上。 设置方法 找到文本控件中的 特殊字符集设置， 点击右侧的 更多选项，将弹出特殊字符集选择框。 选择右上角的 导入 按键添加图片到字符集中， 添加图片后，你可以自行修改对应的asc码或者字符作为该图片的映射字符。然后点击 保存 如果要验证特殊字集是否添加成功，你可以修改文字，预览图上会同步预览效果。注意：如果你设置了特殊字符集，那么系统会尝试将每个字符映射为字符集中指定的图片；如果某个字符没有设置图片的映射，那么这个字符将不会显示到屏幕上。 具体使用 在上面的特殊字符集设置框中，我们已经将字符 0-9 以及 : 冒号 分别映射为图片。 然后代码中，通过setText(char* str)函数设置字符串。由于我们在 TextTime 文本控件中设置了特殊字符集，所以字符都转变为了相应的图片。效果图如下： static void updateTime() { char timeStr[20]; struct tm *t = TimeHelper::getDateTime() sprintf(timeStr, \"%02d:%02\", t->tm_hour, t->tm_min); mTextTimePtr->setText(timeStr); } 如果你只需要显示单个字符，那么可以直接设置asc码或字符，不用转化为字符串。例如： mTextTimePtr->setText((char)48); //直接设置asc码，需要转为char mTextTimePtr->setText('0'); //直接设置字符 样例代码 由于文本控件属性较多，更多属性效果请参考样例代码中的TextViewDemo工程。 预览效果图： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"button.html":{"url":"button.html","title":"按键","keywords":"","body":"按键类 Button 我需要一个按键/按钮， 如何添加修改属性？ 如果需要一个按键/按钮，利用现有的Button控件就可以快速实现。具体操作步骤如下： 双击打开UI文件 在右侧控件集合中找到按键控件 鼠标左键点击按键控件不放，然后将其拖拽到任意位置，松开左键，就能看到自动生成的按键控件。 再左键点击刚才生成的按键控件，在编辑器的右侧就能看到该控件的相关属性。在这个属性表格中，你可以像填写Excel表单一样，自由修改属性！ 如何修改按键/按钮的颜色？ 参考如何修改文字的颜色 如何为按钮添加更多的动画效果？ 参考如何用图片来丰富按钮/按键的样式 如何用图片来丰富按钮/按键的样式 默认的按钮控件是纯颜色的，看起来有些枯燥。但是可以添加图片对按钮进行美化。 下面是具体操作步骤： 首先向UI文件中添加一个按键控件。如何添加按键控件 左键选中刚才添加的按键控件，在编辑器的右侧属性栏中可以看到按键的属性表。观察发现所有属性当中与图片相关的属性有： 图片设置 该属性可以分别设置按键各个状态下的图片，便于按键根据状态的变化，自动切换相应图片 图片位置 图片默认是居中且缩放至铺满整个按键矩形区域，你可以任意调整图片的位置及放大、缩小。 背景图 将图片设置为按键的背景，该图片将覆盖按键的整个矩形区域，并且自动缩放。 具体示例： 效果图： 上图是属性表图片参数部分截图，其表示的含义为： 按键默认情况下显示on.png， 按键选中状态时显示off.png； 图片位置的 左、上、宽、高四个参数决定了图片的显示区域（以像素为单位），以按键矩形区域的左上角为起点坐标（0，0），向右向下为正方向，终点坐标为（67，31）。 如果图片实际的宽高与指定的宽高参数不相等，则图片会根据指定的宽高进行缩放： 理解按键控件的层级关系 对于一般按键控件，它会绘制四层内容，它们从上到下依次是： 按键的文字 按键图片 按键背景图片 按键背景色 如何添加图片按键/按钮？ 参考如何为按钮添加更多的动画效果 当按下这个按键/按钮时，在哪儿或如何添加自己的操作代码？ 在实际开发中，按键是使用频率非常高的一种控件。常常会在按键的点击事件发生后，做一些处理，比如写串口或者刷新UI内容等操作。 要响应按键的点击时间非常的简单。以下是具体步骤： 首先创建一个按键控件，将属性ID命名为Button1。如何创建按键控件 在项目资源管理器中，选中当前项目，右键，在弹出菜单中选择编译FlyThings选项。这一步的作用是 根据当前项目内所有的UI文件自动生成模板代码 。 了解更多关于代码生成的细节 以UI文件为main.ftu为例，上一步完成后，将在当前项目文件夹下会生成 jni/logic/mainLogic.cc文件， 如下图： 注意： main.ftu对应着mainLogic.cc，两者的前缀是相同的。了解更多关于代码生成的细节 双击打开mainLogic.cc ，在文件的末尾应该会看到如下函数， static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } 当在串口屏上点击该按键控件后，系统会自动调用该关联函数。所以，如果你需要添加自己的处理代码，直接写在该关联函数里面即可。 可以看到，函数名称是按一定规则生成。以按键控件为例，它函数名称生成规则为 onButtonClick_XXXX(ZKButton *pButton),其中XXXX会被替换为控件ID， 所以多个按键控件会生成不同的关联函数。 了解更多控件的关联函数 系统按键 除了自己定义的ID值外，按键还保留了两个系统按键值：sys_back 和 sys_home ，从名字上我们大致可以知道它们的功能：返回键 和 Home键 ；点击返回键，界面会回到上一界面，如果进入了多层级的界面，点击Home键可以直接回到主界面（启动界面）。我们只需在按键的属性框中把ID值设置为 sys_back 或 sys_home ，就可以实现相应的功能。 了解更多界面交互 如何处理按键长按事件 如果需要处理按键的长按事件，需要手动添加长按事件的监听。 具体步骤如下： 在按键的 属性表 中， 设置 长按事件触发时间 、长按事件循环触发间隔时间 两个属性 ；下图中，我分别将其设置为 1000、1000， 单位是毫秒。 设置属性后, 编译, 打开对应的 Logic.cc 文件; 在文件顶部, 声明class LongClickListener, 并继承ZKBase::ILongClickListener类 ,实现 virtual void onLongClick(ZKBase *pBase) 方法。 namespace { // 加个匿名作用域，防止多个源文件定义相同类名，运行时冲突 //实现长按监听接口 class LongClickListener : public ZKBase::ILongClickListener { virtual void onLongClick(ZKBase *pBase) { LOGD(\"触发长按事件\"); static int count = 0; char buf[128] = {0}; snprintf(buf, sizeof(buf), \"长按事件触发次数 %d\", ++count); //每次触发长按事件，修改按键的文字 mLongButtonPtr->setText(buf); } }; } 接着，实例化上一步定义的监听类，声明为静态类型 static LongClickListener longButtonClickListener; 在 static void onUI_init() 函数中注册按键长按监听 static void onUI_init(){ //注册按键长按监听 mLongButtonPtr->setLongClickListener(&longButtonClickListener); } 在static void onUI_quit()函数中取消按键长按监听 static void onUI_quit() { //取消按键长按监听 mLongButtonPtr->setLongClickListener(NULL); } 添加完代码后，编译，将程序下载到机器中，长按测试；可以看到 按键的文字被修改，onLongClick函数成功响应。 具体实现，可以参考样例代码 如何处理按键触摸事件 如果需要在按键按下或抬起的时候做出响应，那么可以通过注册触摸的监听接口来实现。 具体步骤如下： 实现自己的触摸监听接口： namespace { // 加个匿名作用域，防止多个源文件定义相同类名，运行时冲突 // 实现触摸监听接口 class TouchListener : public ZKBase::ITouchListener { public: virtual void onTouchEvent(ZKBase *pBase, const MotionEvent &ev) { switch (ev.mActionStatus) { case MotionEvent::E_ACTION_DOWN: mTouchButtonPtr->setText(\"按下\"); break; case MotionEvent::E_ACTION_UP: mTouchButtonPtr->setText(\"抬起\"); break; default: break; } } }; } 接着，实例化上一步定义的监听类，声明为静态类型 static TouchListener sTouchListener; 在 static void onUI_init() 函数中注册按键触摸监听 static void onUI_init() { //注册按键触摸监听 mTouchButtonPtr->setTouchListener(&sTouchListener); } 在static void onUI_quit()函数中取消按键触摸监听 static void onUI_quit() { //取消按键触摸监听 mTouchButtonPtr->setTouchListener(NULL); } 添加完代码后，编译，将程序下载到机器中，点击触摸测试；可以看到 按键的文字被修改。 具体实现，可以参考样例代码 样例代码 由于按键控件属性较多，更多属性效果请参考样例代码中的ButtonDemo工程。样例预览效果图： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"checkbox.html":{"url":"checkbox.html","title":"复选框","keywords":"","body":"复选框 CheckBox 复选框 是基于 按键 的一个控件。 如果你需要一个开关按钮，或一个复选按钮，用复选框控件更合适，也更简单易用。当点击该控件时，它会自动切换为选中状态，再点击一次又切换为非选中状态，切换状态的同时，也会根据属性中设置的图片、颜色等自动切换。 如何使用 双击打开UI文件 在右侧控件集合中找到复选框控件 鼠标左键点击复选框控件不放，然后将其拖拽到任意位置，松开左键，就能看到自动生成的复选框控件。 再左键点击刚才生成的复选框控件，在编辑器的右侧就能看到该控件的相关属性。根据需要，设置各个状态的图片、各个状态的颜色。 这里重点注意 选中时的图片及颜色。 如果你设置了图片，发现图片大小显示异常，可以在 图片位置 属性中，调整图片的位置及大小。通常情况下，我们将图片调整到矩形区域的左边，文字放到矩形区域的右边。 属性设置完成后再编译，对应的Logic.cc 中会生成它的关联函数。当你点击该控件时，关联函数会被系统调用， 其中参数 bool isChecked 表示选中状态。 static void onCheckedChanged_Checkbox1(ZKCheckBox* pCheckBox, bool isChecked) { if (isChecked) { //复选框 为 选中状态 LOGD(\"选中\"); } else { //复选框 为 未选中状态 LOGD(\"未选中\"); } } 下载调试，查看效果。 样例代码 请参考样例代码中的CheckBoxDemo工程。样例预览效果图： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"radiogroup.html":{"url":"radiogroup.html","title":"单选组","keywords":"","body":"单选组 RadioGroup 对于多个选项，单选的情况，我们可以直接使用 单选组 控件。当点击其中某个选项时时，该选项会自动切换为选中状态，同一组中的其他选项会变为非选中状态。这些选项切换状态的同时，也会根据属性中设置的图片、颜色等自动切换。 如何使用 双击打开UI文件 在右侧控件集合中找到 单选组 控件集合 鼠标左键点击 单选组 控件不放，然后将其拖拽到任意位置，松开左键，就能看到自动生成一个矩形区域。它表示一个可以容纳 选项 控件的容器。 可以采用同样拖拽的操作，添加多个 选项 控件到刚才的矩形区域内部。 左键点击添加的 选项 控件，在编辑器的右侧就能看到它的相关属性。可以根据需要，设置每个选项各个状态的图片、各个状态的颜色。 这里重点注意 选中时的图片及颜色 属性。 如果你设置了图片，发现图片大小显示异常，可以在 图片位置 属性中，调整图片的位置及大小。我们还可以在 默认状态 属性中设置 选中 或者 未选中 属性设置完成后再编译，对应的Logic.cc 中会生成它的关联函数。当你点击其中某个选项时，关联函数会被系统调用， 其中参数 int checkedID 表示被点击选项的 ID。我们可以根据这个ID值，来判断当前点击的是哪一个选项。 这个 ID 是一个宏定义整型值。UI文件经过编译后，每个控件都会自动生成对应的宏ID，(关于该宏的更多信息，可查看它的命名规则)，每个选项的宏ID可以在对应的 Activity.h 头文件中找到。例如 那么在关联函数中，可以对点击项进行判断。 static void onCheckedChanged_RadioGroup1(ZKRadioGroup* pRadioGroup, int checkedID) { LOGD(\"选中项的ID = %d\", checkedID); switch (checkedID) { case ID_MAIN_RadioButton1: LOGD(\"第一项被选中\"); break; case ID_MAIN_RadioButton2: LOGD(\"第二项被选中\"); break; case ID_MAIN_RadioButton3: LOGD(\"第三项被选中\"); break; default: break; } } 下载调试，查看效果。 样例代码 请参考样例代码中的RadioGroupDemo工程。样例预览效果图： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"seekbar.html":{"url":"seekbar.html","title":"进度条/滑块","keywords":"","body":"滑块/进度条 如何使用滑块控件？ 很多情况下，我们会用到进度条，例如:调节音量 利用简单的几张图片，我们也能快速达到这样的效果。 首先，我们准备四张资源图片 背景图 有效图 滑块 滑块按下 在编辑器中，创建一个滑块控件 如果你不了解如何创建控件，参考创建按键控件 默认的滑块样式是透明的，我们必须为其添加足够的图片资源，它才能正常工作。 在属性表中，我们分别设置有效图 、滑块常显图片、滑块按下时的图片、背景图 图片 上一步完成后，一个滑块的创建基本完成了。如何想在工具中预览滑块滑动的效果，可以修改 最大值属性和默认进度值属性。在实时的预览中，你就可以看到滑块游标的位置变化。 如何在代码中控制滑块的进度？ 如何获得滑块的当前进度？ 如果我们用滑块实现了一个音量条，那肯定需要知道当前音量条的进度值，并且，一旦音量条有变化，我们还必须同步调节音量。所有，我们有如下3个函数来解决这些问题。 进度值变化监听函数如果你在UI文件中创建了滑块控件，那么该函数在 编译FlyThings 后，将会自动添加到相应的XXXXLogic.cc文件中。当在触摸屏上滑动进度条时、或者进度条当前值有变化时，系统会自动调用该函数。static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { //LOGD(\"XXXX滑块的进度值变化为 %d !\\n\", progress); } void setProgress(int progress)用于设置滑块当前进度。 例如： //将滑块进度设置为28 mSeekbarPtr->setProgress(28) int getProgress()用于获得当前滑块的进度值。例如： int progress = mSeekbarPtr->getProgress(); LOGD(\"当前滑块的进度值为 %s\", progress); 样例代码 更多滑块控件的使用，参考样例代码中的SeekBarDemo工程 样例预览效果图： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"pointer.html":{"url":"pointer.html","title":"指针/仪表","keywords":"","body":"指针仪表控件 功能介绍 如果我们想要实现一个仪表，或者时钟转动类似的效果，用这个控件就可以轻松实现。这个控件就是专为处理图形旋转设计的。 思考 如果要实现一个仪表， 我们可以将它拆解为两个部分，分别为静止的背景图当作表盘和重叠在背景图上旋转的指针图片。所以，在选择好背景图和指针图片后，我们只需要确定指针旋转的圆心坐标即可。 具体如何使用 我们先创建一个 仪表 控件， 可以看到它具有如下的属性： 如果你还不知道如何创建一个控件，可以参考如何创建按键控件属性图中，可以看到我已经添加了 指针图片 和 背景图 添加过程如动画所示： 从上面最后的预览图来看，并没有发现什么问题，背景图和指针的位置看起来都很正常。但是，程序真正运行起来后，是错误的。为了快速方便调整，我们可以将 起始角度 属性设置为其他度数（默认为0），这里我们调整为120，可以发现，指针旋转120°后，指针旋转的结果并不是我们期望的那样。造成这种情况的原因是 指针旋转的圆心坐标不正确。有两个属性共同决定指针旋转圆心坐标， 它们就是 旋转点坐标 和 指针固定点坐标 旋转点坐标该坐标是参照整个控件矩形区域而言的，控件矩形区域左上角为[0,0],以像素为单位，对于这样的一个仪表而言，显然我们想要的旋转点坐标是在表盘的中央，那么对应图片的具体坐标是 （250，250），如下图： 指针固定点坐标该坐标是参照指针图片而言的，图片左上角为[0,0], 以像素为单位。 对于这样的指针图片而言，我们想要的指针固定点坐标是（30，210） 将两个坐标分别填入属性表后，可以看到指针旋转到正确的位置 起始角度 支持负数，在上面的例子中，如果 将起始角度 修改为-120，则指针刚好指向表盘0的位置。 关于指针固定点的技巧 在上面的例子中，指针固定点坐标位于指针图片内，其实，这个坐标还可以超出图片范围，达到游标的那种效果。 如下图，红色方框内的白色实际为一张指针图片，比较小，但是在右边的属性中，我将指针固定点坐标远远超出了图片的真实大小，再调整旋转坐标，就达到了圆环游标的效果。 操作方法 这类控件最常用的方法就是通过代码调整指针的旋转角度。 //将指针调整到90度 mPointer1Ptr->setTargetAngle(90.0); 样例代码 具体仪表控件的使用，参考样例代码中的PointerDemo项目。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"listview.html":{"url":"listview.html","title":"列表","keywords":"","body":"列表控件 功能 列表按键经常用于一个页面无法展示完成所有信息的时候使用，同时每个单元信息中存在一些一致的属性分类 场景 WiFi列表，设备列表，表格信息 具体如何使用 打开UI文件，创建一个列表控件,再添加两个列表子项控件到列表中 然后你就能直观的看到列表的外观样式。 具体操作如下： 选中列表，可以看到它有如下属性 每项属性你可以尝试修改，然后下载程序到机器中查看具体变化。 现在转到大纲视图 可以看到列表下默认生成了一个 Item节点，它表示列表的一行或者一列， 在Item里包含我们添加的两个 ListSub 节点。你可以点击选中各个节点，查看它们各自的属性，以及在预览图上可以看到它们作用的范围。注意：每一个列表控件最多可以添加 32 个列表子项。 Item 和 列表子项 控件的属性与 按键控件类似。 你可以分别修改它们的属性，调整样式。我这边修改后的结果如下： 在UI文件中调整好列表的大致外观后，再进行编译(如何编译FlyThings项目)。在自动生成的关联函数中，我们要添加具体的逻辑代码，绘制列表的具体内容。 编译后，在对应的Logic.cc源文件中，每一个列表控件会生成三个与之相关的函数。 int getListItemCount_ListView1()： 获取将要绘制列表的长度 例如: 要显示的数据有100条， 那么就返回100。 void obtainListItemData_List1： 具体设置列表每一项的显示内容 具体例子参见后续文档 以上两个函数共同控制着列表的显示内容。更具体的函数调用流程。 onListItemClick_List1： 列表控件的点击事件 当点击列表中的某一项时，系统会调用该函数，参数index 表示 当前被点击列表项的索引值。 列表绘制的流程 当我们要绘制一个列表时，首先系统需要知道它一共有多少项，所以，我们提供了int getListItemCount_ListView1()这个函数，它会被系统调用，用于获取列表的长度（总项数），注意，该函数是动态获取的，在程序的运行过程中，我们可以根据业务需要，返回不同值，就可以动态控制列表的长度。 接着，系统会多次调用void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index)该函数，每一次调用，我们可以在该函数中，利用参数提供的指针，详细控制每一项具体显示的内容。 例子1. 设置列表项的显示内容static void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //pListItem指针表示列表项， 该指针只能在这个函数内当中使用 char buf[32] = {0}; //参数index表示 当前绘制的是列表的第几项，从0开始。 //这里，我们将index值格式化到字符串中 snprintf(buf, sizeof(buf), \"第%d项\", index); //将字符串作为文字显示到列表项区域 pListItem->setText(buf); //如果你在ui文件中，已经配置好了 列表项 \"选中时的图片“， //那么，通过以下这行代码设置列表项的选中状态，即可控制列表项显示对应状态的图片 pListItem->setSelected(true); } 例子2. 设置列表子项的显示内容如果我们用到了列表子项，可以通过如下方法得到列表子项的指针，再通过新得到的指针操作列表子项。 static void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { char buf[32] = {0}; //参数index表示 当前绘制的是列表的第几项，从0开始。 //这里，我们将index值格式化到字符串中 snprintf(buf, sizeof(buf), \"第%d项的第一个子项\", index); //我们可以通过findSubItemByID()函数以及列表子项的ID，得到列表子项的指针 //与pListItem指针相同，查找得到的列表子项指针也只能在这个函数内当中使用 ZKListView::ZKListSubItem* subitem1 = pListItem->findSubItemByID(ID_MAIN_SubItem1); if (subitem1 != NULL) { //设置列表子项1的文字 subitem1->setText(buf); } snprintf(buf, sizeof(buf), \"第%d项的第二个子项\", index); ZKListView::ZKListSubItem* subitem2 = pListItem->findSubItemByID(ID_MAIN_SubItem2); if (subitem2 != NULL) { //设置列表子项2的文字 subitem2->setText(buf); } } 列表的思想 在我们的系统中，列表是对一系列规则数据的映射，如果我们想修改列表，比如增加一项数据，或者修改某项内容等，应先修改数据，再触发刷新， 然后系统会自动调用obtainListItemData_ListView1函数，在该函数中，再根据最新的数据设置列表的显示内容。 这个思想在下面的样例中就有体现。 样例代码 我们提供了列表控件样例，参考样例代码中的ListViewDemo工程。 样例讲解 创建列表控件 我们依次创建两个列表控件，尝试设置不同的属性及外观。 CycleList控件： 开启循环列表选项 编译项目 这一步会自动生成列表相关的代码到相应 Logic.cc 文件中。具体操作参考《如何编译FlyThings项目》 创建List1列表需要的数据结构体一般情况，我们会定义一个结构体来作为列表每项数据的模型 typedef struct { //列表项显示的文字 const char* mainText; //列表子项1要显示的文字 const char* subText; //打开/关闭 标识 bool bOn; } S_TEST_DATA; 我们再定义一个该结构体数组，用于模拟列表数据 static S_TEST_DATA sDataTestTab[] = { { \"测试数据1\", \"testsub1\", false }, { \"测试内容2\", \"testsub2\", false }, { \"测试数据3\", \"testsub3\", false }, { \"测试测试4\", \"testsub4\", true }, { \"测试数据5\", \"testsub5\", false }, { \"测试数据6\", \"testsub6\", true }, { \"测试数据7\", \"testsub7\", false }, { \"测试数据8\", \"testsub8\", false }, { \"测试数据9\", \"testsub9\", false }, { \"测试数据10\", \"testsub10\", false }, { \"测试数据11\", \"testsub11\", false } }; 添加列表函数代码 static int getListItemCount_List1(const ZKListView *pListView) { //以数组的长度作为列表的长度 return sizeof(sDataTestTab) / sizeof(S_TEST_DATA); } static void obtainListItemData_List1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //得到列表子项1的指针，命名为psubText ZKListView::ZKListSubItem* psubText = pListItem->findSubItemByID(ID_MAIN_ListSub1); //得到列表子项2的指针，命名为psubButton ZKListView::ZKListSubItem* psubButton = pListItem->findSubItemByID(ID_MAIN_ListSub2); pListItem->setText(sDataTestTab[index].mainText); //以index为下标，从数组中得到对应的结构体，在从结构体中得到需要显示的文字，最后设置到对应的列表子项中 psubText->setText(sDataTestTab[index].subText); //UI文件中，我们为列表子项2设置了选中时的图片属性， //这里根据结构体的`bOn`值，设置列表子项的选中状态，这样如果成员`bOn`为真，则设置为选中，系统会自动显示之前设置好的选中图片 psubButton->setSelected(sDataTestTab[index].bOn); } static void onListItemClick_List1(ZKListView *pListView, int index, int id) { //当点击列表的第index项时，修改bOn变量， 将bOn取反。这样做可达到每点击列表一下，图片就切换一次 //注意图片切换的操作是在obtainListItemData_List1 函数中完成的，现在我们只修改这个变量值而已 sDataTestTab[index].bOn = !sDataTestTab[index].bOn; //上一句代码修改了结构体数据，现在我们想立即刷新列表，调用了refreshListView 强制刷新 //触发刷新后，系统会再次调用getListItemCount_List1 和obtainListItemData_List1 两个函数， 这样修改后的数据就与列表显示对应了。 mList1Ptr->refreshListView(); } 添加完代码后可运行查看实际效果。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"diagram.html":{"url":"diagram.html","title":"波形图","keywords":"","body":"波形图 使用该控件可以轻松的绘制曲线型或者折线型波形图。 如何使用 首先在UI文件中创建一个 波形图 控件，该控件指定了波形的绘制区域，然后再添加一个 波形 控件到刚才创建的区域中，你应该立马就可以看到波形大致的预览效果。具体创建过程如下： 你可以向波形图中添加多个波形， 分别调整它们的样式外观。注意：由于在预览图上，我们无法直接选中单个波形控件，所以，当我们需要调整指定的波形属性时，需要在大纲视图上进行选择。 分别查看 波形图 和 波形 控件的属性， 可以发现，波形图 决定了波形的x轴，y轴的值范围，以及波形的绘制区域。 而 波形 决定了每条波形的外观样式。 其中，波形 的属性中的 步进 和 刷新间距 两个属性需要解释下。 步进 表示每次向波形中添加一个数据的时候，波形图像前进的值，该值会受到 x轴缩放 属性的影响。 刷新间距表示波形刷新时 空缺 的那部分宽度 以上两个属性只有使用 void addData(int index, float data) 函数添加波形数据时才有效。 坐标轴及缩放 整个波形的图像缩放是自动完成的，我们不需要关心它，我们只需要在属性表中，确定 x轴范围，y轴范围，以及确定整个波形图像的矩形显示区域就可以了。 注意：波形控件中的 x轴缩放 、y轴缩放 属性，它会将你添加的业务数值都乘以该比例后，再绘制到屏幕上，默认为1.0 ，表示不缩放。 波形的坐标轴由 x轴最小值、x轴最大值、y轴最小值、y轴最大值 共同决定。 例如，默认的 x 轴范围是 [0, 100], y轴范围是[0,100],则它们构成的坐标轴为 一般情况下，x轴最小值 属性输入的值 小于 x轴最大值 属性 输入的值。但是如果将输入的最小值，最大值颠倒，那么同样的数据， 绘制的波形图像会左右颠倒; 如果使用void setData(int index, const SZKPoint *pPoints, int count)函数添加波形数据，那么还会造成刷新方向颠倒。 同理，对于y轴而言，绘制波形图像会造成上下颠倒。 代码操作 同样，UI文件只帮助我们快速修改波形的样式外观，具体的波形数据还是得通过代码添加。 在项目的jni/include/control/ZKDiagram.h 文件public 函数中，可以看到能支持的所有操作。 注意：与其他控件不同，我们添加的 波形 控件，虽然有ID属性，但是它并不生成独立的指针变量， 只有包含波形 的 波形图控件才会生成指针变量。所以对某个波形的操作，需要通过 波形图 指针，再借助 index值来表明对哪一个 波形 操作。 index的值从 0 开始。 void setPenWidth(int index, int width)设置波形线宽度，对应属性表上的 线条宽度 属性 void setPenColor(int index, ARGB color)设置波形颜色，对应属性表上的 波形颜色 属性 void setXScale(int index, double xScale)设置x轴缩放，对应属性表上的 x轴缩放 属性， void setYScale(int index, double yScale)设置y轴缩放，对应属性表上的 y轴缩放 属性 void setData(int index, const SZKPoint *pPoints, int count) typedef struct { float x; float y; } SZKPoint; SZKPoint结构体包含了 单个数据的 x、y值。 函数表示将pPoints数组中的count个点绘制到 第 index个波形上。注意： count 值不能大于 pPoints数组实际大小, 否则会造成数组越界。使用该函数绘制波形的思想是： 先将需要显示的数据填充到sPoints数组中，再一次性将数组里的点绘制的波形上。所以，如果想达到 波形 向左或向右 移动的动画效果，你需要手动将数组内的值整体偏移一个下标，再显示到波形上， 再整体偏移一个下标，再显示到波形上，如此循环。 通常这样的循环通过 定时器 来实现。所以该方法会造成 整个波形图像都会刷新。 void addData(int index, float data) 将单个数据增加到波形上， data为 y值， 你可能会好奇为什么没有 x 值，因为这个函数数是 局部波形图形刷新，当你每次调用该函数设置 y 值时，系统会自动偏移一定 x 值，而这个偏移的大小 与设置的 步进 属性相同。对比 void setData(int index, const SZKPoint *pPoints, int count)和void addData(int index, float data) 两种刷新波形的方式，可以得出，如果在大数据量下，采用第二种方式会有更高的刷新效率。 void clear(int index) 清除波形图数据 [!Note] **注意： Z6、Z11、A33平台坐标点结构体为MPPOINT，H500S、Z20、Z21及之后的平台结构体改名为SZKPoint，这点需要注意下。 添加波形移动的方法 刚才上面也有提到过，如果采用 void setData(int index, const SZKPoint *pPoints, int count)方式绘制波形，通常需要自行将数组中的值按下标偏移。 static void movePoints(SZKPoint* p,int size){ for(int i =0;i 添加定时器，用于定时刷新波形数据 一般情况下，添加定时器配合波形方便定时刷新 样例代码 效果图具体波形图控件的使用，参考样例代码中的DiagramDemo项目。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"circlebar.html":{"url":"circlebar.html","title":"圆形进度条","keywords":"","body":"圆形进度条 某些情况下，我们需要显示一个 Loading 的加载动画。 那么圆形进度条这个控件就非常适合。 如何使用 首先，打开UI文件，创建一个 圆形进图条 ，然后设置 有效图 属性。一个基本的圆形进度条就创建完成了。它的所有属性如下： 圆形进度条实质是显示当前进度对应的扇形区域，这个区域是对 有效图 的裁剪得来。 举例：如果照上图属性设置， 最大值 100， 起始角度0， 旋转方向为 顺时针方向，那么当我们设置 25的进度时，仅显示右上角 90°的扇形区域。 如果进度值为100，那么就显示全部的有效图。 注意： 这个扇形的显示区域只针对有效图进行裁剪， 背景图不会被裁剪。 代码操作 圆形进度条提供的操作函数非常简单。 //设置当前进度 void setProgress(int progress); //得到当前进度值 int getProgress()； //设置进度最大值 void setMax(int max); //得到进度最大值 int getMax()； 样例代码 样例中， 滑动上方的滑动条，下方的两个圆形进度条进度会跟着变化。具体圆形进度条控件的使用，参考样例代码中的CircleBarDemo工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"qrcode.html":{"url":"qrcode.html","title":"二维码","keywords":"","body":"二维码 如何添加二维码？ 如果需要显示二维码，利用现有的二维码控件就可以快速实现。具体操作步骤如下： 双击打开UI文件 在右侧控件集合中找到二维码控件 鼠标左键点击二维码控件不放，然后将其拖拽到任意位置，松开左键，就能看到自动二维码的控件。 选中刚才生成的二维码控件，在编辑器右侧的属性栏中，可以修改二维码内容，你可以看到二维码图像会同步改变。 动态更新二维码 除了通过工具设置二维码内容外，我们还可以通过代码来动态设置二维码内容： bool loadQRCode(const char *pStr); 样例代码 效果图 具体二维码控件的使用，参考样例代码 中的QrCodeDemo项目。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"video.html":{"url":"video.html","title":"视频","keywords":"","body":"视频 FlyThings还提供了视频播放的控件。 [!Note] 视频播放功能并非所有版本的机器都支持！如果需要正常使用该功能，那么请购买带有多媒体功能的机器版本。 使用控件轮播视频 首先，创建一个 视频 控件，默认背景色为黑色。 查看 视频 的属性表 其中，有个属性为 是否为轮播视频类型如果选择 是 ，那么每次进入这个UI界面时，会自动读取TF卡目录下的配置文件，循环播放配置文件中指定的视频。 退出页面自动停止播放。 这个属性非常适合仅需要播放视频、且不存在用户干预播放的场景，比如轮播广告机、自动播放一段短视频等。如果选择 否 ，仅仅只会创建一个视频的渲染区域，除此以外没有其他操作。那么，你就需要自己去操作视频播放了。 创建视频配置文件上面说到，如果是视频轮播类型，会自动读取视频配置文件。 你需要自行创建它。这个配置文件需要位于TF卡根目录下，文件名是 XXXX_video_list.txt XXXX 表示对应的UI文件前缀名。例如： 我在 main.ftu 中添加了一个视频控件，那么，对应的配置文件名为 main_video_list.txt配置文件以行为单位， 每行为视频文件的绝对路径，如果视频文件也位于TF卡根目录，那么直接填写 /mnt/extsd/ 加上 视频文件名即可。 注意： 防止编码问题导致视频文件读取失败，请尽量使用英文命名视频文件。 程序运行后，即可自动轮播配置文件中的视频。 播放指定视频文件 创建一个 视频 控件 将属性 是否为轮播视频类型 置为 否。 添加代码，控制播放逻辑播放 //播放test.mp4文件， 从时间0开始播 mVideoView1Ptr->play(\"/mnt/extsd/test.mp4\", 0); 暂停 //暂停播放 mVideoView1Ptr->pause(); 恢复播放 //恢复播放 mVideoView1Ptr->resume(); 停止播放 mVideoView1Ptr->stop(); 跳转到指定时间播放 //跳转到10秒的位置 mVideoView1Ptr->seekTo(10 * 1000); 设置播放音量， 范围 0~1.0 //设置音量为0.5 mVideoView1Ptr->setVolume(0.5); 判断是否正在播放 bool state = mVideoView1Ptr->isPlaying(); if （state) { LOGD(\"正在播放\"); } 获取视频的总时长，单位毫秒 int n = mVideoView1Ptr->getDuration(); 获取视频当前播放位置，单位毫秒 int n = mVideoView1Ptr->getCurrentPosition(); 视频是异步播放，自动生成的关联函数中，会通知我们视频播放的状态 static void onVideoViewPlayerMessageListener_VideoView1(ZKVideoView *pVideoView, int msg) { switch (msg) { case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_STARTED: LOGD(\"视频开始播放\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_COMPLETED: LOGD(\"视频播放结束\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_ERROR: LOGD(\"视频播放出错\"); break; } } 完整视频播放器的实现 如果你对视频播放有更高的要求，需要控制播放/暂停、拖动视频进度条等。可以参考样例代码中的VideoPlayerDemo项目，它实现了一个完整的播放器。 样例代码 在该样例中， 实现了视频的循环播放，以及调整视频音量。具体实现，参考样例代码中的VideDemo项目。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"edittext.html":{"url":"edittext.html","title":"编辑框","keywords":"","body":"编辑/输入框 我需要数字键盘， 我需要用户手动输入中文，怎么办？ 如何添加编辑/输入框 如何添加编辑/输入框 如果需要数字及中文输入，利用现有的编辑/输入框控件就可以快速实现。具体操作步骤如下： 双击打开main.ftu文件 在右侧控件集合中找到编辑/输入框控件 鼠标左键点击编辑/输入框控件不放，然后将其拖拽到任意位置，松开左键，就能看到自动编辑/输入框的控件。 在右侧属性中，根据需要选择 文本类型， 如果你需要输入中文，那就讲 文本类型 选择为 全文本， 并且在 项目属性 中开启拼音输入法。 当下载运行到机器上，点击编辑/输入框控件，会自动打开一个系统内置输入法或者数字键盘，这样就可以输入文字或数字了。 内置拼音输入法 截图 内置数字键盘输入 截图 默认的编辑/输入框为白色，你可以在右侧的属性表里自定义外观样式。其中关于编辑/输入框的相关属性有如下几个： 是否为密码框输入如果选择是，当模拟键盘输入时，正在键入的字符会显示为指定的密码字符，否则无变化 密码字符如果是否为密码输入选择是,正在键入的字符会显示为指定的密码字符，否则无变化 文本类型该属性有两个选项，分别是 全文本表示可以输入中英文及数字，不受限制。 仅数字表示只能输入数字，其他受限。 提示文本当模拟键盘中内容为空时，会自动显示提示文本。 提示文本颜色当模拟键盘中内容为空时，会自动显示提示文本，该文本颜色为指定的颜色。 如何得到模拟键盘的输入内容？ 当成功创建了编辑/输入框，选择 编译FlyThings ，会自动生成它的关联函数，打开工程目录下的jni/logic/****Logic.cc文件(****表示UI文件名 )，找到自动生成的函数（XXXX表示控件ID名）了解更多控件的关联函数 static void onEditTextChanged_XXXX(const std::string &text) { //LOGD(\"当前输入的内容为 %s \\n\", text.c_str()); } 当模拟键盘输入内容结束后，系统会自动调用该函数，参数text就是当前模拟键盘上的完整字符串。std::string 是c++语言类型的字符串。还可以通过如下语句，得到C语言形式的字符串指针。 const char* str = text.c_str(); 如何将字符串转为数字？ 编辑框的关联函数中，我们只能得到字符串，所以，当我们输入数字时，需要自行将数字字符串转为数字。 atoi函数可以将字符串转为对应的数字，比如 “212” 可以转为整形 213如果遇到非法字符，会造成转换失败或者中断解析。例如：atoi(\"213abc\"); 返回 213atoi(\"abc\"); 返回 0static void onEditTextChanged_EditText1(const std::string &text) { int number = atoi(text.c_str()); LOGD(\"字符串转为数字 = %d\", number); } atof函数可以将字符串转为对应的浮点数，比如 “3.14” 可以转为浮点数 3.14如果遇到非法字符，会造成转换失败或者中断解析。例如：atoi(\"3.14abc\"); 返回 3.14atoi(\"abc\"); 返回 0static void onEditTextChanged_EditText1(const std::string &text) { // atof函数可以将字符串转为对应的浮点数，比如 “3.14” 可以转为整形 3.14 //如果参数不规范，会造成转换失败，统一返回 数字 0 double f = atof(text.c_str()); LOGD(\"字符串转为浮点数 = %f\", f); } 如何自定义输入法？ 除了使用默认的输入法外，我们还可以自定义输入法，样例代码包中提供了演示例子ImeDemo工程。目前仅支持数字和字母输入的定制，带有中文输入法的界面无法自定义。 输入法界面与普通界面的实现有些区别： 普通界面是继承Activity实现的，输入法需要继承IMEBaseApp； 另外注册的方式也不一样，普通界面注册方式：REGISTER_ACTIVITY(****Activity);，输入法界面注册方式：REGISTER_SYSAPP(APP_TYPE_SYS_IME, ****Activity);(****表示UI文件名 ) 这些区别ImeDemo工程中已经做好了修改，只需移植到自己工程即可： 将ui目录下UserIme.ftu文件拷贝到自己工程ui目录下； 将activity目录下UserImeActivity.h和UserImeActivity.cpp文件拷贝到自己工程activity目录下； 将logic目录下UserImeLogic.cc文件拷贝到自己工程logic目录下； 之后的操作与普通界面编程一致，在UserImeLogic.cc中编写逻辑； powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"window.html":{"url":"window.html","title":"窗口容器","keywords":"","body":"窗口 功能描述 窗口实际是一个容器部件。可以包含所有的控件，也可以再次包含一个新的窗口。可以用于以下场景 显示隐藏一个控件组合 当需要完成tab页面的时候可以通过多个窗口实现不同的窗口切换 弹出的对话框 弹出悬浮框 如何使用 创建一个 窗口 控件，默认的窗口是透明的。根据需求，可以自行添加背景图或者修改背景色； 你也可以将其他控件添加到窗口中。 在上面的属性表中 有两个属性需要解释下: 是否是模态窗口如果是模态，当这个窗口控件显示时，点击该窗口以外的区域，该窗口会自动隐藏。如果是非模态， 该窗口控件的显示/隐藏 都必须自行控制。 超时自动隐藏窗口如果是模态窗口， 那么该窗口从刚开始显示开始计时，在指定时间后自动隐藏。单位为秒；如果该值为 -1，那么表示不会自动隐藏。如果是非模态，那么该参数无任何作用。 代码操作 对于窗口控件，我们一般会涉及到如下几个函数 //显示窗口 void showWnd(); //隐藏窗口 void hideWnd(); 判断窗口是否显示 bool isWndShow(); 动态设置背景 如果我们将窗口布满整个屏幕，然后设置这个窗口的背景，即可实现修改屏幕背景的效果。 相关的接口 /** * @brief 设置背景图 * @param pPicPath 图片路径 */ void setBackgroundPic(const char *pPicPath); /** * @brief 设置背景颜色 * @param color -1时，背景设置为透明；其他颜色值为0x RGB，颜色值不支持alpha */ void setBackgroundColor(int color); 使用示例 //把/mnt/extsd/bg.png 这个路径的图片设置为这个窗口控件的背景图 mWindow1Ptr->setBackgroundPic(\"/mnt/extsd/bg.png\"); //将ID为window1的窗口背景色设置为红色 mWindow1Ptr->setBackgroundColor(0xff0000); //将ID为window1的窗口背景色设置为绿色 mWindow1Ptr->setBackgroundColor(0x00ff00); //将ID为window1的窗口背景色设置为蓝色 mWindow1Ptr->setBackgroundColor(0x0000ff); 有许多控件都拥有设置背景色、设置背景图的接口，使用方法相同。 样例代码 演示了 模态/非模态窗口控件的使用 具体窗口控件的使用，参考样例代码中的WindowDemo项目 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"slidewindow.html":{"url":"slidewindow.html","title":"滑动窗口","keywords":"","body":"滑动窗口 滑动窗口控件与手机主界面九宫格左右滑动的界面效果类似。由一个滑动主窗口和多个图标组成。 如何使用 首先在UI文件中创建一个 滑动主窗口 控件，然后再添加多个 滑动窗口图标 控件到 主窗口控件中。 添加 滑动窗口图标 控件时，它会自动按顺序排列图标，如果添加满一页后，继续添加也会自动翻页。所有添加的图标控件都可以在 大纲视图 中找到。 如果想调整 滑动窗口图标 排列的位置，你可以在大纲视图中选中节点,然后直接通过拖拽来调整。注意下面动画左下角大纲视图的操作。 在 大纲视图 中，选中 滑动窗口图标 控件，可以分别添加图片以及修改文字；选中整个 滑动主窗口 可以调整排列的 行数 和 列数， 还可以统一调整字体大小、图标大小。 代码操作 如果你添加了滑动窗口控件，那么在编译后，会自动生成关联函数， 函数具体介绍参考滑动窗口关联函数 一般情况下，我们只需要通过触摸滑动来上下翻页。但是，我们也提供了相应的翻页函数。 切换下一页// 切换到下一页，有动画 mSlideWindow1Ptr->turnToNextPage(true); // 切换到下一页，无动画 mSlideWindow1Ptr->turnToNextPage(false); 切换上一页// 切换到上一页，有动画 mSlideWindow1Ptr->turnToPrevPage(true); // 切换到上一页，无动画 mSlideWindow1Ptr->turnToPrevPage(false); 我们还可以通过代码监听到滑动窗口翻到了第几页： namespace { // 加个匿名作用域，防止多个源文件定义相同类名，运行时冲突 // 实现自己的监听接口 class MySlidePageChangeListener : public ZKSlideWindow::ISlidePageChangeListener { public: virtual void onSlidePageChange(ZKSlideWindow *pSlideWindow, int page) { LOGD(\"当前切换到第%d页\", page); } }; } // 定义监听对象 static MySlidePageChangeListener sMySlidePageChangeListener; static void onUI_init() { mSlidewindow1Ptr->setSlidePageChangeListener(&sMySlidePageChangeListener); } 获取当前是哪一页 int i = mSlideWindow1Ptr->getCurrentPage(); LOGD(\"当前是第%d页\", i); 样例代码 效果图 具体滑动窗口控件的使用，参考样例代码中的SlideWindowDemo项目。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"painter.html":{"url":"painter.html","title":"画布","keywords":"","body":"画布 画布控件提供了简单几何图形绘制接口。 如何使用 创建一个 画布 控件，默认的画布控件是透明的。根据需求，可以自行添加背景图或者修改背景色。 代码操作 通过画布控件的指针，即可调用接口绘制图形。 该控件几乎所有功能都需要代码实现，示例如下。 static void onUI_init() { /** * 绘制一个圆角矩形边框 */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0x7092be); mPainter1Ptr->drawRect(10, 10, 430, 230, 5, 5); /** * 绘制一段圆弧 */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xadc70c); mPainter1Ptr->drawArc(80, 80, 40, 40, -20, -120); /** * 绘制一段扇形 */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0x008ecc); mPainter1Ptr->fillArc(80, 80, 40, 40, -20, 120); /** * 绘制三角形 */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0xff804f); mPainter1Ptr->drawTriangle(200, 40, 160, 90, 240, 90);//空心三角形 mPainter1Ptr->fillTriangle(300, 40, 260, 90, 340, 90); //实心三角形 /** * 绘制直线 */ MPPOINT points1[] = { {50 , 150}, {150, 150}, {70 , 200}, {100, 120}, {130, 200}, {50 , 150} }; /** 根据提供的多个点坐标依次连接成线 */ mPainter1Ptr->setLineWidth(2); mPainter1Ptr->setSourceColor(0x88cffa); mPainter1Ptr->drawLines(points1, TABLESIZE(points1)); /** * 绘制曲线 */ MPPOINT points2[] = { {250, 150}, {350, 150}, {270, 200}, {300, 120}, {330, 200}, {250, 150} }; mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xe28ddf); /** 根据提供的多个点坐标连接为曲线 */ mPainter1Ptr->drawCurve(points2, TABLESIZE(points2)); } 样例代码 演示了画布控件的使用 画布控件的具体使用方法，参见样例代码 里的 PainterDemo 工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"camera.html":{"url":"camera.html","title":"摄像头","keywords":"","body":"摄像头 FlyThings提供了摄像头的控件。 [!Note] 摄像头功能并非所有版本的机器都支持！如果需要正常使用该功能，那么请购买支持USB摄像头功能的版本。 如何使用 首先，创建一个 摄像头 控件，默认背景色为黑色。 查看 摄像头 的属性表 将自动预览设置为开根据所接摄像头的型号，选择CVBS信号与否 将摄像头与屏连接，再下载运行程序，即可看到摄像头的预览画面。 开始/停止预览 我们可以通过代码控制 开始/停止预览画面 开始预览mCameraView1Ptr->startPreview(); 停止预览mCameraView1Ptr->stopPreview(); 摄像头拍照 实现拍照回调接口 class PictureCallback : public ZKCamera::IPictureCallback { public: virtual void onPictureTakenStarted() { mTextView1Ptr->setText(\"拍照开始\"); } virtual void onPictureTakenEnd() { mTextView1Ptr->setText(\"拍照结束\"); } virtual void onPictureTakenError() { mTextView1Ptr->setText(\"拍照错误\"); } virtual const char* onPictureSavePath() { //照片保存路径 return \"/mnt/extsd/camera.jpg\"; } }; 实例化接口，并注册 //定义为全局静态变量 static PictureCallback picture_callback; 注册拍照回调接口 static void onUI_init(){ mCameraView1Ptr->setPictureCallback(&picture_callback); } static void onUI_quit() { //记得在界面退出时将注册接口置空 mCameraView1Ptr->setPictureCallback(NULL); } 增加一个按键，当点击按键时，请求拍照static bool onButtonClick_Button3(ZKButton *pButton) { //请求拍照 mCameraView1Ptr->takePicture(); return false; } 样例代码 在该样例中， 实现了摄像头的预览及拍照功能、相册功能。具体实现，参考样例代码 CameraDemo项目 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"digital_clock.html":{"url":"digital_clock.html","title":"数字时钟","keywords":"","body":"数字时钟 数字时钟是专用于时间显示的控件，在很多场景下，我们都需要显示时间，该控件会自动根据系统时间来显示。 如何使用 双击打开UI文件 在右侧控件集合中找到数字时钟控件 鼠标左键点击数字时钟控件不放，然后将其拖拽到任意位置，松开左键，就能看到数字时钟的控件。 选中刚才生成的数字时钟控件，在编辑器右侧的属性栏中，可以修改其属性内容，主要修改下面五个属性。 时钟显示格式 该属性设置时间的显示格式，可以选择24小时制或者12小时制，同时控制秒数是否显示。 是否跳动 该属性控制时钟中的:是静止还是跳动。 时钟颜色 该属性设置时钟文字的颜色显示。 字体大小 该属性数字时钟的文字大小 特殊字符集设置我们知道，根据asc码的定义，字符 char 与 整形 int 存在着对应关系。比如字符 0 的asc码为48。 特殊字符集就是将asc码映射为图片的一种功能。设置该功能后，当我们显示一个字符串时，系统会尝试将字符串中的每一个字符映射为指定的图片，最终显示一串图片到屏幕上。具体使用方法请参考文本控件中的特殊字符集的使用。 保存，下载调试，运行后，即可看到效果。 如果想修改时间， 则可以参考系统时间文档修改。 样例代码 参考样例代码中的DigitalClockDemo项目 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"relation_function.html":{"url":"relation_function.html","title":"关联函数介绍","keywords":"","body":"控件自动生成的关联函数讲解 有些控件会自动生成关联函数。这些控件生成的关联函数的具体讲解如下： [!Note] 函数中出现的XXXX代表控件ID，实际过程中，请自行替换 按键控件 static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } 当点击按键时，会调用该函数。 参数ZKButton *pButton是被点击按键的指针，通过该指针的成员函数可以对控件进行一系列操作。 该指针与全局变量mXXXXPtr所指向的对象为同一对象。 编辑输入框控件 static void onEditTextChanged_XXXX(const std::string &text) { } 当输入框中的文字发生改变时，系统会自动调用该函数。 参数std::string &text是当前输入框中的完整字符串。 滑块控件 static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } 当滑块当前进度值发生变化时，系统会自动调用该函数。 参数ZKSeekBar *pSeekBar 是该滑块控件的指针，通过该指针的成员函数可以对控件进行一系列操作。 参数int progress是当前滑块的的进度值 滑动窗口控件 static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } 当点击滑动窗口控件中的某一个图标时，系统会自动调用该函数。 参数ZKSlideWindow *pSlideWindow 是该滑动窗口控件的指针，通过该指针的成员函数可以对控件进行一系列操作。 参数int index是当前被点击图标的索引值。例如该滑动窗口一共添加了10个图标，则索引值范围是[0, 9] 列表控件 列表控件是最复杂的一个控件，它会创建三个关联函数。虽然函数较多，但是按照下面的步骤理解起来也十分容易。 首先，系统想要绘制一个列表控件，需要知道它一共有多少项。于是有了下面这个关联函数 static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } 参数const ZKListView *pListView 是该列表控件的指针， 它与全局变量mXXXXPtr指向同一个对象。 返回值是整形， 表示该列表一共有多少项，可以根据你的需求来定义。 系统知道了需要绘制的数目后，还不够，还需要知道你每一项都分别显示哪些内容。于是有了下面这个函数，它会被多次调用，让你设置每一项的显示内容，直到每一项都处理完毕。 void obtainListItemData_XXXX(ZKListView *pListView, ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } 参数ZKListView *pListView 是该列表控件的指针， 它与全局变量mXXXXPtr指向同一个对象。 参数ZKListView::ZKListItem *pListItem 是列表项的指针，与UI文件中的Item对应 参数int index是pListItem在整个列表中的索引值。它具有一定范围，例如：getListItemCount_XXXX函数返回值为10，则表示列表共有10项，那么index的范围是[0, 9]， 结合pListItem和index,你就能知道现在设置的这个列表项处于整个列表的什么位置。 在这个函数里，你可以根据index分别设置每一项的显示内容。例如： 函数中注释的语句就表示：每一个列表项将它对应的索引号作为文字显示。 与按键控件类似，列表控件同样有点击事件，只不过它是根据索引值来判断当前点击的是哪一个列表项。 static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } 当点击列表控件时，系统会根据触摸的坐标，判断触点落在哪一个列表项上，计算出该列表项的索引号后，系统会自动调用该函数。 参数ZKListView *pListView 是该列表控件的指针， 它与全局变量mXXXXPtr指向同一个对象。 参数int index 是当前被点击的列表项在整个列表控件中的索引值 参数int id 是当前被点击的控件的整形id。注意，这个id与属性表中的ID名称不同。 它的具体宏定义在相应的Activity.h文件中。 例如mainActivity.h中 这个id参数的作用在于，当列表项中有多个子项时，可以用来区分当前被点击的是哪一个子项。例如: 如下图，我在列表项中添加了两个列表子项,并添加了图片装饰，作为开关按钮，属性ID名分别为SubItem1、SubItem2，当我点击SubItem1时，通过判断参数id与ID_MAIN_SubItem1、ID_MAIN_SubItem2的相等关系，就能确定点击的是哪一个开关。具体代码： static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"点击了列表第%d项的第一个子项\", index); break; case ID_MAIN_SubItem2: //LOGD(\"点击了列表第%d项的第二个子项\", index); break; } } [!Note] 技巧之：快速跳转至关联函数 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"first_app.html":{"url":"first_app.html","title":"第一个启动界面","keywords":"","body":"当我们新建一个工程时，生成的模板代码里面有一个Main.cpp文件，路径： jni/Main.cpp；模板代码如下： 其中红框内为启动界面代码，启动的是mainActivity界面，对应的UI资源文件为main.ftu，具体我们可以看一下 jni/activity/mainActivity.cpp 里面的代码，就清楚对应的是哪个UI资源了： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"open_close_app.html":{"url":"open_close_app.html","title":"打开/关闭应用界面 ","keywords":"","body":"前面我们已经了解到了启动界面，进入启动界面后，我们可以再打开其他界面，进入第二级、第三级界面等等；接下来我们来了解一下如何打开、关闭其他界面； 打开应用界面 比如现在我们要打开sub.ftu对应的界面，根据前面分析启动界面的说明，我们可以知道该UI资源对应的界面对象为subActivity，这些都是工具帮我们自动生成的代码，我们不需要关注过多的细节，简单了解一下即可，接下来我们可以通过如下代码启动该界面： EASYUICONTEXT->openActivity(\"subActivity\"); 假如我们想通过一个按钮点击跳转到sub.ftu界面，我们可以在按钮点击事件的回调接口中调用以上语句： static bool onButtonClick_Button1(ZKButton *pButton) { // 跳转到sub.ftu界面 EASYUICONTEXT->openActivity(\"subActivity\"); return false; } 一般情况下，以上的调用代码就足够了，如果涉及到界面与界面间需要传递一些信息，如支付页面，我们就需要用到openActivity的第二个参数进行传参了： Intent *pIntent = new Intent(); pIntent->putExtra(\"cmd\", \"open\"); pIntent->putExtra(\"value\", \"ok\"); EASYUICONTEXT->openActivity(\"subActivity\", pIntent); 这样在subLogic.cc的onUI_intent回调中就可以接收到了： static void onUI_intent(const Intent *intentPtr) { if (intentPtr) { // 键值解析 std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } 注意： 1. new出来的Intent不需要手动delete，由框架内部自动delete； 2. putExtra只提供了string的键值对方式，如需传递int或其他类型的值，需转成string类型，在onIntent中收到后再做相应的转换 关闭应用界面 通过上面的openActivity方法，我们打开了subActivity界面，这个时候我们想回退到原来的界面，怎么办呢？ 我们可以通过以下代码返回到上一级界面： EASYUICONTEXT->goBack(); 如果是通过按钮触发返回的，我们可以直接通过工具设置一下按钮的ID值为sys_back，系统也会响应返回功能； 如果我们进入了较多层级的界面，想要直接回退到我们的第一个启动界面，我们可以通过如下代码实现： EASYUICONTEXT->goHome(); 即回退到主界面。 另外，如果也是通过按钮触发的，我们也可以通过工具设置一下按钮的ID值为sys_home，系统也会响应回主界面的功能； 最后，我们还可以通过EasyUIContext的closeActivity方法关闭应用界面，比如我们要关闭subActivity界面： EASYUICONTEXT->closeActivity(\"subActivity\"); 该方法需要调用者清楚要关闭应用的名称；另外，该方法不能关闭启动界面，启动界面是常在的。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"activity_life_cycle.html":{"url":"activity_life_cycle.html","title":"界面活动周期","keywords":"","body":"界面活动周期 在介绍界面的活动周期之前，我们先来了解一下界面的层级关系 首先我们的应用起来后会先进入mainActivity对应的界面，即启动界面，之后通过openActivity方法打开了subActivity对应的界面，接着再进入thirdActivity对应的界面，就形成了上图所看到的层级效果了；后打开的界面在层级上层，它们间形成了栈的这样一种关系； 打开界面时的活动流程 我们再来看看调用openActivity方法后，程序走了哪些流程，这里分两种情况介绍： 界面栈中不存在即将要打开的界面； 我们先来看一下subLogic.cc中的onUI_init函数，只有界面栈中不存在该界面情况下，第一次打开时，会走这个函数，走到这里意味着所有控件指针也就初始化完成了，在这个函数里我们就可以开始对它们进行一些操作，如下： static void onUI_init() { //Tips :添加 UI初始化的显示代码到这里,如:mTextView1Ptr->setText(\"123\"); LOGD(\"sub onUI_init\\n\"); mTextView1Ptr->setText(\"123\"); } 界面打开时有数据传递过来，在onUI_intent回调函数中接收处理: static void onUI_intent(const Intent *intentPtr) { LOGD(\"sub onUI_intent\\n\"); // 判断不为空 if (intentPtr) { // 键值解析 std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } 界面显示完成回调onUI_show函数； 界面栈中存在即将要打开的界面； 这种情况只是将界面栈中对应的界面移动到顶层，不走onUI_init流程； 打开显示一个界面，意味着之前顶层的界面被隐藏掉了；假设在mainActivity界面打开了subActivity界面，它们的活动流程如下： 这里我们重点关注mainActivity界面隐藏 ------> subActivity界面显示流程； 关闭界面时的活动流程 当我们调用goBack()函数时，会将顶层的界面弹出，直到启动界面； 关闭界面时会回调onUI_quit函数，如果界面打开后有申请一些什么资源的，记得要在这里进行释放； 退出顶层的界面后，会将下一层界面显示出来，即会回调下一层界面的onUI_show接口； 当我们调用goHome()函数时，会直接回退到启动界面，将其他界面都弹出； 当我们调用closeActivity(\"xxx\")函数时，可以移除除启动界面外任意界面；当移除的不是顶层的界面时，下一层的界面不会走onUI_show流程； powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"internal_app.html":{"url":"internal_app.html","title":"系统内置界面","keywords":"","body":"除了开发人员自己定制的界面外，我们系统也内置了几个常用的界面，如插卡升级时出现的界面就属于内置界面之一； 另外，还有系统设置界面，打开方式： EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); 我们可以通过一个按钮点击跳转到该界面看一下效果（其他的几个内置界面都可以通过如下方式查看效果）： static bool onButtonClick_Button1(ZKButton *pButton) { EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); return false; } 其中每一项点击进去后又是新的内置界面，打开网络设置： EASYUICONTEXT->openActivity(\"NetSettingActivity\"); 打开WIFI设置： EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); 如果目标机器支持wifi，打开右上角开关，界面上会显示搜索到的wifi信息； 打开热点设置界面： EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); 回到刚刚的系统设置界面，我们再点击打开语言设置界面： EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); 触摸校准界面： EASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); 开发者选项界面： EASYUICONTEXT->openActivity(\"DeveloperSettingActivity\"); 目前只有ADB的调试开关选项。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"system_app.html":{"url":"system_app.html","title":"系统应用","keywords":"","body":"系统界面类型 前面介绍的应用界面我们归类为普通窗口界面，一般情况下已经够用了，通过工具新建UI界面时，默认的窗口类型就是普通窗口： 如果某些场景需要一个悬浮在UI界面之上的显示区，那么普通窗口就不能胜任这份工作了，需要用到我们其他的几种类型的窗口了； 在 窗口类型 选项中，有三种特殊类型窗口选项，这三种特殊类型具有特殊的文件名，分别对应为 状态栏 statusbar.ftu 导航栏 navibar.ftu 屏保 screensaver.ftu 点击确定后，工具会帮我们自动生成相应的代码；这三种类型的窗口，对于控件的操作与普通窗口一样； 状态栏 解释：这个状态栏跟Android，iOS手机的状态栏概念一致，是一个悬浮在UI界面之上的一个通用显示区。通常用于显示一些常见信息，或者放置返回键或Home键等等。如下效果： 系统提供了两个接口可以用于操作状态栏： 显示状态栏： EASYUICONTEXT->showStatusBar(); 隐藏状态栏： EASYUICONTEXT->hideStatusBar(); 完整源码见样例代码包中的StatusBarDemo工程 导航栏 解释：这个导航栏跟Android手机的导航栏概念一致，是一个悬浮在UI界面之上的一个通用操作或者显示区，一般在页面的底部。通常用于显示一些操作按键。导航栏实际上和状态栏没有什么差别。 显示导航栏： EASYUICONTEXT->showNaviBar(); 隐藏导航栏： EASYUICONTEXT->hideNaviBar(); 屏保应用 解释：屏保应用是指当用户不再做系统交互的时候，时间超过某个指定时间长度。系统自动打开一个页面。 右键工程, 选择 Properties 选项, 在弹出的属性框里，我们可以对屏保超时时间进行设置，单位为秒，-1表示不进屏保； 我们也可以通过代码进行一些设置，见 jni/include/entry/EasyUIContext.h： 所需头文件 #include \"entry/EasyUIContext.h\" 设置屏保超时时间 //设置屏保超时时间为5秒 EASYUICONTEXT->setScreensaverTimeOut(5); 设置是否允许启用屏保 EASYUICONTEXT->setScreensaverEnable(false); //关闭屏保检测 EASYUICONTEXT->setScreensaverEnable(true); //恢复屏保检测 应用场景：如升级界面不能进入屏保模式，可以在升级应用里EASYUICONTEXT->setScreensaverEnable(false)关闭屏保检测。 立即进入屏保 EASYUICONTEXT->screensaverOn(); 立即退出屏保 EASYUICONTEXT->screensaverOff(); 判断是否进入了屏保 EASYUICONTEXT->isScreensaverOn(); 完整源码见样例代码包中的ScreensaverDemo工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"timer.html":{"url":"timer.html","title":"定时器","keywords":"","body":"定时器 在某些情况下，我们可能需要定时做一些操作。比如，间隔一定时间发送心跳包、定时查询数据刷新UI界面、或者做一些轮询的任务等等。如果你有以上的这些需求，那么定时器是一个方便的选择。 如何使用定时器 注册定时器为了方便使用，我们以填充结构体的形式来添加定时器。在Logic.cc文件中，默认会有这样一个结构体数组： /** * 注册定时器 * 在此数组中添加即可 */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //定时器id=0, 时间间隔为6秒 //{1, 1000}, }; 如果我们想要添加一个定时器时，只需要在这个数组中添加结构体即可。这个结构体的定义如下：typedef struct { int id; // 定时器ID ， 不能重复 int time; // 定时器时间间隔 单位/毫秒 }S_ACTIVITY_TIMEER; 添加定时器的逻辑代码在数组中注册定时器后，当某一个定时器触发时，系统将调用对应 Logic.cc 文件中的 void onUI_Timer(int id)函数，针对这个定时器的所有操作代码，就是添加在这个函数中，函数具体定义如下： /** * 定时器触发函数 * 不建议在此函数中写耗时操作，否则将影响UI刷新 * @param id * 当前所触发定时器的id，与注册时的id相同 * @return true * 继续运行当前定时器 * false * 停止运行当前定时器 */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } 该函数同样是随 Logic.cc 文件默认生成。注意函数的参数 id ，它与结构体数组中定义的 id 值相同，我们可以根据 id 值判断当前触发的是哪一个定时器，从而做一些针对性的操作。 [!Note] 注意：每个界面的定时器都是独立的，不同界面定时器的id可以相同；注册的定时器，只要界面不销毁（见界面活动周期），都会一直在运行；注册了无需手动停止，界面销毁了就会自动停止了。 具体样例 接下来我们以一个具体的例子讲述定时器的使用。假设我们需要实现一个这样的功能： 有一个整形变量，每隔一秒钟，将变量累加1，并且将最新结果显示到屏幕上。具体实现过程如下： 首先我们在UI文件中添加一个文本控件，用于显示累加的结果。 注册定时器， 在 mainLogic.cc 的定时器数组中，添加一个结构体， 定时器id为1，时间间隔为1秒。注意时间单位为毫秒。 在 mainLogic.cc 中，定义静态整型变量，初始化为0 在void onUI_Timer(int id)函数中，添加累加代码，并将其显示到文本控件中。 编译运行 样例代码 见 样例代码 里的 TimerDemo 工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"how_to_register_timer.html":{"url":"how_to_register_timer.html","title":"手动注册/停止定时器 ","keywords":"","body":"如何任意开启停止定时器 我们可以在REGISTER_ACTIVITY_TIMER_TAB中添加预设的定时器，但这种方式不够灵活，无法任意开启/停止，下面介绍另一种添加定时器的方法。 Activity类中有提供三个关于定时器的方法， 下面介绍如何使用。 /** * 注册定时器 */ void registerUserTimer(int id, int time); /** * 取消定时器 */ void unregisterUserTimer(int id); /** * 重置定时器 */ void resetUserTimer(int id, int time); 在logic.cc中，添加一个变量，标识该定时器是否已经注册。 /** * 是否注册了定时器 */ static bool isRegistered = false; #define TIMER_HANDLE 2 我们再添加两个按键，在按键的点击事件中，我们分别添加 注册定时器、取消定时器的代码。 static bool onButtonClick_ButtonTimerOn(ZKButton *pButton) { //如果没有注册才进行注册定时器 if (!isRegistered) { mActivityPtr->registerUserTimer(TIMER_HANDLE, 500); isRegistered = true; } return false; } static bool onButtonClick_ButtonTimerOff(ZKButton *pButton) { //如果已经注册了定时器，则取消注册 if (isRegistered) { mActivityPtr->unregisterUserTimer(TIMER_HANDLE); isRegistered = false; } return false; } [!Warning] 以上提到的 registerUserTimer、unregisterUserTimer、resetUserTimer 三个函数不能在 onUI_Timer函数中调用，会造成死锁。 样例代码 参考样例代码 中TimerDemo项目。预览效果图： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"linux_serial_programming.html":{"url":"linux_serial_programming.html","title":"Linux串口编程","keywords":"","body":"Linux串口编程 [!Note] 本篇文档旨在让大家理解FlyThings项目串口部分的代码是如何从零到有的这个过程，从而更容易理解我们最终提供的串口部分代码流程。理解之后，您可以根据自己的需求任意修改源代码。 该产品基于Linux系统，所以我们可以完全沿用标准Linux编程来操作串口。 基本步骤 我将Linux串口编程分为以下5个步骤：打开串口、配置串口、读串口、写串口、关闭串口。 打开串口 #include int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); open是系统函数，负责打开某个节点 以上代码表示：以可读可写的方式，尝试打开/dev/ttyS0这个串口，如果打开成功，返回一个非负值，这个值表示串口描述符，若失败，返回一个负数，即错误码。 /dev/ttyS0 可以理解为串口号，类似Windows系统上的COM1。 配置串口成功打开串口后，还需要配置串口，设置波特率等参数。 int openUart() { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); struct termios oldtio = { 0 }; struct termios newtio = { 0 }; tcgetattr(fd, &oldtio); //设置波特率为115200 newtio.c_cflag = B115200 | CS8 | CLOCAL | CREAD; newtio.c_iflag = 0; // IGNPAR | ICRNL newtio.c_oflag = 0; newtio.c_lflag = 0; // ICANON newtio.c_cc[VTIME] = 0; newtio.c_cc[VMIN] = 1; tcflush(fd, TCIOFLUSH); tcsetattr(fd, TCSANOW, &newtio); //设置为非阻塞模式，这个在读串口的时候会用到 fcntl(fd, F_SETFL, O_NONBLOCK); return fd; } [!Note] 以上是本平台的默认串口配置，8个数据位，1个停止位，无校验。非特殊需求请勿修改，受限于硬件与驱动，如果修改其为其他配置，可能会无效。 读串口 #include unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); read是系统函数，它提供了读串口的功能，该函数需要三个参数： 第一个参数 是串口描述符，即打开串口步骤中open函数的返回值。 第二个参数 是缓冲区指针，用于保存读取的串口数据。 第三个参数 是缓冲区长度，也表示本次最多能读取多少个字节。 调用该函数，如果返回值大于0，表示有正确收到串口数据，且返回值等于读取到数据量的字节数。如果返回值小于或等于0， 表示有错误或者暂时没读到数据。 发送串口 #include unsigned char buffer[4] = {0}; buffer[0] = 0x01; buffer[1] = 0x02; buffer[2] = 0x03; buffer[3] = 0x04; int ret = write(fd, buffer, sizeof(buffer)); write是系统函数，它提供了发送串口的功能，该函数需要三个参数： 第一个参数 是串口描述符，即打开串口步骤中open函数的返回值。 第二个参数 是待发送缓冲区指针。 第三个参数 是待发送缓冲区长度 调用该函数, 如果返回值大于0， 且返回值等于传递的第三个参数，表示发送成功。如果返回值小于或等于0，表示异常。 [!Note] read函数只是顺序读取串口收到的数据流，但不能保证一次就读取完整的数据。例如，短时间内，串口收到了1000个字节的数据，缓冲区的长度为1024，虽然1024 > 1000，但可能我们第一次read后仅读取了一部分数据，所以我们需要多次read，才能保证数据读取完整。 关闭串口#include close(fd); close是系统函数，需要的参数是串口描述符，即打开串口步骤中open函数的返回值。 综合使用 以下是一个简单的Linux串口编程的完整例子，上面提到的几个基本步骤都有用到。 #include #include #include int main(int argc, char** argv) { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); if (fd 0) { //依次将读取到的数据输出到日志 for (int i = 0; i 如何从软件上保证串口稳定通信 当我们将上面的例子尝试应用到正式产品的时候，会不可避免地遇到这些问题： 串口通信可能会受到一定的干扰，她是不可靠的。所以通常会制定通信协议， 这个协议一般包括帧头、帧尾、帧内容、校验等部分，协议的使用可以最大程度地保证数据的完整性，使得串口通信变得可靠。 举例：如果我们定义协议， 以 0xFF 0x55开头，后面跟上8个有效字节为完整的一帧。那么上面Linux串口通信的例子的代码大概会修改成这样子： //仅列出关键部分，其余代码省略 while (true) { unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if (ret == 10) { LOGD(\"正确读到一帧数据\"); } else if (ret 当我们将上面的代码用于实际测试，频繁的收发，很可能会遇到 协议头正确，但是帧长度错误 的情况。为什么？因为Linux系统调度或其他的原因，read函数不能保证一次性将当时串口收到的所有数据都返回给你，为了完整地读取串口数据，你需要多次调用read函数，然后将前后收到的数据拼接起来，再按协议校验数据，从中找到有效的帧。虽然这么做代码变得复杂，但它是合理的。根据刚才的分析，再将例子代码修改为这样子： //提高buffer数组的作用域，使得while循环中不会清空数据 unsigned char buffer[1024] = {0}; // 增加一个`legacy`变量，表示buffer中遗留的数据长度 int legacy = 0; while (true) { //根据legacy的大小，调整缓冲区的起始指针及大小，防止数据覆盖 int ret = read(fd, buffer + legacy, sizeof(buffer) - legacy); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if ((ret + legacy) == 10) { LOGD(\"正确读到一帧数据\"); //清空legacy legacy = 0; } else if (ret 实际应用中，我们不仅要处理串口通信，还要响应屏幕上各个按键等内容。上面的例子中，从main函数开始，接着就是一个while循环，然后一直处理着串口消息，做不了其他事。Linux系统支持 多线程 ,通常，我们会新建一个子线程，再将这个while循环部分放到子线程中处理，这样就不会耽误我们继续其他操作。如何修改，这里就不给出代码了。 总结 鉴于Linux上的串口通信编程，需要处理诸多细节的问题，FlyThings提供了一份通用代码，它解决了如下问题： 串口的打开、关闭、读写操作 协议的拼接处理 提供统一的数据回调接口 这部分的源码是完全 开源 的，可以任意新建一个FlyThings项目， 源码在项目的 uart 文件夹下。如果对比 UartContext类的源码，你应该可以从中看到本篇文档的影子。 希望可以通过本篇文档，可以让你熟悉FlyThings项目的串口通讯部分的内容。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"serial_introdoction.html":{"url":"serial_introdoction.html","title":"简介","keywords":"","body":"串口简介 下面这张图，是最最最简单的一个通讯模型；屏和MCU之间通过串口进行通信，它们之间只要定好协议，就可以进行交互了 这里有点需要注意的，传统的串口屏它们是作为从机端设备，通过MCU发相应的指令来控制它们；而我们的串口屏不一样，我们的屏是具有逻辑的，它可以自己实现交互，在这里作为主机端。 如果由自己从头来开发这部分通讯代码，那工作量将是巨大的；为了简化开发流程，使开发人员更多的关注业务逻辑的开发，我们的工具在新建工程时会自动生成串口通讯的代码： 同时，我们也提供了协议数据与界面交互的回调接口： 开发人员更多的是关注数据在UI界面上的展示，而通讯部分则由我们的框架自动完成。 通讯框架中的协议解析部分需根据开发人员使用的通讯协议做相应的改动，接下来的通讯框架讲解这一章节中我们会重点介绍原理及需要修改的部分，以及通过通讯案例实战这一章节中的一些案例来加深我们对这套通讯框架的认识。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"serial_framework.html":{"url":"serial_framework.html","title":"通讯框加讲解","keywords":"","body":"通讯框架讲解 这一章节重点讲解通讯框架的实现原理，理论的东西比较多，第一遍可以粗略的过一下，大概清楚这通讯模型，配套案例动手做一下，再回过头来巩固一下原理，多玩几遍，熟悉过后，自己想怎么自定义协议都可以。 代码框架 软件APP部分分为两层 uart协议解析和封装的串口HAL层 UartContext：串口的实体控制层，提供串口的开关，发送，接收接口 ProtocolData：定义通讯的数据结构体，用于保存通讯协议转化出来的实际变量； ProtocolSender：完成数据发送的封装； ProtocolParser：完成数据的协议解析部分，然后将解析好的数据放到ProtocolData的数据结构中；同时管理了应用监听串口数据变化的回调接口； APP应用接口层 通过ProtocolParser提供的接口注册串口数据接收监听获取串口更新出来的ProtocolData。 通过ProtocolSender提供的接口往MCU发送指令信息 我们再细化一下这流程： 可以清楚的看到 接收 和 发送 两路流程一上一下，每一层的功能还是比较清晰的； 具体到代码对应的流程： 无论是接收还是发送流程，最终都是要经过 UartContext 对串口进行读写操作，这是一些标准化的流程，所以 UartContext 我们基本上是不用去修改的，也可以不用理会它是怎么实现的，当然，有兴趣的可以去看一下。 到此，我们对这个通讯模型有个大概的了解，之后我们再来看具体代码的实现。 协议接收部分使用和修改方法 通讯协议格式修改 这里我们举一个比较常见的通讯协议例子： 协议头（2字节） 命令（2字节） 数据长度（1字节） 数据（N） 校验（1字节 可选) 0xFF55 Cmd len data checksum CommDef.h 文件中定义了同步帧头信息及最小数据包大小信息： // 需要打印协议数据时，打开以下宏 //#define DEBUG_PRO_DATA // 支持checksum校验，打开以下宏 //#define PRO_SUPPORT_CHECK_SUM /* SynchFrame CmdID DataLen Data CheckSum (可选) */ /* 2Byte 2Byte 1Byte N Byte 1Byte */ // 有CheckSum情况下最小长度: 2 + 2 + 1 + 1 = 6 // 无CheckSum情况下最小长度: 2 + 2 + 1 = 5 #ifdef PRO_SUPPORT_CHECK_SUM #define DATA_PACKAGE_MIN_LEN 6 #else #define DATA_PACKAGE_MIN_LEN 5 #endif // 同步帧头 #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 ProtocolParser.cpp 文件，配置文件命令格式： /** * 功能：解析协议 * 参数：pData 协议数据，len 数据长度 * 返回值：实际解析协议的长度 */ int parseProtocol(const BYTE *pData, UINT len) { UINT remainLen = len; // 剩余数据长度 UINT dataLen; // 数据包长度 UINT frameLen; // 帧长度 /** * 以下部分需要根据协议格式进行相应的修改，解析出每一帧的数据 */ while (remainLen >= DATA_PACKAGE_MIN_LEN) { // 找到一帧数据的数据头 while ((remainLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) { pData++; remainLen--; continue; } if (remainLen remainLen) { // 数据内容不全 break; } // 打印一帧数据，需要时在CommDef.h文件中打开DEBUG_PRO_DATA宏 #ifdef DEBUG_PRO_DATA for (int i = 0; i 上面的解析流程有点复杂，下面我们先给出一张图，再来分析可能会容易理解一些；一包数据可能包含0到多帧数据，下面这张图里，我们标出来有3帧数据，另外还有一帧数据不全，还少5个数据，不完整的那一帧数据将会拼接到下一包数据里 协议头需要修改 // 1.修改协议头部分的定义，如果协议头长度有变化，则要注意修改协议头判断部分语句。 #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 // 2.协议头长度变化的时候需要修改这里。 while ((mDataBufLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) 协议长度的位置或者长度计算方式发生变化的修改 // 这里的pData[4] 代表的是第5个数据是长度的字节，如果变化了在这里修改一下。 dataLen = pData[4]; // 帧长度一般是数据长度加上头尾长度。如果协议中传的长度计算方式发生变化修改这个部分。 frameLen = dataLen + DATA_PACKAGE_MIN_LEN; 校验发生变化的情况 /** * 默认我们是关闭checksum校验的，如果需要支持checksum校验，在CommDef.h文件中打开PRO_SUPPORT_CHECK_SUM宏 * 当校验不一样的时候需要修改校验方法， * 1.校验内容变化修改这个位置 * if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) * 2.校验计算公式变化修改 getCheckSum函数里边的内容 */ /** * 获取校验码 */ BYTE getCheckSum(const BYTE *pData, int len) { int sum = 0; for (int i = 0; i 当完成一帧数据的接收后程序会调用procParse 解析 // 支持checksum校验，需要时在CommDef.h文件中打开PRO_SUPPORT_CHECK_SUM宏 #ifdef PRO_SUPPORT_CHECK_SUM // 检测校验码 if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) { // 解析一帧数据 procParse(pData, frameLen); } else { LOGE(\"CheckSum error!!!!!!\\n\"); } #else // 解析一帧数据 procParse(pData, frameLen); #endif 通讯协议数据怎么和UI控件对接 继续前面的协议框架我们进入到procParse的解析部分。 这里重点的代码是：ProtocolParser.cpp 打开文件然后找到void procParse(const BYTE *pData, UINT len) /* * 协议解析 * 输入参数: * pData: 一帧数据的起始地址 * len: 帧数据的长度 */ void procParse(const BYTE *pData, UINT len) { /* * 解析Cmd值获取数据赋值到sProtocolData结构体中 */ switch (MAKEWORD(pData[2], pData[3])) { case CMDID_POWER: sProtocolData.power = pData[5]; LOGD(\"power status:%d\",sProtocolData.power); break; } notifyProtocolDataUpdate(sProtocolData); } 以上 MAKEWORD(pData[2], pData[3]) 在我们的协议例子中表示Cmd值； 当数据解析完成后通过notifyProtocolDataUpdate 通知到页面UI更新，这个部分请参照后面的UI更新部分 数据结构 上面的协议解析到了sProtocolData 结构体中，sProtocolData 是一个静态的变量，用于保存MCU（或者其他设备）串口发送过来的数据值。 这个数据结构在ProtocolData.h文件中。这里可以添加整个项目里面需要使用到的通讯变量 typedef struct { // 可以在这里面添加协议的数据变量 BYTE power; } SProtocolData; UI更新 UI界面在工具生成Activity.cpp的时候就已经完成了registerProtocolDataUpdateListener ，也就是说当数据更新的时候logic里面页面程序就会收到数据。 static void onProtocolDataUpdate(const SProtocolData &data) { // 串口数据回调接口 if (mProtocolData.power != data.power) { mProtocolData.power = data.power; } if (mProtocolData.eRunMode != data.eRunMode) { mProtocolData.eRunMode = data.eRunMode; mbtn_autoPtr->setSelected(mProtocolData.eRunMode == E_RUN_MODE_MANUAL); if (mProtocolData.eRunMode != E_RUN_MODE_MANUAL) { mbtn_external_windPtr->setText(mProtocolData.externalWindSpeedLevel); mbtn_internal_windPtr->setText(mProtocolData.internalWindSpeedLevel); } } ... } 在代码里面我们看到一个变量 mProtocolData，这是一个页面里面的static 的变量。在onUI_init()的时候会初始化。 如： static SProtocolData mProtocolData; static void onUI_init() { //Tips :添加 UI初始化的显示代码到这里,如:mText1->setText(\"123\"); mProtocolData = getProtocolData(); // 初始化串口数据的结构体。 // 开始初始化页面的UI显示 } 串口数据发送 打开ProtocolSender.cpp 当APP层需要发送数据给MCU（或其他设备）的时候直接调用sendProtocol 就可以了。 具体的协议封装由sendProtocol方法完成。用户可以根据自己的协议要求修改这个部分的代码。 /** * 需要根据协议格式进行拼接，以下只是个模板 */ bool sendProtocol(const UINT16 cmdID, const BYTE *pData, BYTE len) { BYTE dataBuf[256]; dataBuf[0] = CMD_HEAD1; dataBuf[1] = CMD_HEAD2; // 同步帧头 dataBuf[2] = HIBYTE(cmdID); dataBuf[3] = LOBYTE(cmdID); // 命令字节 dataBuf[4] = len; UINT frameLen = 5; // 数据 for (int i = 0; i send(dataBuf, frameLen); } 当界面上有个按键按下的时候可以操作： BYTE mode[] = { 0x01, 0x02, 0x03, 0x04 }; sendProtocol(0x01, mode, 4); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"serial_example.html":{"url":"serial_example.html","title":"通讯案例实战","keywords":"","body":"通讯案例实战 通过前面章节通讯框架讲解，可能看的也是云里雾里的，这里我们先总结一下，串口通讯主要有以下4点内容： 接收数据 解析数据 展示数据 发送数据 其中 解析数据 部分较为复杂，需要根据具体的通讯协议做相应的改动；这一章节我们就不讲理论的东西了，举一些实战案例，大伙多玩几遍就可以玩溜了。 案例一 这里我们还是以前面的通讯协议为例，实现自己的一个简单的通讯程序；完整代码见 样例代码 里控件样例的 UartDemo 工程；我们最终要实现的效果是，通过串口发送指令来控制显示屏上的仪表指针旋转，UI效果图如下： 我们只需要修改 3处 地方就可以实现控制仪表指针旋转； 1). 重温一下前面介绍的协议格式，这里我们新增自己的协议指令CMDID_ANGLE对应的值为0x0001： 协议头（2字节） 命令（2字节） 数据长度（1字节） 数据（N） 校验（1字节 可选) 0xFF55 0x0001（见以下CMDID_ANGLE） 1 angle checksum 协议数据结构体里我们新增1变量，见 ProtocolData.h: /******************** CmdID ***********************/ #define CMDID_POWER 0x0 #define CMDID_ANGLE 0x1 // 新增ID /**************************************************/ typedef struct { BYTE power; BYTE angle; // 新增变量，用于保存指针角度值 } SProtocolData; 2). 由于我们使用的还是前面定义的协议格式，所以这里协议解析的部分我们不需要做任何改动，只需在procParse中处理对应的CmdID值即可： /** * 解析每一帧数据 */ static void procParse(const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; case CMDID_ANGLE: // 新增部分，保存角度值 sProtocolData.angle = pData[5]; break; } // 通知协议数据更新 notifyProtocolDataUpdate(sProtocolData); } 3). 我们再来看界面接收到协议数据的回调接口，见 logic/mainLogic.cc： static void onProtocolDataUpdate(const SProtocolData &data) { // 串口数据回调接口 // 设置仪表指针旋转角度 mPointer1Ptr->setTargetAngle(data.angle); } 完成以上流程后，接下来我们只需要通过MCU向屏发送相应的指令就可以看到仪表指针的旋转了；为了简单起见，我们这个程序里不做checksum校验，协议数据如下： 帧头 CmdID 数据长度 角度值 0xFF 0x55 0x00 0x01 0x01 angle 我们可以在CommDef.h文件中打开DEBUG_PRO_DATA宏，打印接收到的协议数据： 到此，串口的 接收数据 ---> 解析数据 ---> 展示数据 就算完成了； 最后我们再来模拟一下串口发送数据；这里，我们给出的程序里，开启了一个定时器，2s模拟一次数据发送： static bool onUI_Timer(int id) { // 模拟发送串口数据 BYTE data = rand() % 200; sendProtocol(CMDID_ANGLE, &data, 1); return true; } 以上代码其实就是模拟设置角度值，我们可以通过短接屏上通讯串口的TX和RX，实现自发自收，也是可以看到仪表指针旋转的； 到此，我们的串口演示程序就介绍完了，开发人员可以先把演示程序编译烧录到机器里看一下效果，然后再在这基础之上增加一些协议，熟悉这整个通讯流程。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"serial_configuration.html":{"url":"serial_configuration.html","title":"串口配置","keywords":"","body":"如何配置串口 串口号的选择 由于软件与硬件的设计兼容问题，导致软件串口号与硬件上的串口号标识可能存在不同的情况，具体对应关系如下： Z11系列平台 软件串口号 硬件串口号 ttyS0 UART1 ttyS1 UART2 Z6系列平台 软件串口号 硬件串口号 ttyS0 UART0 ttyS1 UART1 ttyS2 UART2 A33系列平台 软件串口号 硬件串口号 ttyS1 UART1 ttyS2 UART2 ttyS3 UART3 串口波特率配置 新建工程时配置波特率 工程属性修改波特率 右键工程, 在弹出框中选择 Properties 选项, 弹出如下属性框 串口打开与关闭 打开源码路径 jni/Main.cpp；我们可以看到在程序初始化和销毁时分别有对串口打开和关闭的操作 void onEasyUIInit(EasyUIContext *pContext) { LOGD(\"onInit\\n\"); // 打开串口 UARTCONTEXT->openUart(CONFIGMANAGER->getUartName().c_str(), CONFIGMANAGER->getUartBaudRate()); } void onEasyUIDeinit(EasyUIContext *pContext) { LOGD(\"onDestroy\\n\"); // 关闭串口 UARTCONTEXT->closeUart(); } powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"multiuart.html":{"url":"multiuart.html","title":"多串口配置","keywords":"","body":"多串口配置 常规项目默认只支持一个串口，如果您要使用双串口，甚至多串口，请下载DoubleUartDemo样例， 该样例在常规项目中修改了串口部分代码，以支持多串口。 变更 变更部分见如下说明。 uart部分代码经过修改，所以项目属性里的串口配置失效。 串口号及波特率请参照 jni/uart/UartContext.cpp 文件中的 init()函数修改。 void UartContext::init() { uart0 = new UartContext(UART_TTYS0); uart0->openUart(\"/dev/ttyS0\", B9600); uart1 = new UartContext(UART_TTYS1); uart1->openUart(\"/dev/ttyS1\", B9600); } 发送数据到指定串口 unsigned char buf[2] = {1, 1}; sendProtocolTo(UART_TTYS1, 1, buf, 2); //发送到TTYS1串口 unsigned char buf[2] = {0}; sendProtocolTo(UART_TTYS0, 1, buf, 2);//发送到TTYS0串口 接收串口数据的方式与常规项目相同如果需要区分数据来自哪一个串口，建议在SProtocolData 结构体中添加一个字段标识该帧来自哪一个串口。 修改 uart/ProtocolData.h typedef struct { BYTE power; int uart_from; //来自哪一个串口 } SProtocolData; 修改 uart/ProtocolParser.cpp /** * 解析每一帧数据 */ static void procParse(int uart, const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; } sProtocolData.uart_from = uart; //标识该帧来自哪一个串口 // 通知协议数据更新 notifyProtocolDataUpdate(sProtocolData); } 然后在Logic.cc中，可以使用uart_from字段判断该数据来自哪一个串口。 static void onProtocolDataUpdate(const SProtocolData &data) { LOGD(\"onProtocol %d\", data.uart_from); char buf[128] = {0}; snprintf(buf, sizeof(buf), \"收到串口 %d的数据\", data.uart_from); mTextview1Ptr->setText(buf); } 样例代码 完整代码见样例代码 里的 DoubleUartDemo 工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"wifi.html":{"url":"wifi.html","title":"wifi设置 ","keywords":"","body":"启动wifi设置界面 EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); wifi操作接口说明 获取WifiManager对象 #include \"net/NetManager.h\" WifiManager *pWM = NETMANAGER->getWifiManager(); // 可以定义个宏,方便以下接口调用 #define WIFIMANAGER NETMANAGER->getWifiManager() 检测机器是否支持wifi WIFIMANAGER->isSupported(); 检测wifi是否打开 WIFIMANAGER->isWifiEnable(); 开关wifi WIFIMANAGER->enableWifi(true); 扫描wifi WIFIMANAGER->startScan(); 连接wifi WIFIMANAGER->connect(ssid, pw); 断开wifi连接 WIFIMANAGER->disconnect(); 检测wifi是否已连接 WIFIMANAGER->isConnected(); 获取已连接wifi的信息 WIFIMANAGER->getConnectionInfo(); 注册、反注册wifi信息监听 void addWifiListener(IWifiListener *pListener); void removeWifiListener(IWifiListener *pListener); 样例代码 见 样例代码 里的 NetDemo 工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"wifi_ap.html":{"url":"wifi_ap.html","title":"热点设置 ","keywords":"","body":"启动热点设置界面 EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); 热点操作接口说明 获取SoftApManager对象 #include \"net/NetManager.h\" SoftApManager *pSAM = NETMANAGER->getSoftApManager(); // 可以定义个宏，方便以下接口调用 #define SOFTAPMANAGER NETMANAGER->getSoftApManager() 开关热点 SOFTAPMANAGER->setEnable(true); 热点是否是打开状态 SOFTAPMANAGER->isEnable(); 获取当前热点状态 SOFTAPMANAGER->getSoftApState(); // 有以下几种状态 E_SOFTAP_DISABLED // 关闭状态 E_SOFTAP_ENABLING // 打开过程中 E_SOFTAP_ENABLED // 打开成功 E_SOFTAP_DISABLING // 关闭过程中 E_SOFTAP_ENABLE_ERROR // 打开失败 修改热点名称、密码 SOFTAPMANAGER->setSsidAndPwd(\"zkswe\", \"abcd1234\"); 获取热点名称、密码 SOFTAPMANAGER->getSsid(); SOFTAPMANAGER->getPwd(); 注册、反注册热点状态监听 void addSoftApStateListener(ISoftApStateListener *pListener); void removeSoftApStateListener(ISoftApStateListener *pListener); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"audio.html":{"url":"audio.html","title":"音频播放 ","keywords":"","body":"音频播放 创建 ZKMediaPlayer对象，类型为 ZKMediaPlayer::E_MEDIA_TYPE_AUDIO static ZKMediaPlayer sPlayer(ZKMediaPlayer::E_MEDIA_TYPE_AUDIO); 注册消息监听 // 消息监听接口如下 class PlayerMessageListener : public ZKMediaPlayer::IPlayerMessageListener { public: virtual void onPlayerMessage(ZKMediaPlayer *pMediaPlayer, int msg, void *pMsgData) { switch (msg) { case ZKMediaPlayer::E_MSGTYPE_ERROR_INVALID_FILEPATH: case ZKMediaPlayer::E_MSGTYPE_ERROR_MEDIA_ERROR: // 出错消息 break; case ZKMediaPlayer::E_MSGTYPE_PLAY_STARTED: // 开始播放消息 break; case ZKMediaPlayer::E_MSGTYPE_PLAY_COMPLETED: // 播放结束消息 break; } } }; static PlayerMessageListener sPlayerMessageListener; // 注册消息监听 sPlayer.setPlayerMessageListener(&sPlayerMessageListener); 操作接口说明 sPlayer.play(\"/mnt/extsd/music/test.mp3\"); // 播放指定路径的文件 sPlayer.pause(); // 暂停播放 sPlayer.resume(); // 恢复播放 sPlayer.seekTo(int msec); // 跳转到msec时间播放， msec 单位: ms sPlayer.stop(); // 停止播放 sPlayer.isPlaying(); // 是否播放中，返回bool型 sPlayer.getDuration(); // 获取当前播放歌曲的总时间 sPlayer.getCurrentPosition(); // 获取当前播放歌曲的当前播放时间点 // Z6、Z11、A33平台设置音量接口为2个参数 sPlayer.setVolume(0.5, 0.5); // 设置媒体音量，音量范围：0.0 ~ 1.0 // H500S、Z20、Z21及之后的平台设置音量接口为1个参数 sPlayer.setVolume(0.5); // 设置媒体音量，音量范围：0.0 ~ 1.0 [!Note] 播放的音频文件不能过短，时间过短可能导致无法正常播放。 完整代码见样例代码 控件样例里的 MusicDemo 工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"thread.html":{"url":"thread.html","title":"线程","keywords":"","body":"线程 系统支持pthread线程，如果你了解 pthread接口，也可以用posix接口实现线程。另外，我们还提供一个对 pthread的封装类。该类包括如下三个部分 Thread.h：线程类 Mutex.h：锁类 Condition.h：条件变量类 线程的使用 引入头文件，继承Thread类，实现virtual bool threadLoop()函数， 按需选择实现readyToRun函数。 #include class MyThread: public Thread { public: /** * 线程创建成功后会调用该函数，可以在该函数中做一些初始化操作 * return true 继续线程 * false 退出线程 */ virtual bool readyToRun() { LOGD(\"Thread 已经创建完成\"); return true; } /** * 线程循环函数 * * return true 继续线程循环 * false 推出线程 */ virtual bool threadLoop() { LOGD(\"线程循环函数\"); //检查是否有退出线程的请求，如果有，则返回false，立即退出线程 if (exitPending()) { return false; } //累加计数，并显示到屏幕上 loop_count += 1; mTextView2Ptr->setText(loop_count); //为了方便观察，这里添加休眠500ms usleep(1000 * 500); //返回真，继续下次线程循环 return true; } }; 实例化线程对象 static MyThread my_thread; 启动线程 //调用线程类的run函数可以启动线程， //参数为线程名，可以任意指定。 my_thread.run(\"this is thread name\"); 停止线程Thread类提供了两个请求退出线程的函数，同步与异步的区别，具体使用如下： void requestExitAndWait() //请求退出线程，并且等待，直到线程完全退出后，该函数才返回 my_thread.requestExitAndWait(); void requestExit() //请求退出线程，发出请求后该函数立即返回，但此时，并不代表线程也完成退出了 my_thread.requestExit(); 调用上面两个函数中的任意一个后，在threadLoop函数中，我们就可以通过 bool exitPending()成员函数判断是否有退出线程的请求。 virtual bool threadLoop() { LOGD(\"线程循环函数\"); //检查是否有退出线程的请求，如果有，则返回false，立即退出线程 if (exitPending()) { return false; } return true; } [!Note] 注意，以上函数只是添加一个请求退出线程的标记而已，并不是强制终止线程。如果你在 threadLoop函数中一直执行某些操作，让 threadLoop函数一直无法结束，那么该线程是不会停止的。正确的做法是，在threadLoop中检查退出线程请求，或者检查某个终止条件，然后返回 false。 [!Warning] 禁止在threadLoop函数中调用 requestExitAndWait和requestExit函数，可能造成死锁。 判断线程是否还在运行 if (my_thread.isRunning()) { mTextView4Ptr->setText(\"正在运行\"); } else { mTextView4Ptr->setText(\"已停止\"); } Thread流程图 在经过上面各个步骤的讲解后，再结合流程图，应该会有更深的理解。 样例代码 见 样例代码 控件样例里的 ThreadDemo 工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"mutex.html":{"url":"mutex.html","title":"互斥量","keywords":"","body":"互斥量/锁 当我们的程序里引入线程后，某些情况下又会引出其他问题，导致程序Bug。 多线程编程中，这样的情况非常普遍：就是A线程对一个变量赋值，然后B线程读这个值。为了方便说明，我们将这种情况翻译为下面的代码。定义一个struct Student全局变量，还定义两个线程，A线程负责对student变量赋值；B线程对student变量做了拷贝，并读出变量的各个成员，显示到日志上。请问：如果同时启动两个线程，那么B线程的日志会输出怎样的结果？ #include struct Student { char name[24]; //姓名 int age; //年龄 int number; //学号 }; struct Student student = {0}; class AThread: public Thread { public: virtual bool threadLoop() { snprintf(student.name, sizeof(student.name), \"xiaoming\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { struct Student s = student; LOGD(\"姓名：%s\", s.name); LOGD(\"年龄：%d\", s.age); LOGD(\"学号：%d\", s.number); return true; } }; static AThread athread; static BThread bthread; 首先，我们希望的结果是日志里输出 姓名：xiaoming 年龄：10 学号：20200101 实际上，如果测试的次数足够多，可能大部分的输出与我们期望的相同，还有可能会输出以下这些结果： 姓名： 年龄：0 学号：0 姓名：xiaoming 年龄：0 学号：0 姓名：xiaoming 年龄：10 学号：0 如果程序中出现了 “异常” 结果，肯定算是一个Bug了。 分析原因 当程序存在多线程时，线程执行顺序是由系统灵活调度的，可能出现A线程执行了一部分指令，又转到B线程执行一部分指令，又转到A线程执行指令。 对上面的例子而言， A线程中，共有三条语句完成对 student 变量的完整赋值，当只执行完第一条语句，仅完成了对 name 的赋值，此时系统转而切换到B线程， 那么B线程中，这时读取 student 变量，就会出现 name 字段有效，而 age 和 number为0的情况。 其他的异常结果，同理。 如何解决 由原因得出，只要我们保证A线程中， student 的所有赋值操作都完成后，B线程再去读 student变量，这样就没有问题了。 如何实现 在编程中，有一个 互斥锁 的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为\" 互斥锁\" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。 如果你熟悉Linux编程，可以用标准实现。这里我们介绍我们封装的 互斥量类 使用。 定义一个互斥量 static Mutex mutex1; 在需要加锁的地方，定义局部 Mutex::Autolock 类实例加锁。该类利用了局部变量的生命周期以及c++的类的构造、析构函数，自动实现加锁、解锁操作。Mutex::Autolock _l(mutex1); 结合上面A、B线程的例子，修改的代码如下： #include struct Student { char name[24]; //姓名 int age; //年龄 int number; //学号 }; struct Student student = {0}; //定义互斥量 static Mutex mutext1; class AThread: public Thread { public: virtual bool threadLoop() { //在该函数的语句进行加锁，函数结束后，自动解锁 Mutex::Autolock _lock(mutext1); snprintf(student.name, sizeof(student.name), \"xiaoming\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { //在该函数的语句进行加锁，函数结束后，自动解锁 Mutex::Autolock _lock(mutext1); struct Student s = student; LOGD(\"姓名：%s\", s.name); LOGD(\"年龄：%d\", s.age); LOGD(\"学号：%d\", s.number); return true; } }; static AThread athread; static BThread bthread; 代码中，我们对A、B线程内，student相关的操作都进行了加锁。当执行A线程时，Mutex::Autolock _lock(mutext1); 语句会获得 mutex1互斥量，当A线程没有解锁，又转去执行B线程时，执行到B线程内的 Mutex::Autolock _lock(mutext1); 语句，它也想获得 mutext1互斥量，但是，这个互斥量已经被A线程抢先获得，现在B线程想要获得的话，只能等，等到A线程释放 mutext1 ，B线程才能正常获得 mutext1 互斥量，然后继续执行接下来的语句。使用互斥量后，使得被加锁的代码部分，能够互斥执行，且保证完整性。 在我们的项目中，也有一个用到互斥量的例子，见源码 jni/uart/ProtocolParser.cpp ： void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener) { Mutex::Autolock _l(sLock); LOGD(\"registerProtocolDataUpdateListener\\n\"); if (pListener != NULL) { sProtocolDataUpdateListenerList.push_back(pListener); } } 如果对互斥量概念还不够理解，可以从网上获取更多关于 互斥量的资料。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"screenshot.html":{"url":"screenshot.html","title":"截屏","keywords":"","body":"截屏 产品开发完毕后，编写使用说明书时，可能需要运行界面的截图，可参考如下代码截屏。 准备 下载screenshot.h 源文件，保存到项目 jni目录下。 使用 引用头文件#include \"screenshot.h\" 调用接口进行截屏 static bool onButtonClick_Button1(ZKButton *pButton) { //截取当前屏幕，保存为bmp图片，保存到TF卡目录下 //每调用一次该函数，保存的图片名递增 //例如 screenshot01.bmp、screenshot02.bmp、screenshot03.bmp Screenshot::AutoSave(); return false; } 默认图片保存到TF卡，所以尽量插上TF卡再截屏。如果需要保存到其他位置，可以自行修改源码。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"data.html":{"url":"data.html","title":"数据存储 ","keywords":"","body":"数据存储 在某些应用场景中需要永久存储一些信息(掉电保存数据)，如账号、密码或其他配置的一些信息，这些数据的特点是：总量少，但需要灵活存取。像这类情况，就不必使用数据库。我们提供了一套简单的数据存储接口，以键-值对的方式存储。 所需头文件 #include \"storage/StoragePreferences.h\" 主要接口 // 存储接口 static bool putString(const std::string &key, const std::string &val); static bool putInt(const std::string &key, int val); static bool putBool(const std::string &key, bool val); static bool putFloat(const std::string &key, float val); // 删除指定键 static bool remove(const std::string &key); // 清空存储数据 static bool clear(); // 获取接口，获取不到对应键值，返回defVal默认值 static std::string getString(const std::string &key, const std::string &defVal); static int getInt(const std::string &key, int defVal); static bool getBool(const std::string &key, bool defVal); static float getFloat(const std::string &key, float defVal); [!Warning] 该接口是将数据以文件的形式保存在flash中， 所以请勿频繁写入，造成flash损坏。 该分区大小有限制，屏的型号不同，分区大小也不同。尽量将数据大小控制在512KB以内。 使用示例 保存 //保存字符串，以“username”为别名，值为name字符串 const char* name = \"zhang san\"; StoragePreferences::putString(\"username\", name); //保存布尔变量，以“power”为别名，值为true StoragePreferences::putBool(\"power\", true); //保存浮点数，以“temperature”为别名， 值为30.12 StoragePreferences::putFloat(\"temperature\", 30.12); //保存整型，以“age”为别名，值为20 StoragePreferences::putInt(\"age\", 20); 读取 //读取“username”这个键的值，如果没有值，返回空字符串 std::string name = StoragePreferences::getString(\"username\", \"\"); //日志打印读取到的字符串 LOGD(\"username %s\\n\", username.c_str()); //读取布尔变量，如果没有值，则指定返回false bool power = StoragePreferences::getBool(\"power\", false); //读取浮点数，如果没有值，则指定返回0 float temperature = StoragePreferences::getFloat(\"temperature\", 0); //读取整型，如果没有值，则指定返回18 int age = StoragePreferences::getInt(\"age\", 18); 删除//单独清空某一个值 StoragePreferences::remove(\"username\"); StoragePreferences::remove(\"power\"); StoragePreferences::remove(\"temperature\"); StoragePreferences::remove(\"age\"); //清空所有值 StoragePreferences::clear(); 修改如果需要修改某个值，只需要按键值重复保存即可，将自动覆盖旧的值 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"vireeprom.html":{"url":"vireeprom.html","title":"模拟EEPROM","keywords":"","body":"模拟EEPROM功能 EEPROM（带电可擦写可编程读写存储器）是用户可更改的只读存储器（ROM），其可通过高于普通电压的作用来擦除和重编程（重写）。 模拟原理 本系统基于Linux，自带文件系统，带均衡擦写算法。将保存的数据写入到 NorFlash（不低于10万次擦写次数，注意不是Nandfalsh，NandFlash 出现坏块后就是各种风险了）。 FlyThings OS内部预留了 /data 分区，用于用户数据，为了方便熟悉单片机操作的用户使用，我们在/data分区下创建一个文件来模拟一个EEPROM空间。 （/data分区的大小为1M或几百KB不等，依具体系统版本而定）是不是感觉特别像国内炼丹炉里面出来的STC大法的单片机。 使用场景 掉电保存数据。 实现步骤 首先在项目的 jni 目录下创建一个头文件。选中项目下的 jni ，点击鼠标右键，在弹出的上下文菜单中选择 头文件 选项, 然后命名为 vireeprom.h， 点击完成。 将以下代码完整拷贝到刚才添加的头文件中. (刚才创建头文件时，可能会自动添加一些内容，将这些内容删除)这些代码实现了EEPROM的模拟功能。 #ifndef JNI_VIREEPROM_H_ #define JNI_VIREEPROM_H_ #include #include #include /** * 模拟EEPROM的存储大小，字节为单位,建议不宜过大 */ #define EEPROM_SIZE 1024 /** * 实际保存为文件 /data/eeprom.eep */ #define EEPROM_FILE \"/data/eeprom.eep\" class VirEEPROM { public: VirEEPROM() { memset(buff_, 0, sizeof(buff_)); file_ = fopen(EEPROM_FILE, \"rb+\"); if (file_) { fread(buff_, 1, EEPROM_SIZE, file_); fseek(file_, 0, SEEK_END); int f_size = ftell(file_); //调整文件到合适大小 if (f_size != sizeof(buff_)) { ftruncate(fileno(file_), sizeof(buff_)); fseek(file_, 0, SEEK_SET); fwrite(buff_, 1, sizeof(buff_), file_); fflush(file_); sync(); } } else { file_ = fopen(EEPROM_FILE, \"wb+\"); //调整文件到合适大小 ftruncate(fileno(file_), sizeof(buff_)); } } virtual ~VirEEPROM() { if (file_) { fflush(file_); fclose(file_); sync(); } } /** * 返回值：小于0 是失败的，大于0是实际写入的字节数 * 参数：value需要保存的数据指针，可以是结构体指针，char*,int*……，size是要保存的数据大小 * 使用举例： * const char buff[]=\"12345678\"; * VIREEPROM->WriteEEPROM(0,buff,sizeof(buff); */ int Write(int addr, const void* value, int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //超出大小 return -2; } memcpy(buff_ + addr, value, size); if (0 != fseek(file_, addr, SEEK_SET)) { return -3; } int n = fwrite((char*)value, 1, size, file_); fflush(file_); sync(); return n; } /** * 返回值：小于0 是失败的，大于0是实际读取到的字节数 * 参数：value需要读取的数据指针，可以是结构体指针，char*,int*……，size是要读取的数据大小 * 应用举例： * char buff[9]; * VIREEPROM->ReadEEPROM(0,buff,sizeof(buff); */ int Read(int addr,void* value,int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //超出大小 return -2; } memcpy(value, buff_ + addr, size); return size; } /** * 返回值： * 0 成功 * 小于0 失败 */ int Erase() { if (file_ == NULL) { return -1; } if (0 != fseek(file_, 0, SEEK_SET)) { return -2; } memset(buff_, 0, sizeof(buff_)); if (sizeof(buff_) != fwrite(buff_, 1, sizeof(buff_), file_)) { return -3; } fflush(file_); sync(); return 0; } static VirEEPROM* getInstance() { static VirEEPROM singleton; return &singleton; } private: unsigned char buff_[EEPROM_SIZE]; FILE* file_; }; #define VIREEPROM VirEEPROM::getInstance() #endif /* JNI_VIREEPROM_H_ */ 至此准备工作已经完成，我们再写一些例子测试是否正常。打开 mainLogic.cc 源文件，先在文件顶部引用刚才的头文件。 #include \"vireeprom.h\" 测试代码 static void onUI_init(){ //把value数组，从地址0开始，依次写入 char value[4] = {1, 2, 3, 4}; VIREEPROM->Write(0, value, sizeof(value)); //从0地址开始读，依次读取4个字节 ，读取的内容保存到buf中 char buf[4] = {0}; VIREEPROM->Read(0, buf, sizeof(buf)); //输出日志 LOGD(\"读出的数据： %02x, %02x, %02x, %02x\", buf[0], buf[1], buf[2], buf[3]); //将eeprom全部清空为0 VIREEPROM->Erase(); } powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"brightness.html":{"url":"brightness.html","title":"屏幕背光操作 ","keywords":"","body":"屏幕背光操作 所需头文件 #include \"utils/BrightnessHelper.h\" 亮度调节 调节背光亮度亮度范围是 0 ~ 100 (注意：0并不等于关屏) //将屏幕亮度调整为80 BRIGHTNESSHELPER->setBrightness(80); 获取当前亮度值BRIGHTNESSHELPER->getBrightness(); 开关屏幕背光 关屏 BRIGHTNESSHELPER->screenOff(); 开屏 BRIGHTNESSHELPER->screenOn(); 记忆亮度 系统开机起来默认是记忆最后调节的亮度值，如果想要修改为不记忆亮度或设置固定的亮度值，可以打开工程的属性进行修改： powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"system_time.html":{"url":"system_time.html","title":"系统时间 ","keywords":"","body":"系统时间 所需头文件 #include \"utils/TimeHelper.h\" tm 结构体各字段解释 struct tm { int tm_sec; /* 秒–取值区间为[0,59] */ int tm_min; /* 分 - 取值区间为[0,59] */ int tm_hour; /* 时 - 取值区间为[0,23] */ int tm_mday; /* 一个月中的日期 - 取值区间为[1,31] */ int tm_mon; /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */ int tm_year; /* 年份，其值从1900开始 */ ... } 获取当前日期 struct tm *t = TimeHelper::getDateTime(); 显示时间代码样例 static void updateUI_time() { char timeStr[20]; static bool bflash = false; struct tm *t = TimeHelper::getDateTime(); sprintf(timeStr, \"%02d:%02d:%02d\", t->tm_hour,t->tm_min,t->tm_sec); mTextTimePtr->setText(timeStr); // 注意修改控件名称 sprintf(timeStr, \"%d年%02d月%02d日\", 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday); mTextDatePtr->setText(timeStr); // 注意修改控件名称 static const char *day[] = { \"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\" }; sprintf(timeStr, \"星期%s\", day[t->tm_wday]); mTextWeekPtr->setText(timeStr); // 注意修改控件名称 } 设置时间代码样例 // 利用tm 结构体设置时间 static void setSystemTime() { struct tm t; t.tm_year = 2017 - 1900; //年 t.tm_mon = 9 - 1; //月 t.tm_mday = 13; //日 t.tm_hour = 16; //时 t.tm_min = 0; //分 t.tm_sec = 0; //秒 TimeHelper::setDateTime(&t); } // 或者用字符串设置时间 date str format: 2017-09-13 16:00:00 TimeHelper::setDateTime(\"2017-09-13 16:00:00\"); 完整源码见样例代码包中的DateDemo工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"machine_unique_id.html":{"url":"machine_unique_id.html","title":"设备唯一ID ","keywords":"","body":"设备唯一ID码 如何读取 所需头文件#include \"security/SecurityManager.h\" 读取设备ID Z6、Z11、A33平台接口使用说明：// 设备 id 共8个字节 unsigned char devID[8]; // 成功返回 true，失败返回 false bool ret = SECURITYMANAGER->getDevID(devID); H500S、Z20、Z21平台接口使用说明：// 设备 id 最多16个字节 unsigned char devID[16]; // 返回 devID长度 int ret = SECURITYMANAGER->getDevID(devID); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"tf.html":{"url":"tf.html","title":"TF卡","keywords":"","body":"TF卡 当插入TF卡后，系统会自动挂载为 /mnt/extsd目录。如果想读写TF卡内的文件，可以对该目录进行读写操作。 文件路径 如果你的TF卡根目录内有一个 test.txt 文件，那么在我们的机器上，这个文件的绝对路径就是 /mnt/extsd/test.txt 。 写TF卡注意事项 向TF卡内写文件，尽量遵循以下操作顺序，不然可能会造成无法写入的情况。 插卡->上电->打开文件->读写文件->fflush()->关闭文件->sync()->拔卡 换言之，如果有写TF卡的需求，尽量保证在开机前就已经插好TF卡，而不是在已经开机状态下临时插入TF卡。 并且写完后，注意同步的问题。 判断是否挂载TF卡 #include \"os/MountMonitor.h\" if (MOUNTMONITOR->isMount()) { //TF卡已经挂载 } else { //TF卡未挂载 } [!Note] /mnt/extsd 目录一直存在，与是否插入TF卡无关没有插入TF卡的情况下，如果读写该目录，内容会保存在内存中，但断电就会消失。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"mount.html":{"url":"mount.html","title":"插拔卡监听","keywords":"","body":"TF卡拔插监听 通过注册监听接口，我们可以知道TF卡的拔插状态；这里我们首先需要实现自己的监听类： #include \"os/MountMonitor.h\" class MyMountListener : public MountMonitor::IMountListener { public: virtual void notify(int what, int status, const char *msg) { switch (status) { case MountMonitor::E_MOUNT_STATUS_MOUNTED: // 插入 // msg 为挂载路径 LOGD(\"mount path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF卡已插入\"); break; case MountMonitor::E_MOUNT_STATUS_REMOVE: // 移除 // msg 为卸载路径 LOGD(\"remove path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF卡已移除\"); break; } } }; 定义监听对象： static MyMountListener sMyMountListener; 注册监听： MOUNTMONITOR->addMountListener(&sMyMountListener); 当我们不再需要监听时，需要移除监听： MOUNTMONITOR->removeMountListener(&sMyMountListener); 具体操作参考样例代码中的MountDemo项目 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"gpio.html":{"url":"gpio.html","title":"GPIO操作 ","keywords":"","body":"GPIO操作 [!Note] 如果是购买的SV50PB模组或者SV50PC模组，使用前，需要在模组配置中使能 GPIO 功能，再重新升级系统,才能正常使用。 更多有关模组的使用教程。 引入头文件 #include \"utils/GpioHelper.h\" 操作函数 class GpioHelper { public: /** * 将脚位设置为输入模式，并返回脚位的高低状态 * @param pPin 脚位名 * @return -1 操作失败 * 1 高电平 * 0 低电平 */ static int input(const char *pPin); /** * 将脚位设置为输出模式, 并指定输出高电平或者低电平 * @param pPin 脚位名 * @param val 1 高电平 * 0 低电平 * @return -1 失败 * 0 成功 */ static int output(const char *pPin, int val); }; 各个平台可操作脚位名称定义 Z11S平台 目前该平台只保留了3组io口可以操作。 // 3组io口定义 #define GPIO_PIN_B_02 \"B_02\" #define GPIO_PIN_B_03 \"B_03\" #define GPIO_PIN_E_20 \"E_20\" #include \"utils/GpioHelper.h\" // 读B02 io口状态 GpioHelper::input(GPIO_PIN_B_02); // B02 io口输出高电平 GpioHelper::output(GPIO_PIN_B_02, 1); SV50PB模组 有以下12组io口可以操作： // SV50PB #define SV50PB_PIN7 \"PIN7\" #define SV50PB_PIN8 \"PIN8\" #define SV50PB_PIN9 \"PIN9\" #define SV50PB_PIN10 \"PIN10\" #define SV50PB_PIN11 \"PIN11\" #define SV50PB_PIN12 \"PIN12\" #define SV50PB_PIN13 \"PIN13\" #define SV50PB_PIN14 \"PIN14\" #define SV50PB_PIN23 \"PIN23\" #define SV50PB_PIN24 \"PIN24\" #define SV50PB_PIN26 \"PIN26\" #define SV50PB_PIN27 \"PIN27\" #include \"utils/GpioHelper.h\" // 读PIN7 io口状态 GpioHelper::input(SV50PB_PIN7); // PIN7 io口输出高电平 GpioHelper::output(SV50PB_PIN7, 1); SV50PC模组 有以下25组io口可以操作： // SV50PC #define SV50PC_PIN2 \"PIN2\" #define SV50PC_PIN3 \"PIN3\" #define SV50PC_PIN4 \"PIN4\" #define SV50PC_PIN5 \"PIN5\" #define SV50PC_PIN6 \"PIN6\" #define SV50PC_PIN7 \"PIN7\" #define SV50PC_PIN8 \"PIN8\" #define SV50PC_PIN9 \"PIN9\" #define SV50PC_PIN10 \"PIN10\" #define SV50PC_PIN11 \"PIN11\" #define SV50PC_PIN13 \"PIN13\" #define SV50PC_PIN14 \"PIN14\" #define SV50PC_PIN15 \"PIN15\" #define SV50PC_PIN16 \"PIN16\" #define SV50PC_PIN17 \"PIN17\" #define SV50PC_PIN18 \"PIN18\" #define SV50PC_PIN22 \"PIN22\" #define SV50PC_PIN24 \"PIN24\" #define SV50PC_PIN25 \"PIN25\" #define SV50PC_PIN26 \"PIN26\" #define SV50PC_PIN27 \"PIN27\" #define SV50PC_PIN28 \"PIN28\" #define SV50PC_PIN29 \"PIN29\" #define SV50PC_PIN30 \"PIN30\" #define SV50PC_PIN31 \"PIN31\" #include \"utils/GpioHelper.h\" // 读PIN7 io口状态 GpioHelper::input(SV50PC_PIN7); // PIN7 io口输出高电平 GpioHelper::output(SV50PC_PIN7, 1); 86盒子 有以下4组io口可以操作： // 86 Box #define Z6X86BOX_PIN7 \"PIN7\" // 对应硬件上IO1 #define Z6X86BOX_PIN8 \"PIN8\" // IO2 #define Z6X86BOX_PIN9 \"PIN9\" // IO3 #define Z6X86BOX_PIN10 \"PIN10\" // IO4 #include \"utils/GpioHelper.h\" // 读PIN7 io口状态 GpioHelper::input(Z6X86BOX_PIN7); // PIN7 io口输出高电平 GpioHelper::output(Z6X86BOX_PIN7, 1); 样例 完整源码见样例代码包中的GpioDemo项目 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"spi.html":{"url":"spi.html","title":"SPI操作 ","keywords":"","body":"SPI操作 [!Note] 目前仅SV50PB模组支持该功能。 使用前，需要在模组配置中使能 SPI 功能，用生成的新系统包升级，才能正常使用。 更多有关模组的使用教程。 引入头文件 #include \"utils/SpiHelper.h\" 具体操作 // 所需头文件 #include \"utils/SpiHelper.h\" static void testSpi() { uint8_t tx[512], rx[512]; /** * 定义变量 * * 参数1： spi总线号 * 参数2： 模式，可选值： SPI_MODE_0、SPI_MODE_1、SPI_MODE_2、SPI_MODE_3 * 参数3： spi时钟频率，这里设置了50M * 参数4： 一个字有多少位，默认值： 8 * 参数5： 位顺序，true： 表示低位在前，false： 表示高位在前； 默认值： false，高位在前 */ SpiHelper spi(1, SPI_MODE_0, 50*1000*1000, 8, false); memset(tx, 0, 512); memset(rx, 0, 512); tx[0] = 0x4B; /** * 单工写 * * 参数1： 写数据地址 * 参数2： 数据长度 */ if (!spi.write(tx, 5)) { LOGD(\"spi tx error!\\n\"); } /** * 单工读 * * 参数1： 读数据地址 * 参数2： 数据长度 */ if (!spi.read(rx, 8)) { LOGD(\"spi rx error!\\n\"); } for (int i = 0; i 其他接口操作请参见头文件注释说明。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"i2c.html":{"url":"i2c.html","title":"I2C操作 ","keywords":"","body":"I2C操作 [!Note] 目前仅SV50P系列模组支持该功能。 使用前，需要在模组配置中使能 TWI 功能，用生成的新系统包升级，才能正常使用。 更多有关模组的使用教程。 引入头文件 #include \"utils/I2CHelper.h\" 具体操作 #include \"utils/I2CHelper.h\" #define CFG_L 0x47 #define CFG_H 0x80 #define VER_L 0x41 #define VER_H 0x81 static void testI2C() { uint8_t tx[512], rx[512]; memset(tx, 0, 512); memset(rx, 0, 512); /** * 定义变量 * * 参数1： i2c总线号 * 参数2： 从机地址, 一定要注意是 7bit地址 * 参数3： 超时时间，单位: ms * 参数4： 重试次数 */ I2CHelper i2c(0, 0x5e, 1000, 5); tx[0] = CFG_H; tx[1] = CFG_L; /** * 单工写 * * 参数1： 写数据地址 * 参数2： 数据长度 */ if (!i2c.write(tx, 2)) { LOGD(\"i2c tx cfg error!\\n\"); } /** * 单工读 * * 参数1： 读数据地址 * 参数2： 数据长度 */ if (!i2c.read(rx, 1)) { LOGD(\"i2c rx cfg error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", CFG_H, CFG_L, rx[0]); memset(rx, 0, 512); /** * 半双工传输，即共用读写，中间无stop信号 * * 参数1： 写数据地址 * 参数2： 写数据长度 * 参数3： 读数据地址 * 参数4： 读数据长度 */ if (!i2c.transfer(tx, 2, rx, 1)) { LOGD(\"i2c i2c_transfer cfg error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", CFG_H, CFG_L, rx[0]); tx[0] = VER_H; tx[1] = VER_L; if (!i2c.write(tx, 2)) { LOGD(\"i2c tx ver error!\\n\"); } if (!i2c.read(rx, 1)) { LOGD(\"i2c rx ver error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", VER_H, VER_L, rx[0]); memset(rx, 0, 512); if (!i2c.transfer(tx, 2, rx, 1)) { LOGD(\"twi i2c_transfer ver error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", VER_H, VER_L, rx[0]); } 其他接口操作请参见头文件注释说明。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"adc.html":{"url":"adc.html","title":"ADC操作 ","keywords":"","body":"ADC操作 [!Note] 目前仅SV50P系列模组支持该功能。 使用前，需要在模组配置中使能 ADC 功能，用生成的新系统包升级，才能正常使用。 更多有关模组的使用教程。 引入头文件 #include \"utils/AdcHelper.h\" 具体操作 #include \"utils/AdcHelper.h\" static void testAdc() { /** * 设置adc使能状态 * * @param true 使能 * false 禁止 * 默认是使能状态 */ AdcHelper::setEnable(true); for (int i = 0; i powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"reboot.html":{"url":"reboot.html","title":"重启系统","keywords":"","body":"重启系统 可通过如下代码，主动让系统机器重启。 需要的头文件 #include #include 代码 //同步数据，将缓存数据保存，以防数据丢失 sync(); reboot(RB_AUTOBOOT); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"i18n.html":{"url":"i18n.html","title":"多国语言翻译","keywords":"","body":"多国语言翻译 FlyThings 提供了多国语言翻译的功能，方便国际化。 如何添加翻译 首先通过新建向导，创建翻译文件。 创建完毕后，项目下会生成一个名为 i18n 的子文件夹，并且添加了默认的tr翻译文件。每个tr文件的文件名代表相应的语言 (请勿随意修改文件名)。 双击打开tr文件，可以看出该内容为xml格式。每一个string标签表示一条翻译。name 属性用于给这条翻译取别名（建议统一为英文、数字、下划线组合命名），之后在代码中用别名代表该字符串。 注意：同一配置文件内，别名不能重复。 你好,世界! 你好, FlyThings 如果希望在字符串中换行，则用&#x000A;转义，如下： 第一行&#x000A;第二行 如上所示，我们将 “你好,世界!” 这个字符串取别名为 hello_world、将 你好, FlyThings 这个字符串取别名为 hello_flythings，如果我们要添加更多的翻译，我们只需要按照示例添加string标签即可。 既然是多国语言的翻译，我们就要为每个语言都添加相同 name 的标签。这样，当我们切换语言时，系统就会根据 name 属性，将内容替换。 配置文件添加完毕后，我们就可以在ui文件以及代码中使用。 打开ui文件，我们可以在文本属性里输入 @hello_world (我们用@符号后面跟上配置文件中的别名，来表示这个字符串需要翻译)。然后，我们下载运行，可以看到文本的内容已经自动翻译为 你好，世界！ 我们还可以在代码中对字符串进行翻译。以前我们设置字符串是用 setText() 这个成员方法，如果我们需要自动翻译，则需要使用 setTextTr() 成员方法。 例如: /** * 当界面构造时触发 */ static void onUI_init() { // setTextTr 参数为翻译配置文件中的name值，注意：这里传入的字符串前面不需要带@符号 mTextview1Ptr->setTextTr(\"hello_world\"); } 下载运行，我们可以看到内容已经替换为对应的字符串。 我们还可以获取当前语言name对应的value值，然后做一些类似拼接的操作等等: #include \"manager/LanguageManager.h\" static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); std::string hello = LANGUAGEMANAGER->getValue(\"hello\"); std::string world = LANGUAGEMANAGER->getValue(\"world\"); std::string ret = hello + \" \" + world; LOGD(\"ret: %s\\n\", ret.c_str()); return false; } 支持更多的语言 默认只提供了四种语言（简体中文、英文、日文、韩文）。如果你需要支持更多的语言，可按照如下要求添加。 拷贝现有的.tr文件，将文件名修改为 xx_XX-XXX.tr 格式，该格式分为三部分，第一个部分是语言代号，由两个小写字母组成；第二个部分是地区代号，由两个大写字母组成；第三部分是语言的名字，这个名字将直接显示语言切换列表中。如果不了解语言代号及地区代号，可以取任意字母组合，保证多个tr文件名的第一部分和第二部分不冲突即可。 例子：es_ES-西班牙语.trfr_FR-法语.trru_RU-俄语.traa_BB-语言名称.tr 添加tr文件后，按照之前的规则编辑tr文件即可。 如何切换语言 系统默认的语言为 zh_CN （中文简体）。 你可以打开系统内置切换语言的界面选择语言。添加如下代码打开该界面。 EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); 或者使用如下API自由切换语言。 EASYUICONTEXT->updateLocalesCode(\"zh_CN\"); //设置为中文 EASYUICONTEXT->updateLocalesCode(\"en_US\"); //设置为英文 EASYUICONTEXT->updateLocalesCode(\"ja_JP\"); //设置为日语 字体要求 多语言翻译需要字体的支持。如果字体中不存在该文字，则会显示不正常，所以，字体中一定要包含多国语言的文字。 系统默认字体是精简版本，建议添加自定义字体，参见字体裁剪。 样例 完整源码见样例代码包中的TranslationDemo工程 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"adb_debug.html":{"url":"adb_debug.html","title":"ADB调试 ","keywords":"","body":"ADB 快速下载调试 FlyThings 可以通过 USB线 或者WIFI 快速下载程序到机器中。具体步骤如下： 首先确保电脑与机器成功连接，连接方式有两种： [!Note] 注意： 如果您购买的是带有WIFI功能的版本，那么只能通过WIFI连接，USB线不能使用； 以太网版本优先使用USB线连接，如果USB连接不成功才使用WIFI连接（即网络连接）方式，如果都不能成功连接请联系我们。 同理，如果您购买的是不带WIFI功能的版本，那么只能通过USB线连接。 USB线连接成功可以看到 使用USB线连接电脑与机器。如果电脑能将机器识别为Android设备，表示连接正常。 如果不能正常连接，电脑提示驱动问题，可尝试下载更新驱动。 通过WIFI方式连接。（这种方式需要机器支持WIFI功能。）先进入机器的WIFI设置界面，将机器连接到与电脑相同的网络，也就是说，电脑和机器必须接入同一个WIFI。（如果不同的网络会导致后续下载程序失败）。网络连接成功后，点击WIFI设置界面右上角菜单按钮查看机器的IP地址，然后，打开FlyThings IDE开发工具，在菜单栏上，依次选择菜单 调试配置 -> ADB IP配置， 将机器IP填入，选择确定。工具将尝试与机器连接，如果提示连接成功，则表示正常。如果提示失败，则需要检查IP是否正确？机器连接WIFI是否正常？ WIFI设置界面 操作过程动画 下载调试 完成上一步后，就可以直接下载程序了。在项目资源管理器中，选中项目名，右键，在弹出菜单中选择 下载调试 菜单， 选择后，它会先自动编译一次，编译成功后，再将程序下载到机器中，如果没有提示错误，那么你就可以看到机器程序已经得到了更新。同样，在选中项目后，你还可以使用快捷键 Ctrl + Alt + R 下载调试。 查看打印日志 注意事项 如果电脑上连接有Android手机，可能会与机器造成冲突，导致下载失败。使用时，建议暂时断开Android手机连接。 注意 ： 通过该方式运行程序，并不能将程序固化到机器中，如果您拔掉TF卡或者断电重启，程序将自动恢复。 如果您希望固化程序到设备中，可以选择制作升级镜像，然后升级即可。 在命令行下使用ADB 我们可以通过ADB命令，快速查看设备的状态、日志等。首先任意选中一个项目，然后找到顶部的菜单栏，依次选择 调试配置 -> 打开系统命令行， 现在我们就可以在弹出的命令行中，输入想要执行的命令，再按回车健执行命令。下面介绍一些常用的命令。 adb logcat -v time powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"logcat.html":{"url":"logcat.html","title":"查看打印日志 ","keywords":"","body":"查看日志 添加日志 所需头文件 #include \"utils/Log.h\" FlyThings 的打印统一调用 LOGD 或 LOGE 宏输出，使用方法与C语言的printf相同 ; 默认生成的代码里就有调用的例子（默认被注释掉，需要时打开）： static bool onButtonClick_Button1(ZKButton *pButton) { LOGD(\"onButtonClick_Button1\\n\"); return true; } 查看打印日志 命令行的方式查看（推荐） 找到软件的顶部菜单， 依次打开菜单 调试配置->打开系统命令行 如果你是采用USB线与设备连接， 直接在命令行中输入 adb shell logcat -v time 再输入回车键，如果电脑与设备连接正常，将看到设备的所有日志信息。如果你是采用的网络连接，例如WIFI、以太网， 那就得先查看设备，得到设备的IP地址，再在命令行里输入 adb connect 192.168.1.123 （此处自行更换IP地址），再输入回车键，如果IP正确，正常连接，将看到这样的信息： connected to 192.168.1.123:5555 ，正常连接后，再输入 adb shell logcat -v time ，再输入回车键，就可以看到所有的日志信息了。 可以通过 Ctrl + C组合键停止日志显示。 UI界面的方式查看 (弃用) 连接好 ADB 后，可以通过我们的工具查看程序的打印日志。 具体操作步骤如下： 在菜单栏上 选择 调试配置 -> 切换日志窗口 ，工具会切换到另一个界面。 在新界面的左下角，选中 LogCat , 如果连接正常，在右侧红框区域，你将看到机器的打印日志。 如果你想回到代码编辑界面， 在工具的右上角，点击 FlyThings的图标即可。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"start_from_sdcard.html":{"url":"start_from_sdcard.html","title":"从TF卡启动程序 ","keywords":"","body":"从TF卡启动程序 当我们不能使用ADB下载程序时，还可以将程序下载到TF卡里，从TF卡来启动程序。 [!Note] 注意：TF卡仅支持FAT32格式 操作具体步骤 首先我们要配置程序的输出目录。 找到工具栏上的这个按钮 点击旁边的黑色下拉箭头，在弹出的菜单中选择 路径配置 在弹出框中，选择TF卡的盘符(请确保TF卡能正常使用），点击确定 。 在上面的步骤中，我们配置好了输出目录，现在点击下图中的按钮开始编译，它会将编译结果 打包输出到配置的盘符下。 操作成功后， 将在配置的盘符下 生成 EasyUI.cfg 、ui、lib、 font 等目录和文件。 将TF卡拔出，插入机器中，将机器重新上电，这时候，系统检测到TF卡里的文件，就会启动卡里的程序，而不是系统内的程序。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"update_logo.html":{"url":"update_logo.html","title":"升级开机LOGO ","keywords":"","body":"开机LOGO 更新开机LOGO 首先准备一张开机LOGO图片，图片必须满足以下条件： 图片名称固定为 boot_logo.JPG，注意，文件后缀是大写的 JPG； 其他名称将无法识别。Windows系统电脑的用户务必打开资源管理器的“显示扩展名”功能，确保完整的文件名称正确无误。 图片分辨率必须与屏幕分辨率完全相同，以像素为单位。 图片不宜过大，否则升级失败。最好保持在100KB以内，但是不同的系统版本所支持的大小也有差异。由于系统开机时，支持的压缩算法有限，在电脑上显示的大小并不代表系统内解压、再压缩后的占用大小。 升级时，如果提示“镜像大于分区大小”，说明图片对于该系统版本来说，仍然过大。 开机LOGO图片应尽量简单，强烈推荐以纯色为背景，再加上简单的图标或文字，这样能有效减小图片大小。； 将 boot_logo.JPG 拷贝到TF卡根目录下 将TF卡插入到机器中，然后设备会自动弹出升级提示。选择boot_logo 然后点击升级即可。 升级完成后系统会关机重启。此时拔出TF卡。防止系统再次升级。 更加丰富的“开机LOGO” 开机LOGO的功能有限，如果您有更加丰富的需求，可以采用如下方式曲折实现 用一张纯黑色的图片升级为开机LOGO。 应用程序的第一个界面视为你的”开机LOGO” 应用程序的第一个界面尽量不要有耗时操作，否则会拖慢程序的启动时间。 延长开机LOGO的显示时间 开机LOGO的时间依赖应用程序的启动时间。 应用程序的第一个界面完整加载后，就会覆盖开机LOGO。 所以只要在第一个界面的 onUI_init 函数里加上sleep操作，即可变相延长开机LOGO的显示时间。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"make_image.html":{"url":"make_image.html","title":"制作升级镜像文件 ","keywords":"","body":"制作升级镜像文件 在之前的教程中，我们通过下载调试菜单运行程序，但是它并不能将程序固化到设备中，如果您拔掉TF卡或者断电重启，程序将自动恢复。 如果您希望固化程序到设备中，我们可以将程序打包制作成升级文件，设备升级后，就可以将程序固化在设备内部，一上电，默认就会启动该程序。 操作具体步骤 首先我们要配置镜像的输出目录。 找到工具栏上的这个按钮 点击旁边的黑色下拉箭头，在弹出的菜单中选择 路径配置 在弹出框中，选择镜像文件的输出目录，点击确定 。 在上面的步骤中，我们配置好了输出目录，现在点击下图中的按钮开始编译，它会将编译结果 打包，并生成 update.img 文件输出到配置的目录下。 update.img 文件成功生成后，将其拷贝到TF卡里(注意：使用前，请将TF卡格式化为FAT32格式)，将TF卡插入机器中，机器重新上电，这时候，系统检测到TF卡里的文件，就会启动升级程序，在下图的界面中，勾选升级的项目，点击升级。升级完成后及时拔掉升级卡，防止重复升级。 [!NOTE] 注意：TF卡仅支持FAT32格式 如果屏幕损坏或触摸不准情况下，导致不能通过点击按钮进行升级，那么这种情况下，我们可以通过自动升级这种方式来升级我们的系统。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"autoupgrade.html":{"url":"autoupgrade.html","title":"自动升级","keywords":"","body":"插卡自动升级 在屏幕损坏或触摸不准情况下，想要对系统进行升级，我们可以在TF卡根目录下创建一个文件 zkautoupgrade （注意：该文件是没有后缀名的） 这样机器插卡后会自动勾选上升级项，默认2s后开始升级；如果需要控制其他时间后才开始升级，我们可以打开zkautoupgrade文件填相应的数字即可，单位为秒；升级完成后，系统重启，记得要拔出TF卡，防止再次自动升级。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"sd_boot.html":{"url":"sd_boot.html","title":"制作刷机卡 ","keywords":"","body":"制作刷机卡 [!Warning] 注意： TF卡的容量最大支持16G，过大机器无法识别TF卡，无法升级。最新软件刷机包，请到 QQ群：371608200 群共享下载，注意找自己机器对应版本的软件，见机器背面标签，否则升级可能会造成异常！ 下载电脑端刷机工具 选择电脑上的TF卡盘符 指定升级的镜像文件 点击烧录 烧写成功后，拔出TF卡，插入机器，再重新上电，即可进行升级 [!Warning] 注意：升级进度条完成后，需要及时拔出TF卡，防止机器重启后反复升级 恢复卡步骤 选择电脑上的TF卡盘符 点击 恢复卡 格式化完成后，则卡恢复正常使用 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"remote_update.html":{"url":"remote_update.html","title":"远程升级","keywords":"","body":"远程升级 目前系统没有直接进行远程升级的接口。但是我们可以了解TF卡检测升级的机制后，再添加上一些自己的代码，即可达到远程升级的目的。我们先介绍一般插TF卡升级的流程。 TF卡检测升级流程 当系统启动或者插入TF卡的时候，如果TF卡正常挂载，系统会检测TF卡根目录下是否存在 update.img 文件 (系统内，TF卡根目录映射为 /mnt/extsd)。如果存在，进一步校验文件是否符合要求，如果通过校验，然后弹出升级提示界面，用户可以选择进行升级。如果不存在，结束检测流程，界面无任何动作。 实现步骤 首先我们要下载升级镜像 update.img。一般情况下，通过HTTP协议下载文件是最简单的方式，当然，也可以根据实际情况选择其他协议。下载后，将镜像文件保存到TF卡目录/mnt/extsd/ 下。 [!Note] 如果机器内没有插TF卡，这个目录仍然可以写入，因为它是保存在内存中的。 受限于内存大小，如果镜像文件过大，会造成设备运行异常、或者升级失败。如果有插入TF卡，可以忽略内存大小的问题。 调用升级检测函数先下载 UpgradeMonitor.h 源文件，保存到项目的 jni/include/os 目录下。 然后调用接口检测升级。 #include \"os/UpgradeMonitor.h\" //主动检测 /mnt/extsd目录下是否有正确的update.img文件， //如果有，则弹出升级提示框， //如果没有，则无任何动作 UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd\"); 弹出升级提示界面后，用户可以选择是否升级。至此，已完全实现远程升级功能。 下载文件后自动更新 如果希望下载升级文件后，强制更新，那么只需要参考自动升级文档，用代码创建 zkautoupgrade文件即可。 避免反复升级 在上面的步骤中，我们将镜像文件保存在 /mnt/extsd/目录下，成功升级后，机器会自动重启，这时，系统会执行常规的升级检测流程，由于镜像文件的存在，升级提示界面再一次弹出，导致了重复升级。 解决方法 下载镜像文件时，将它保存到非 /mnt/extsd/ 目录， 例如： /mnt/extsd/temp/ ， 并且，也同步修改调用检测函数的参数。 UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); 样例参考 完整样例下载样例中简单实现了http客户端下载文件，参考源码http部分。 下载文件属于耗时操作，推荐放到独立线程中，这样才不会影响界面的即时响应。 关键代码 class DownloadThread : public Thread { protected: virtual bool threadLoop(){ http::HttpClient http; mTextview1Ptr->setText(\"下载升级文件\"); //创建升级文件的保存路径 system(\"mkdir /mnt/extsd/temp\"); //这里修改为真实服务IP string err = http.Download(\"192.168.1.1/update.img\", 80, \"/mnt/extsd/temp/update.img\"); mTextview1Ptr->setText(err); if (err.empty()) { UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); } mButton1Ptr->setInvalid(false); return false; }; }; 服务端实现为了方便测试，例程中包含了一个 http.exe，它是一个静态文件服务。 将制作好的升级镜像文件 update.img 和 http.exe 放到同一文件夹下，然后在电脑上双击执行 http.exe，只要网络正常，即可 通过网址下载同目录下的镜像文件。例如：http://192.168.1.1/update.img(请注意将IP地址修改为电脑当前IP) 服务端开启后，再运行样例代码，即可测试远程升级。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"demo_download.html":{"url":"demo_download.html","title":"代码样例","keywords":"","body":"样例下载 [!Note] 请优先下载与屏对应平台的样例代码，如果确实没有,可任意下载一份,再参考转换项目平台自行转换 Z6S或z6平台 480x272 控件样例 480x854 控件样例 800x480 控件样例 1024x600 控件样例 第三方库移植代码样例(Modbus、Sqlite、CURL HTTP、Mqtt) 场景应用样例(日历、表格、文件浏览器) Z11S平台 480x272 控件样例 480x854 控件样例 800x480 控件样例 1024x600 控件样例 第三方库移植代码样例(Modbus、Sqlite、CURL HTTP、Mqtt) 场景应用样例(日历、表格、文件浏览器) A33NOR平台 480x272 控件样例 480x854 控件样例 800x480 控件样例 1024x600 控件样例 第三方库移植代码样例(Modbus、Sqlite、CURL HTTP、Mqtt) 场景应用样例(日历、表格、文件浏览器) H500S平台 480x272 控件样例 480x854 控件样例 800x480 控件样例 1024x600 控件样例 第三方库移植代码样例(Modbus、Sqlite、CURL HTTP、Mqtt) Z21平台 480x272 控件样例 480x854 控件样例 800x480 控件样例 1024x600 控件样例 第三方库移植代码样例(Modbus、Sqlite、CURL HTTP、Mqtt) 出厂样例代码 代码样例 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"file_read_write.html":{"url":"file_read_write.html","title":"文件读写","keywords":"","body":"文件读写 如果你熟悉标准C语言的文件读写，可以按照标准C语言的方式读写文件。 针对一些常用的文件读写操作，我们基于C语言文件读写接口做了简单的封装，方便使用。 如果需要，可以按步骤，将源码集成到自己的项目中。 /** * 写文件，如果文件存在，将会覆盖，如果文件不存在，则新建文件，再写入内容 * 成功返回true */ bool WriteFile(const char* filename, const void* data, int len); /** * 在文件末尾追加内容,如果文件不存在，则先新建文件，再写入内容 * 成功返回true */ bool AppendFile(const char* filename, const void* data, int len); /** * 读文件 * 成功，将文件以二进制的形式保存在string的data中，以 string.data()读取二进制内容 * 失败返回空串 */ string ReadFile(const char* filename); 移植步骤 在项目的jni文件夹下新建一个文件夹，命名为 io 下载 ioutil.h 、ioutil.cpp 两个文件，保存到io文件夹下。 如何使用 引入头文件 #include \"io/ioutil.h\" 写文件 //将“0123456789”这个字符串写入到123.txt这个文件中 const char* filename = \"/mnt/extsd/123.txt\"; //文件保存的路径 const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); 追加文件 //将内容追加到文件的末尾，如果指定的文件不存在，则新建文件。 const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); 读文件 const char* filename = \"/mnt/extsd/123.txt\"; //读取文件的所有内容，保存在content中 string content = ioutil::ReadFile(filename); //将读到的每一个字节以16进制输出到日志 for (size_t i = 0 ; i [!Warning] ioutil::ReadFile函数是将文件的所有内容读取到内存里，如果指定的文件过大，会导致内存不够，可能会造成异常。 连续写文件 ，适用于写大文件的情况 const char* filename = \"/mnt/extsd/123.txt\"; const char* append_str = \"abcdefgh\"; ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i 连续读，适用于处理大文件的情况 const char* filename = \"/mnt/extsd/123.txt\"; ioutil::Reader r; if (r.Open(filename)) { char buf[1024] = {0}; while (true) { int n = r.Read(buf, sizeof(buf)); if (n > 0) { //有读到内容,输出每一个字节 for (int i = 0; i 测试代码 /** * 当界面构造时触发 */ static void onUI_init() { //写文件 const char* filename = \"/mnt/extsd/123.txt\"; const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); string content = ioutil::ReadFile(filename); LOGD(\"读取字节数%d, 内容:%s\", content.size(), content.c_str()); //追加文件 const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); content = ioutil::ReadFile(filename); LOGD(\"读取字节数%d, 内容:%s\", content.size(), content.c_str()); ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i 0) { //有读到内容,输出每一个字节 for (int i = 0; i powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"net.html":{"url":"net.html","title":"Socket编程","keywords":"","body":"socket网络编程 如果你熟悉Linux的socket编程，可以根据标准Linux socket编程接口进行网络编程。 针对一些常用的socket编程实现操作，例如，建立TCP客户端，我们基于Linux 的标准接口做了简单的封装，方便使用。 如果需要，可以按步骤，将源码集成到自己的项目中。 移植步骤 在项目的jni文件夹下新建一个文件夹，命名为 net 下载 net.h 、net.cpp 两个文件，保存到net文件夹下。 如何使用 TCP客户端 引入头文件 #include \"net/net.h\" 使用例子 //以tcp协议连接 www.baidu.com这个域名的80端口，域名改为IP也行 net::Conn* conn = net::Dial(\"tcp\", \"www.baidu.com:80\"); //net::Conn* conn = net::Dial(\"tcp\", \"14.215.177.38:80\"); if (conn) { byte buf[2048] = {0}; const char* req = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"; //发送 conn->Write((byte*)req, strlen(req)); while (true) { //读取，超时1000毫秒 int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"读取 %d字节： %s\", n, buf); } else if (n == 0) { LOGD(\"连接正常断开\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"读取超时\"); } else { LOGD(\"出错\"); break; } } //关闭连接 conn->Close(); //释放内存 delete conn; conn = NULL; } UDP客户端 引入头文件 #include \"net/net.h\" 使用例子//使用以udp协议连接IP:192.168.1.100 的8080端口 net::Conn* conn = net::Dial(\"udp\", \"192.168.1.100:8080\"); if (conn) { byte buf[2048] = {0}; const char* req = \"hello\"; conn->Write((byte*)req, strlen(req)); while (true) { //读取，超时1000毫秒 int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"读取 %d字节： %s\", n, buf); } else if (n == 0) { LOGD(\"连接正常断开\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"读取超时\"); //这里设置超时就退出 break; } else { LOGD(\"出错\"); break; } } //关闭连接 conn->Close(); //释放内存 delete conn; conn = NULL; } powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"http.html":{"url":"http.html","title":"HTTP","keywords":"","body":"HTTP 如果你需要实现HTTP Get、POST 请求，libcurl 是一个很好的选择，它是一个C语言开源库。为了方便使用，我们已经编译了该库。直接下载样例代码的第三方移植代码样例中的CURLDemo项目。 [!Note] 一定要下载与屏平台对应的版本，否则无法运行。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"transcoding.html":{"url":"transcoding.html","title":"编码转换","keywords":"","body":"UTF-8编码 目前系统内仅支持UTF-8编码，例如文本框等控件，也只能正常显示UTF-8编码的字符串。如果要正常显示其他的编码，需要自行转码。 sconv sconv是一个转码的开源库，我们借助它来进行utf-8和gbk之间编码的转换。 准备 下载sconv源文件，并将它解压到我们项目 jni文件夹下。 UTF-8 转 GBK 引用头文件 #include #include \"utf8cover/sconv.h\" 添加函数 string utf8_to_gbk(const char* utf8_str) { int size = sconv_utf8_to_unicode(utf8_str, -1, NULL, 0); wchar *unicode = new wchar[size / 2 + 1]; size = sconv_utf8_to_unicode(utf8_str, -1, unicode, size); unicode[size / 2] = 0; size = sconv_unicode_to_gbk(unicode, -1, NULL, 0); char *ansi_str = new char[size + 1]; size = sconv_unicode_to_gbk(unicode, -1, ansi_str, size); ansi_str[size] = 0; string gbk(ansi_str, size); delete[] ansi_str; delete[] unicode; return gbk; } 使用刚才的函数进行编码转换，例子如下：const char* utf8_str = \"这是utf8编码\"; string gbk = utf8_to_gbk(utf8_str); LOGD(\"转换后，共%d字节\", gbk.size()); for (size_t i = 0; i GBK 转 UTF-8 引用头文件 #include #include \"utf8cover/sconv.h\" 添加函数 string gbk_to_utf8(const char* gbk_str) { int size = sconv_gbk_to_unicode(gbk_str, -1, NULL, 0); wchar *unicode_str = new wchar[size / 2 + 1]; size = sconv_gbk_to_unicode(gbk_str, -1, unicode_str, size); unicode_str[size / 2] = 0; size = sconv_unicode_to_utf8(unicode_str, -1, NULL, 0); char *utf8_str = new char[size + 1]; size = sconv_unicode_to_utf8(unicode_str, -1, utf8_str, size); utf8_str[size] = 0; string utf8(utf8_str, size); delete[] unicode_str; delete[] utf8_str; return utf8; } 使用刚才的函数进行编码转换，例子如下：//方便测试，这里构造一个gbk编码数组， 其内容为“这是gbk编码” const char gbk_str[] = {0xd5, 0xe2, 0xca, 0xc7, 0x67, 0x62, 0x6b, 0xb1, 0xe0, 0xc2, 0xeb,0}; string utf8 = gbk_to_utf8(gbk_str); LOGD(\"转换后，共%d字节\", utf8.size()); LOGD(\"内容是：%s\", utf8.c_str()); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"json.html":{"url":"json.html","title":"JSON","keywords":"","body":"JSON的构造与解析 默认项目的已经包含开源cppjson库，可直接使用。 使用步骤 引用头文件 #include \"json/json.h\" 构造JSON字符串 Json::Value root; //添加整型值 root[\"int\"] = 1; //添加字符串 root[\"str\"] = \"hello\"; //由于浮点数存在精度打印问题，不推荐使用，尽量转为整型 root[\"float\"] = 3.14f; //添加数组 Json::Value array; array.append(\"123\"); array.append(\"456\"); array.append(\"789\"); root[\"array\"] = array; //json的嵌套 Json::Value sub; sub[\"int\"] = 1; sub[\"str\"] = \"sub str value\"; root[\"subJson\"] = sub; LOGD(\"生成的json字符串为: \"); LOGD(\"%s\", root.toStyledString().c_str()); 解析JSON //解析json Json::Reader reader; Json::Value root2; //这里为了方便，使用构造的json字符串作为解析json的输入 std::string test_json_string = root.toStyledString(); if (reader.parse(test_json_string, root2, false)) { LOGD(\"解析成功\"); //解析json时，一定要多多检查输入的合法性，避免非法输入造成程序崩溃。 if (root2.isMember(\"int\")) { LOGD(\"int = %d\", root2[\"int\"].asInt()); } if (root2.isMember(\"str\")) { LOGD(\"str = %s\", root2[\"str\"].asString().c_str()); } if (root2.isMember(\"array\")) { Json::Value obj = root2[\"array\"]; if (obj.isArray()) { for (Json::ArrayIndex i = 0; i powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"cpp_base.html":{"url":"cpp_base.html","title":"C++基础 ","keywords":"","body":"c++基础知识 这一章节我们主要针对没有c++基础的同学开设的，主要讲解一下我们系统中常用c++语法及常用类； 类 提到c++就不得不先提一下 类，也不要想得太复杂，把它当C语言中的结构体来理解就可以了，举个例子： // C struct Position { int left; int top; int width; int height; }; // c++ class Position { public: int left; int top; int width; int height; }; 定义变量： // C struct Position pos; // c++ Position pos; 操作变量： // C和c++一样 pos.left = 0; 类比C语言中的结构体多了继承、多态、重载还有访问权限的一些概念，对于只熟悉C语言的同学可以不用过多的关注这些细节，只要掌握如何使用即可； 另外，类里可以直接定义函数，C语言中的结构体是定义函数指针，这一点有点不一样，类定义完函数后，就可以跟操作变量一样使用了，这里举一个在我们框架中常用的例子： // 设置文本内容，其中 mTextView1Ptr为ZKTextView类型的指针变量 mTextView1Ptr->setText(\"Hello\"); 常用类 string类 string类其实就是对字符串进行了一些封装，并提供了一大堆函数，只熟悉C语言的同学只需要知道一个函数就可以了：c_str()，该函数会返回string类中的字符串数据，这里也举一个在我们框架中常用的例子： // 输入框回调接口 static void onEditTextChanged_Edittext1(const std::string &text) { // c_str()函数的返回值类型：const char * const char *pStr = text.c_str(); // 之后就可以像普通的字符串操作了，如获取字符串长度strlen(pStr) 等等 } 再举一个获取文本控件内容的例子： // std为命名空间，std::string表示使用std下的string类，不用过多的理会 // 碰到string类，我们参考下面定义就可以了 std::string text = mTextView1Ptr->getText(); // 之后的操作就都一样啦 const char *pStr = text.c_str(); 格式化输出函数snprintf 函数原型： int snprintf(char* dest_str,size_t size,const char* format,...); 功能： 将可变个参数(...)按照format格式化成字符串，然后将其复制到str中。 (1) 如果格式化后的字符串长度 (2) 如果格式化后的字符串长度 >= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\\0')，返回值为欲写入的字符串长度。 所需头文件： #include 格式化参数 规定符%d 十进制有符号整数%u 十进制无符号整数%f 浮点数%s 字符串%c 单个字符%p 指针的值%e 指数形式的浮点数%x, %X 无符号以十六进制表示的整数%o 无符号以八进制表示的整数%g 把输出的值按照%e或者%f类型中输出长度较小的方式输出%p 输出地址符%lu 32位无符号整数%llu 64位无符号整数 说明 (1).可以在“%”和字母之间插进数字表示最大场宽。 例如：%3d表示输出3位整型数，不够3位右对齐。 %9.2f表示输出场宽为9的浮点数，其中小数位为2，整数位为6， 小数点占一位，不够9位右对齐。 %8s表示输出8个字符的字符串，不够8个字符右对齐。 如果字符串的长度、或整型数位数超过说明的场宽，将按其实际长度输出。 但对浮点数，若整数部分位数超过了说明的整数位宽度，将按实际整数位输出； 若小数部分位数超过了说明的小数位宽度，则按说明的宽度以四舍五入输出。 另外，若想在输出值前加一些0，就应在场宽项前加个0。 例如：%04d表示在输出一个小于4位的数值时，将在前面补0使其总宽度为4位。 如果用浮点数表示字符或整型量的输出格式，小数点后的数字代表最大宽度，小数点前的数字代表最小宽度。 例如：%6.9s表示显示一个长度不小于6且不大于9的字符串。若大于9，则第9个字符以后的内容将被删除。 (2).可以在“%”和字母之间加小写字母l，表示输出的是长型数。 例如：%ld表示输出long整数 %lf表示输出double浮点数 (3).可以控制输出左对齐或右对齐，即在\"%\"和字母之间加入一个\"-\"号， 说明输出为左对齐, 否则为右对齐。 例如：%-7d 表示输出7位整数左对齐 %-10s 表示输出10个字符左对齐 特殊规定符\\n 换行\\f 清屏并换页\\r 回车\\t Tab符 例子 直接输出整型 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%d\", 314); LOGD(\"%s\", buf);//日志输出buf 日志输出为 314 控制整型的位数 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%05d\", 314); //格式化为5位数，不足5位数，前面补0 LOGD(\"%s\", buf);//日志输出buf字符串 日志输出为 00314 直接输出浮点数 char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%f\", 3.14); LOGD(\"%s\", buf);//日志输出buf字符串 日志输出为 3.140000 控制输出浮点数格式 char buf[64] = {0}; //输出小数，共6个字符宽度（含小数点在内）， 3个小数位，两个整数位，整数不足两位的则补0 snprintf(buf, sizeof(buf), \"%06.3f\", 3.14); LOGD(\"%s\", buf);//日志输出buf字符串 日志输出为 03.140 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"touchcalibration.html":{"url":"touchcalibration.html","title":"触摸校准 ","keywords":"","body":"触摸校准 电阻屏的机器刷机后系统第一次开机起来会进行一次触摸校准，校准界面如下： 点击 “十字图标” 进行校准；之后想再重新进行校准，我们有以下3种方式： 通过工具修改工程属性，将开机启动触摸校准程序选项勾选上，这样每次开机起来后就会先进入触摸校准界面： 在TF卡根目录下创建一个文件zktouchcalib （注意：该文件是没有后缀名的），插卡后就会进入触摸校准界面 通过代码启动触摸校准界面EASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"font_setting.html":{"url":"font_setting.html","title":"字体库设置说明 ","keywords":"","body":"字体库设置 FlyThings系统默认打包的字体库是思源黑体字体，我们可以查看项目属性： 字体选项默认勾上，编译生成的升级文件就会打包工具安装目录下相应平台font目录下的fzcircle.ttf字体库 该字体库即为思源黑体字体库，我们做了些裁剪，改名为fzcircle.ttf ； 如果我们想使用其他字体库，只需去除默认选项，导入新的字体库即可（注意，这里字体库仅支持ttf格式）： Z6S及以后平台我们系统直接内置了fzcircle.ttf字体库，目的是为了加快开机速度，如果有字体缺失，我们需要自己定制一个扩展字体库，同为思源黑体字体，字体库名称也是fzcircle.ttf，导入方式同上，这样系统加载字体时优先加载系统内置的字体，加载失败则加载扩展字体库里对应的字体；如果是想使用其他字体库，导入的字体库名称不叫fzcircle.ttf即可，这样加载的字体就都是外部的字体。 总结一下： Z11S平台 ：因为该平台系统没有内置字体库，所以系统直接使用的就是工具打包出来的字体库，没有什么扩展字体库之分，记住，默认打包的就是思源黑体字体 fzcircle.ttf； Z6S及以后平台 ：系统内置了fzcircle.ttf字体库，支持扩展字体库，同为思源黑体字体，字体库名称必须是fzcircle.ttf；使用其他字体库情况，导入的字体库名称不能是fzcircle.ttf； powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"font_cut_tool.html":{"url":"font_cut_tool.html","title":"裁剪字体 ","keywords":"","body":"字体裁剪 在项目中，可能会使用自定义字体，但是动辄上10M的完整字体并不适合在项目上使用。 并且，通常我们只用到字体中的一小部分，将不需要的字符裁剪掉，可以大大节省字体的空间消耗，也能加快屏的启动速度。 字体裁剪工具的使用 在开发工具的菜单栏中，可以找到字体裁剪工具。 ， 首先选择字体裁剪的方式。 这一步目的是要确定保留字体中的哪些字符。 正则表达式支持java正则表达式， 例如 \\d 则表示所有数字 指定文本指定一个文本文件，保证文件编码为UTF-8 ，文件内容中的所有文字即表示需要保留的文字。 （推荐该方式： 简单、直观） 设置字体指定完整字体的路径。 设置输出路径指定字体裁剪后，新字体的保存路径。如果文件已存在，将会造成覆盖。 以上参数设置完成后，点击 裁剪 如果提示完成， 则裁剪成功，可以在输出路径中看到新生成的字体文件。可以发现，裁剪后的字体文件小于完整的字体。 示例 新建一个txt文件，文件内容仅 “你好” 两个字，保存编码为UTF-8 。设置好参数后，裁剪，最终生成的 ttf 文件大小在10KB以内。 裁剪后的字体可以在在线字体编辑器中校验包含哪些字符。 字体文件 完整思源黑体下载 常用字TXT 常用字一级下载常用字一级、二级下载繁体字一级、二级下载 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"hardware.html":{"url":"hardware.html","title":"硬件使用说明 ","keywords":"","body":"硬件使用说明 使用前注意事项 确定电源电压一定为4.5-5.5V。如果电源超过高于或者低于这个范围，机器无法工作正常，如果电源电压过高，会损坏模组屏。 确定好串口电平是RS232还得TTL还是RS485，根据要求结合第4点说明选择。 注意电源接口座的接口定义说明，不要接错。 模组功能接口示意图 z11s z6s 电源接口说明 PH2.0-8PIN座子接口定义 1PIN 2PIN 3PIN 4PIN 5PIN 6PIN 7PIN 8PIN DC5V RESET CTS TXOUT/B RXIN/A RTS GND GND 直流电源输入4.5-5.5V 模组RESET,默认是NC 流控CTS 串口TX或者RS485-B。（接外部设备RX/RS485B） 串口RX或者RS485-A（接外部设备TX/RS485A） 流控RTS 电源地 电源地 10PIN1.0FPC座子接口定义 1/2/3PIN 4PIN 5PIN 6PIN 7PIN 8/9/10PIN DC5V RTS RXIN/A TXOUT/B CTS GND 直流电源输入4.5-5.5V 流控RTS 串口RX或者RS485-A（接外部设备TX/RS485A） 串口TX或者RS485-B。（接外部设备RX/RS485B） 流控CTS 电源地 串口输出方式选择 如图说明0R电阻是TTL，0R不要是RS232。 模组屏对应外部设备接口示意图 样品配送电源线说明 电源线为单端PH2.0-8PIN 10CM带扣的白蓝或者白红线。如图 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"problems.html":{"url":"problems.html","title":"常见问题 ","keywords":"","body":"常见问题 旧工具创建的项目导入到新工具，编译提示 ndk-build找不到 如果你安装新工具后，并且将旧工具删除了，那么由旧工具创建的项目，导入到新工具后，编译可能会提示 ndk-build找不到。可以通过手动替换下列文件来解决。下载 z11s项目配置文件，解压后，将文件夹内的全部内容拷贝到项目文件夹下，注意：本操作将会覆盖共三个文件，请注意备份。 覆盖文件后，再重启工具即可解决。 在UI主线程中做耗时的操作导致插卡不显示升级界面 界面的刷新显示是在UI主线程中处理的，如果UI主线程中有做一些耗时的操作或者出现程序死循环的情况，就会影响UI的刷新，从而导致插卡不显示升级界面； onUI_init、onUI_intent、onUI_show、onUI_hide、onUI_quit、onUI_Timer及控件相关的一些回调接口，这些函数都是在UI主线程中调用的，所以出现这种情况，要先检查一下有没有在这些函数中做耗时的操作； 出现这种情况，只能机器插卡重新开机，系统起来后会优先检测是否需要升级，这样就可以正常显示升级界面了。 无法下载调试/下载调试失败 首先确认电脑与屏的连接正确，如果是带WIFI的屏，那么仅支持WIFI连接，无法使用USB线连接；同理，如果是不带WIFI的屏，那么只能通过USB线连接，如果USB连接正常，电脑会识别为一个USB设备。确定了所支持的连接方式后，到开发工具 菜单栏中，选择 调试配置->ADB配置，设置对应的连接方式，保存。再次尝试下载。如何通过ADB下载调试 程序突然自己重启或卡住 首先程序出现非预期的情况时，一定要查看日志(如何查看日志)，尝试反复重现问题，根据日志确定问题代码。如果程序崩溃导致重启，日志上一般会出现类似日志。程序启动初始化时都会输出这些日志，所以可通过这个判断程序是否出现了重启。 程序崩溃的大部分原因可以归为指针的错误用法。例如 空指针 数组越界 没有注意指针的生命周期，内存释放后却还在使用 等等由于项目使用C语言及C++语言编程，在指针内存方面，难免需要处理裸指针，这就需要我们额外细心。 还有种崩溃，可能是没注意 除数不能为0 这种错误。 如果程序卡住，从日志上看，也没有重启的现象， 那我们可以从 线程死锁、是否代码死循环了 、有长时间的耗时操作，造成卡死的假象 这些情况来分析。 更多问题请前往论坛搜索或提问 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"install_adb_driver.html":{"url":"install_adb_driver.html","title":"安装ADB驱动","keywords":"","body":"如何使用适用于Windows XP / Vista / 7/8/10的Android ADB驱动程序安装程序 先下载 驱动安装程序。 通过USB将Android设备连接到计算机。 在ADB驱动程序安装程序中，单击 Install 按钮继续。 如果系统提示Windows无法验证此驱动程序软件的发布者，请在“窗口安全性”对话框中选择 ”始终安装此驱动程序软件“ 通用android usb驱动程序将自动安装在您的计算机上。 最后，ADB Driver Installer将显示安装成功 windows xp的用户安装驱动后建议重启。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"convert_platform.html":{"url":"convert_platform.html","title":"转换项目平台","keywords":"","body":"转换项目平台 自动转换 为方便同一份项目源码用于不同硬件平台，提供了转换编译平台的功能。 操作步骤： 选中项目名，右键，在弹出的上下文菜单中，选择转换编译平台，即可快速切换平台。 针对转换功能，需要注意以下几点： 转换功能实质是重新配置了编译工具链等编译环境，并不会对源码有任何改动。 不同平台硬件有差异，所以串口、GPIO 等与硬件相关的设置需要您手动修改。 由于工具链版本差异，转换后可能出现编译失败的情况，这也需要手动修改Makefile或者规范源码解决。 手动迁移 如果没有目标平台的转换选项，只能手动将项目迁移到目标平台。迁移步骤： 新建一个目标平台的项目。 拷贝所有的ftu文件到新项目。 拷贝所有的logic.cc文件到新项目。 拷贝整个resources文件夹内容到新项目 如果您的项目还添加了其他源文件，也将它们拷贝到新项目。 如果您的项目依赖静态库，需要更换为目标平台对应的静态库，并且修改新项目的Makefile文件，指定链接（可对比新旧Makefile 确定添加的内容）。 如果您的项目依赖动态库，需要更换为目标平台对应的动态库，并且修改新项目的Makefile文件，指定链接（可对比新旧Makefile 确定添加的内容）。 迁移后，如果编译失败，须按照控制台编译错误提示修改代码， powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"board_tag_explain.html":{"url":"board_tag_explain.html","title":"产品规格型号说明 ","keywords":"","body":"产品规格型号说明 板子的背后贴有型号标签，型号说明如下： 如 SW80480070A_CWM是7寸800*480的电容WIFI多媒体版本 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"core_module.html":{"url":"core_module.html","title":"核心模组使用教程 ","keywords":"","body":"核心模组 核心模组需要自行生成镜像，刷机，方可使用模组的多种功能。 使用教程 注册并登录网址 https://superv.flythings.cn 选择硬件版型 选择每个脚位功能 注意： 电容触摸PIN：CTPSCL、CTPSDA、CTPINT、CTPRST 电阻触摸PIN：RTPY2、RTPY1、RTPX2、RTPX1 选择屏幕分辨率; 如果有需要，可再次调整屏幕参数 选择触摸类型 注意： 触摸类型应该与PIN脚对应。 电容触摸PIN：CTPSCL、CTPSDA、CTPINT、CTPRST 电阻触摸PIN：RTPY2、RTPY1、RTPX2、RTPX1 以上都设置完毕后，点击提交， 将根据配置下载新的系统镜像。 新的镜像下载完毕后，再参照制作刷机卡教程，对设备进行刷机。 刷机成功后，可查看FlyThings开发文档进行应用开发。 powered by Gitbooklast modified: 2021-06-09 09:56:26 "}}