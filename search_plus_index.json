{"./":{"url":"./","title":"About Us","keywords":"","body":"About us Target Make development easier and more efficient; let ordinary users have more convenient customized development programs. Value Professional: Casting professional products with professional technology Innovation: Continuous innovation to provide customers with a steady stream of value Responsibility: Use technology to change lives About the display module Why do we make Linux display solutions With the development of technology, the human-computer interaction scheme has been upgrading. At present, the development of human-computer interaction in some traditional fields is relatively slow. In the traditional field, there are many display solutions based on single-chip microcomputer, single-chip microcomputer + FPGA, which have solved the difficult problem of interactive development of color screen display for many customers; but with the increase of user needs and interactive content, traditional hardware limitations can no longer meet most of the problems Customer demand, so we made this product. Empower the convenient human-computer interaction experience program in the traditional field + the access capability of the Internet of Things, and help the development of the Internet of Things. Product advantages Compare the solution of traditional single-chip serial port screen or single-chip + FPGA display screen Provides the latest interactive experience like mobile phones and tablet computers, with high customer acceptance, low product learning costs, and good display effects Multi-layer virtualization technology is realized through software, which solves the problem of traditional display schemes limiting the number of layers Support png format decoding ability, so that the image layer overlay effect is better From the system level, it supports WiFi, Ethernet, 2G, and 4G access capabilities to provide customers with more convenient access to the network; at the same time, it is convenient and fast to access Deep Zhiyun, WeChat Internet of Things, WeChat Pay, Alipay and other platforms, which can be shared The industry provides fast IoT terminal solutions. Provide video decoding capabilities, more convenient to display information to users. Compare Android and traditional Linux solutions Provides a stable hardware foundation for testing, saving the cycle of testing and verification of hardware development Provide system development work for the Internet of Things + display, saving the time for the system to re-develop and debug the system on the Internet of Things and display Provides low-cost and high-efficiency operating capabilities: The current system runs on 1G single-core CPU, 64MBDDR2, 16MB Flash, saving more than 50% of hardware costs Provide development tools with configuration + user logic source code to facilitate customers to quickly complete customized development; the development cycle is at least 60% less than the traditional method. The deeply customized system has the ability to quickly start in 3 seconds and operate safely in 24 hours * 365 days. Application scenario Smart home: Smart Appliances Shared industry Elevator signs Advertising player Charging pile Evaluation machine As long as you need to show, maybe we can help you powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"system_introdoction.html":{"url":"system_introdoction.html","title":"FlyThings System Introduction","keywords":"","body":"FlyThings system framework introduction This system is based on Linux system development, adding a self-developed system framework and GUI interactive system. We call it the FlyThings system. The moral is: the Internet of Things adds a flying ability System target scenario: The current Internet of Things industry is developing rapidly, and the level of LCD development in China has also been continuously improved and has entered the world's leading position. With the drop in the price of liquid crystal display, the demand for user window display, screening is coming. All displays will become displays. In view of the current development, China Science and Technology has proposed a more suitable display solution at the current stage. Replace the use of Android in the following small application scenarios, such as home appliances, access control and other product scenarios with simple functions, high system stability requirements, and high cost-effective requirements Replace the traditional black-and-white display or MCU-driven color display solution, and improve the interactive experience in a low-cost way. The arrival of the Internet of Things and sharing scenarios has brought more demand for display windows and interaction. Provide system support with high cost performance and high stability. System composition Kernel Based on the open source Linux 3.4 kernel version Tailored and optimized for the IoT industry system Autonomous GUI framework Web API Multimedia Service IoT platform access Payment platform access capability Remote update system capabilities Ability to push messages remotely Development support Provide WYSIWYG configuration GUI development tools Provide complete logic code open writing part Continuously updated documentation and sample support Constantly updated control package and system upgrade service powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"docs_brief.html":{"url":"docs_brief.html","title":"Getting started","keywords":"","body":"Getting started For novices, here is an introductory guide. Tools Before starting to use our screen, we must first use the Install ok; Open the tool, and simply get familiar with Development Environment, you can try Create a new project，browse what is there, and don’t have to delve into the details inside; There is nothing on the newly created project UI. We can drag and drop a text control on it, and then compile、run to our See the effect on the screen; Note: If your machine is a wifi version, you must configure the ADB IP to download normally; refer to the document; We have provided a large amount of Sample code, select the code package of the corresponding platform size, download it, unzip it, and import into the tool; there are many projects, these are behind The chapter will introduce in detail, here we can choose the example we are interested in Run to see the effect on our screen; At this point, I believe you will be able to use the simple tool; Rules After getting familiar with the tools, let’s take a look at the development rules of this screen; Understand the directory structure of the project, you can know what the project contains, and in which directory our code, UI and resources are stored; Next, let's take a look at what content is automatically generated by the tool, what is the correspondence between the UI file and the source code and the control naming rule on the UI; After understanding these, we know where our code needs to be filled in and how to operate the controls; Control articles The development interface is inseparable from the use of each control. In the navigation bar of the document, there is a special chapter to introduce the use of each control —— Control Introduction； Serial port First, we must know the communication model； Then try it out according to the provided case, and then add some protocols and functions on this basis; Then go to study the realization of communication framework; Upgrade There are two upgrade methods: Make image file —— update.img file; in this way, the program is solidified into the machine, and the program is still there when power is off. Pay attention to the normal download The difference between debugging; this method is also our most commonly used; Make a flash card —— format the whole machine; the system has a new version update, we will officially provide the corresponding sd file, make it into a flash card and flash the machine to upgrade; like: the system can’t turn on, The system needs to support new functions or fix related bugs, etc., in these cases, you need to flash the machine; Debugging Currently, the program can only be debugged by Add Log; Module articles See Core Module Instructions Hardware See Hardware Instructions Question Here are some common problems and solutions; contact us QQ group：371608200 Forum：SuperV powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"download.html":{"url":"download.html","title":"Environmental Installation","keywords":"","body":"Build a development environment Install FlyThings integrated development tools and SDK Windows FlyThings IDE（20200704-0921） SDK update [!TIP] For new users, the SDK part is already included in the FlyThings IDE installation package, so there is no need to download it again. If you want to update the SDK part independently, you can manually download and unzip it, and replace the original SDK folder. SDK Update Package(1.4.5) powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"flythings_ide_snapshot.html":{"url":"flythings_ide_snapshot.html","title":"First use","keywords":"","body":"Use FlyThings integrated development tool for the first time If you have successfully installed FlyThings IDE, then on your desktop, find the shortcut and double-click to run it.If you delete the shortcut, you can also find in the bin folder in the installation directory and run it directly. Choose a workspace When you run the tool, the following interface will pop up. Workspace is used to store related settings and historical records. You can understand it as a container, which can manage multiple projects at the same time, so there is no need to run multiple development tools at the same time. Welcome Screen If you open the software for the first time, or choose a new workspace, then you will see a welcome interface like the picture below. It provides two shortcut functions: New Project and Import Project New ProjectIt will guide you step by step How to create a new FlyThings project Immport projectThrough it, you can import existing projects into the current workspace and continue previous development.How to import a project We are not in a hurry to New Project , first select in the upper left corner to close the welcome interface.If you want to reopen the welcome interface, on the top menubar , select Help -> Welcome menu in turn. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"flythings_ide_layout_introduce.html":{"url":"flythings_ide_layout_introduce.html","title":"Working area introduction","keywords":"","body":" FlyThings IDE work area usage introduction When your new project is completed, you will see the following interface The editor is roughly divided into six areas. The respective functions are as follows: ① Area-Project Explorer It displays the resource files and code files in the project folder in the form of a tree diagram. You can expand/collapse freely, double-click the file to directly open it for editing. The specific demonstration is as follows: ② Area-UI edit box Mainly responsible for the editing and instant preview of the UI interface, it is the main operation area in the development ③ Area-Control Panel It contains all the built-in controls. You can click to select the control you need, and drag it to ②area to complete the creation of the control. The specific demonstration is as follows: ④ Area - Property When you select a control in area② , all its properties will be displayed here in the form of a table, and you can customize and modify it in the table. For example, to modify the text size, the specific demonstration is as follows: ⑤ Area - Outline View It displays all the created controls in the form of a tree diagram; also supports free expansion/collapse; can clearly understand the hierarchical relationship between the controls; and can be directly dragged and dropped A certain node can quickly adjust the position of the hierarchy; double-click the node to quickly show/hide the controls. This is very easy to use when the hierarchy is complicated. The specific demonstration is as follows: ⑥ Area - Console When compiling the code, this location will output the compilation log. If the compilation fails, double-click error prompt contentto jump directly to the corresponding code.As shown in the figure below, it demonstrates that double-click the error message and jump directly to the code. With the above foundation, now, we can officially start development. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"new_flythings_project.html":{"url":"new_flythings_project.html","title":"New Project","keywords":"","body":"How to create a new FlyThings project Creating a new FlyThings project is very simple. Specific steps are as follows: In the menu bar at the top of the editor, select File -> New -> FlyThings Project After the selection in the previous step is completed, the FlyThings Creation Wizard prompt box will pop up. Fill in the parameters related to the new project as required. These parameters are: Item nameThe name of the project; it can be a combination of letters and numbers. Chinese characters and spaces cannot appear. PositionThe storage path of the project; Chinese characters in the path are also not recommended to prevent compilation exceptions. Platform typeChoose the corresponding platform according to the serial screen you purchased, currently there are Z11S Z6S After filling in the required parameters as above, you can directly select Complete to quickly complete the creation. But for now, we choose Next to customize more parameters. After clicking Next, we will see more parameter definitions The meaning and function of each attribute of the project: Screen saver timeoutFlyThings system provides screensaver function. If there is no touch operation on the serial port screen within the specified time, or you do not reset the screen saver timing through the code, then the system will automatically enter the screen saver.If the time is -1 second, it means that the screen saver function is disabled. Serial portSpecify the communication serial port, and generally do not need to be modified. Baud rateSpecify the baud rate of the communication serial port ResolutionSpecify the width and height of the screen in pixels Screen rotationFor some screen coordinate axis directions, you can check this option to rotate the displayed content by 90° to achieve normal display. FontFlyThings supports custom fonts. If you are not satisfied with the default fonts, you can cancel the defaults and select your font file. InputIf you have a requirement for Chinese input, you can check it and cooperate with Edit input box control, you can solve Chinese input. The above attributes can be modified again later, so don't worry too much about filling in errors. (How to modify the properties of an existing project)After the attributes are filled in and confirmed, click Finish to end the creation. The creation process will take some time and wait patiently. After the project is created, you should first understand Introduction to FlyThings Project Code Structure powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"import_project.html":{"url":"import_project.html","title":"Import Project","keywords":"","body":"How to import FlyThings project We can import the downloaded sample code into the current workspace.The import steps are as follows. Locate the menu bar at the top of the tool, and select the menu File -> Import in turn. In the pop-up box, select General -> Existing Project to Workspace, and then select Next。 In the pop-up box, select the Browse button and specify the folder where the project needs to be imported. Click OK, it will automatically parse the items contained in the folder. If the project file is not damaged, you can see the identified project, and then click Finish directly, the imported project will appear in the Project Explorer, and you can continue to view/edit it. Specific import animation powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"new_flythings_ui_file.html":{"url":"new_flythings_ui_file.html","title":"New UI file","keywords":"","body":"How to create a new FlyThings UI file New UI file and New FlyThings project are similar. In the Project Explorer, expand the project that needs to create the UI file, select the ui folder under the project, right-click, and in the pop-up menu, select the menu New -> FlyThings UI file. After the above operations, a New FlyThings UI File Wizard box will pop up, as shown below: ( There are three parameters you want you to specify: File nameYou need to specify the file name of the UI file. The file name is named with letters and numbers, with ftu (FlyThings UI File) as the suffix. ResolutionYou can control the width and height of the UI interface by adjusting the resolution, in pixels; Window typeThere are currently four window types: Normal, Status Bar, Navigation Bar, and Screensaver.In general, we can keep the normal option. For specific explanations of the other three types, please refer to System Application Introduction after confirming the parameters, select Finish to end the creation process. You can see the newly created UI file in the project's ui folder in the project explorer. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"how_to_compile_flythings.html":{"url":"how_to_compile_flythings.html","title":"Compile the project","keywords":"","body":"How to compile the FlyThings project Compiling the FlyThings project is very simple. According to different operation methods, there are three ways to compile as follows. 1. Choose Compile from Project Explorer The specific steps are: In the project explorer, left-click to select the name of the project to be compiled, then right-click, and in the pop-up menu, select the compile FlyThings option to automatically compile the project. The animation of the operation is as follows: 2. Select compile via the toolbar There is a shortcut to compile on the toolbar at the top of the software. Similarly, first in the project explorer, left-click to select the name of the project to be compiled, and then find on the toolbar the green triangle button, click it to compile the selected project . 3. Compile by shortcut keys You may have noticed the compilation shortcut in the above two steps, that is, Ctrl + Alt + Z. It is strongly recommended to use this method for compilation. After editing the code, directly Ctrl + Alt + Z quickly completes the compilation, which is very convenient. How to clean up the project After the project is compiled, some compiled object files and intermediate files are usually left. For example libs and obj folders , Their existence is to speed up compilation and achieve incremental compilation. You can delete them manually, or automatically clean them up through the menu. Manually deleteFirst select the folder to be deleted, right-click, and in the pop-up menu, select the Delete option. Automatic cleaningIf you always perform the deletion manually, it may cause misoperation and cause the loss of important files. Therefore, using automatic cleaning can effectively avoid this situation. Similarly, first select the name of the project to be operated, right-click, and select the Clear Project option in the pop-up menu. It will automatically delete the compiled intermediate files in the libs folder and obj folder.It is recommended to use this method to clean up files. Note: If you encounter strange problems during compilation, or the source code is not compiled into the program, you can try to clean the project first, and then recompile. Especially when you import other people's projects, this situation tends to happen frequently. How to recompile If you want to completely recompile the code, then you can clean up the project and compile again powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"run_project.html":{"url":"run_project.html","title":"Run Project","keywords":"","body":"How to run the project After the project passes compilation, it can be put to run on the real machine. According to different equipment models, there are several operating modes as follows: Use WIFI to connect devices quickly This method only supports models with WIFI, and the currently supported device models are: sw480272043B_CW 4.3Normal definition capacitor with wifi sw480272043B_CWM 4.3Normal definition capacitor with wifi and network multimedia sw80480043B_CW 4.3High-definition capacitor with wifi sw48854050B_CW 5 inch Normal definition capacitor with wifi sw80480070A_CW 7 inch Normal definition capacitor with wifi sw80480070A_CWM 7 inch Normal definition capacitor with wifi and network multimedia sw80480070AI_CW 7 inch Normal definition capacitor with wifi sw80480070AI_CWM 7 inch Normal definition capacitor with wifi and network multimedia sw10600070A_CW 7 inch High-definition capacitor with wifi Product model description After confirming that the device supports WIFI, follow the steps below to complete the configuration: First enter the WIFI setting interfaceof the device, and connect the device to the same wireless network as the computer, that is, the computer and the machine must be connected to the same WIFI. (If a different network will cause the subsequent download procedure to fail). After the wireless network connection is successful, click the menu in the upper right corner of the WIFI setting interface to check the IP address of the device. At this time, back to the development tools on the computer,On the menu bar, select the menu Debug Configuration -> ADB Configuration,In the pop-up box, select WIFI as the ADB connection method, fill in the IP address of the device, and save the application. After completing the connection configuration, select the download and debug menu item, it will temporarily synchronize the project code to the connected device to run. Fast operation with USB connected device For models without WIFI function, almost all support USB cable connection. Note: If it has WIFI function, the USB cable connection is invalid. Connect the device to the computer via a USB cable. If the computer can recognize the device as an Android device, the connection is normal. If you can't connect normally, the computer prompts a driver problem, you can try Download Driver. When the computer recognizes the device correctly, return to the development tool on the computer, in the menu bar, select the menu Debug Configuration -> ADB Configuration, in the pop-up box, select the ADB connection method *USB *, application save. After the configuration is completed, select the Download and Debug menu item, it will temporarily synchronize the project code to the connected device to run. With TF card, boot from TF card If for other reasons, both USB and WIFI cannot be used normally or are occupied, you can start the program from the TF card with the help of a TF card. Specific steps reference Tutorial-start the program from TF card powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"project_structure.html":{"url":"project_structure.html","title":"Project structure introduction","keywords":"","body":"FlyThings project code structure introduction Before you start to write code, you must first understand the basic structure of a FlyThings project, and then you can know where your code should be added.For a basic FlyThings project, its directory structure is like this: It is roughly divided into three folders: jni, resources, ui. The role of each folder is explained below. ui folder Expand ui folder You can see that a main.ftu file is included by default. ftu is the suffix of the UI file of the FlyThings project. Each ftu file corresponds to an application interface. Usually, an application contains multiple interfaces, so you need to create multiple ftu files in the ui folder. To add a new ftu file, please refer to How to create a new FlyThings UI file. For the convenience of description, in the following tutorials, the ftu file will be referred to as the UI file.You can double-click to open the UI file, edit it, and preview the effect instantly. For the specific steps of editing the UI file, please refer to the tutorial of Introduction to Controls.After editing, you can start \"compile\" (How to compile） [!Note] Note: The compilation mentioned here not only compiles the source code, but also includes a series of operations such as the preprocessing of the ui file and the generation of template code, but these are all automated, and you do not need to manually operate. For all the specific operations behind compiling this action, please refer to The specific compilation process and the correspondence between UI files and source code, After reading, I believe you will be easier to understand and get started quickly resources folder The content of this folder is relatively simple, mainly used to store various resource files of the project, including pictures, fonts, input method configuration files, etc. If you have other resource files you can also add to this folder, the folder will be completely copied to the machine. However, due to the limitation of the machine's own storage space, it is not recommended to store large files in this directory. It is recommended that you store large resource files in the TF card. We can get the absolute path of a file in the resources directory in the code. For example: The following code can obtain the absolute path of resources/test.txt. #include \"manager/ConfigManager.h\" std::string resPath = CONFIGMANAGER->getResFilePathEx(\"test.txt\"); jni folder This folder is mainly for storing code files, and it also contains multiple parts of code. We expand the jni folder As you can see, it contains 6 parts of activity, include, logic, uart, Main.cpp, Makefile, each The functions of each part are as follows: activity subfolder Store the basic class code of the UI file. After each UI file is compiled, an Activity class and a Logic.cc file with the same prefix name will be generated. For example: there is a main.ftu in the ui folder, then after compilation, mainActivity.h, mainActivity.cpp and mainLogic.cc will be generated, and the mainActivity class will be stored in In the activity folder, the mainLogic.cc file will be stored in the logic folder. [!Warning] It is strongly recommended not to manually modify the code under the activity folder, except in special circumstances logic subfolder Store specific logic codes. Same as the description above, each UI file will generate a Logic.cc file with the corresponding prefix name after compilation.Note: Our custom code is mainly added to these Logic.cc files. include subfolder The header files related to the system and all control related header files are mainly stored here. Easy to compile. uart subfolder As the name suggests, this folder stores serial port operation related codes, including reading and writing serial ports, protocol analysis, etc. Main.cpp The entry code of the entire FlyThings application, including the interface for selecting the boot and some initialization, generally does not need to modify this file. Makefile/Android.mk、Application.mk Compilation configuration file, which contains the specific source code compilation process, generally does not need to be modified After the compilation is passed, the libs directory and the obj directory will be generated under the project, which are the compiled target storage directory and the compiled intermediate file directory, both of which can be cleaned up or deleted directly It doesn't matter. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"ftu_and_source_relationships.html":{"url":"ftu_and_source_relationships.html","title":"UI file and generated code explanation","keywords":"","body":"FlyThings compilation process and the correspondence between UI files and source code How the controls in the UI file are associated with pointer variables FlyThings separates the UI from the code for easy management. In the following, UI files refer to all ftu files in the ui folder of the project. In order to reduce the repetitive code written during development, we improved the compilation process. Before the real source code is compiled, the tool will generate aLogic.cc file with the same prefix name according to the UI file. For example, main.ftuwill generate a paired mainLogic.ccfile. Here you need to pay attention to:The generation of the Logic.ccfile is not a direct overwrite, but an incremental modification.When compiling, the tool will traverse each UI file and read the controls contained in the UI file. And declare a pointer variable for this control, in the code, through this pointer, you can operate the corresponding control. Pointer variables are defined in the Activity.cpp file with the same prefix name. Take main.ftu as an example, like this: As you can see in the figure, all pointers are static global variables, and they all have the same naming rules. For specific naming rules, please refer to Naming Rules for Control ID Names and Pointer Variable Names; and, You should also notice the statement #include \"logic/mainLogic.cc\" in the screenshot, which includes the mainLogic.ccfile into mainActivity.cpp , and our business code is written in mainLogic.cc file, so we can fully use these control pointers in mainLogic.cc.If you are interested in the initialization of these pointers, you can find it in the onCreate method of mainActivity. The relationship between UI files and Logic.cc files Now, you probably already know how the controls in the UI file are connected to these pointers. Let's take a look at what code is automatically generated for us in the mainLogic.cc file.If you don't add any controls to your UI file, your mainLogic.cc file will look like this: /** * Register timer * Fill the array to register the timer * Note: id cannot be repeated */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //Timer id=0, interval of 6 seconds //{1, 1000}, }; /** * Triggered when the interface is constructed */ static void onUI_init(){ //Tips : Add the display code for UI initialization here, such as: mText1Ptr->setText(\"123\"); } /** * Triggered when switching to this interface */ static void onUI_intent(const Intent *intentPtr) { if (intentPtr != NULL) { //TODO } } /* * Triggered when the interface is displayed */ static void onUI_show() { } /* * Triggered when the interface is hidden */ static void onUI_hide() { } /* * Triggered when the interface completely exits */ static void onUI_quit() { } /** * Serial data callback interface */ static void onProtocolDataUpdate(const SProtocolData &data) { } /** * Timer trigger function * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh * Parameters: id * The id of the currently triggered timer is the same as the id at registration * Return value: true * Continue to run the current timer * false * Stop running the current timer */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } /** * Triggered when there is a new touch event * Parameters: ev * New touch event * Return value: true * Indicates that the touch event is intercepted here, and the system will no longer pass this touch event to the control * false * Touch events will continue to be passed to the control */ static bool onmainActivityTouchEvent(const MotionEvent &ev) { return false; } The specific functions of these functions are as follows: REGISTER_ACTIVITY_TIMER_TAB[ ] arrayUsed for register timer; the array member type is the following structure typedef struct { int id; // Timer ID, cannot be repeated int time; // Timer time interval in milliseconds }S_ACTIVITY_TIMEER; In essence, this array will be referenced in the rigesterActivityTimer() function of mainActivity.cppand registered to the system in turn by calling the void registerTimer(int id, int time)method. void onUI_init()Used for interface initialization, if you need to initialize some content when opening this UI interface, then you can add code to this function.In essence, this method will be called in the onCreate() method of mainActivity.cpp . You can understand it as the structure of mainActivity. void onUI_quit()Used to exit the interface, if you need to do some operations when the UI interface exits, then you can add the code to this function. In essence, this method will be called in the destructor of mainActivity.cpp void onProtocolDataUpdate(const SProtocolData &data)Used to receive serial port data. When the serial data frame is parsed, this function will be called. The essence is that in onCreate() of mainActivity.cpp, void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener) is called by default to register to receive serial port data, and the registration is cancelled in the destruction of mainActivity.cpp. When the serial port reads the data, the registered UI interface is called in turn through the void notifyProtocolDataUpdate(const SProtocolData &data) in ProtocolParser.cpp. This is the serial port analysis function in ProtocolParser.cpp, combined with the process described above, you should be able to understand how the serial port data is distributed on each interface: /** * Analyze each frame of data */ static void procParse(const BYTE *pData, UINT len) { switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; } // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } bool onUI_Timer(int id)Timer callback function; when a timer reaches the specified time interval, the system will call this function. When multiple timers are added, you can use the id parameter to distinguish the timers. The id parameter is the same as the id filled in the structure array above.Return true to continue running the current timer;Return false to stop running the current timer;If you stopped the timer by returning false , how do you start it again? You can refer to How to start and stop the timer arbitrarily bool onmainActivityTouchEvent(const MotionEvent &ev)Touch event callback function. Able to get all touch messages. Similarly, this function is also registered by default in mainActivity.cpp through the registerGlobalTouchListenermethod; touch messages can only be obtained after registration. Returning true means that the touch event is intercepted here and is no longer passed to the control Returning false means that touch events will continue to be passed to the controlLearn more about the handling of touch events The above is Logic.cc generated by compiling the default UI file. When we add controls to the UI file and compile again, the tool will generate different associated functions according to different controls to the corresponding Logic.cc file. For example: I added two button controls to the UI file of main.ftu , their IDs are Button1 and Button2, then, after compilation, in the mainLogic.cc file The following two correlation functions are generated in static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } static bool onButtonClick_Button2(ZKButton *pButton) { //LOGD(\" ButtonClick Button2 !!!\\n\"); return false; } Pay attention to the naming of the function. The function name contains the ID name of the control, so we require the ID naming of the control to conform to the C language naming standard. If you keep adding controls, more related functions will be generated into the mainLogic.cc file after compilation.Usually, during development, we will add, delete, and modify controls many times in the UI file. For these situations, the current solutions are as follows: For the case of adding a control, the tool will generate a correlation function based on the control ID name when compiling. If the same correlation function already exists, it will be skipped. Will not have any impact on the Logic.cc file. For deleting controls, if you delete an existing control in the UI file, the tool will not delete its associated function. If the associated function is also deleted, it is likely to cause the loss of customer code, so we choose to keep it. For the modification of the control, the generation of the associated function is only related to the control ID name. If you modify the properties of the control in addition to the ID name in the UI file, it will not affect the associated function; if you modify the control ID name Attribute, when compiling, it will be processed according to the situation of adding controls, and the old associated functions are retained. We only took button controls as an example to describe the relationship between the controls in the UI file and the associated functions generated in Logic.cc. FlyThings also provides associated functions for generating other controls, such as sliders, lists, and sliding windows. , To understand the correlation function of other controls, please refer to Explanation of the correlation function automatically generated by the control Finally, use a picture to summarize the correspondence between the ftu file and the code: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"named_rule.html":{"url":"named_rule.html","title":"Named rules of controls","keywords":"","body":"Control naming rules Most of the controls we add to the UI file will automatically generate a corresponding pointer variable and a macro-defined integer value after being compiled. Naming rules for control ID names and pointer variable names The pointer variable name consists of three parts. Respectively fixed lowercase m as the prefix + ID name + Ptr as the end Take the control whose ID attribute is Textview1 as an example After compilation, the generated corresponding pointer variable is named mTextview1Ptr The type of pointer variable depends on the type of control. The pointer types corresponding to each control are as follows:The header files of each class can be found in the project jni/include folder. Control name Class name ZKQRCode ZKEditText ZKButton ZKTextView ZKSeekBar ZKPointer ZKCircleBar ZKDigitalClock ZKVideoView ZKCameraView ZKWindow ZKListView ZKSlideWindow ZKDiagram Control ID name and macro definition integer value naming rules This macro definition represents the mapping relationship of controls in the UI file. The macro definition consists of three parts. They are composed of fixed uppercase ID, uppercase UI file name, and control ID attribute name.Take the control whose ID attribute is Textview1 as an example After compilation, the corresponding macro statement generated is #define ID_MAIN_TextView1 50001 [!Warning] Do not change the integer value of the macro definition at will, otherwise it will cause the program to be abnormal. Explanation of the associated function automatically generated by the control The associated function automatically generated by the control explains that some controls will automatically generate the associated function. The specific explanation of the associated functions generated by these controls is as follows: [!Note] The XXXX in the function represents the control ID name, please replace it yourself in the actual process Button control static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } When the button is clicked, this function is called. The parameter ZKButton *pButton is the pointer of the clicked button, and a series of operations can be performed on the control through the member functions of the pointer. This pointer is the same object as the object pointed to by the global variable mXXXXPtr. Edit input box control static void onEditTextChanged_XXXX(const std::string &text) { } When the text in the input box changes, the system will automatically call this function. The parameter std::string &text is the complete string in the current input box. Slider control static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } When the current progress value of the slider changes, the system will automatically call this function. The parameter ZKSeekBar *pSeekBar is the pointer of the slider control, and a series of operations can be performed on the control through the member functions of the pointer. The parameter int progress is the progress value of the current slider Sliding window control static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } When you click an icon in the sliding window control, the system will automatically call this function. The parameter ZKSlideWindow *pSlideWindow is the pointer of the sliding window control, and a series of operations can be performed on the control through the member functions of the pointer. The parameter int index is the index value of the currently clicked icon. For example, a total of 10 icons are added to the sliding window, and the index value range is [0, 9] List control The list control is the most complex control, it will create three associated functions. Although there are many functions, it is very easy to understand according to the following steps. First, if the system wants to draw a list control, it needs to know how many items it has. So there is the following correlation function static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } The parameter const ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. The return value is an integer, which means how many items there are in the list, which can be defined according to your needs. After the system knows the number that needs to be drawn, it is not enough. It also needs to know what content you display for each item.So with the following function, it will be called multiple times to let you set the display content of each item until each item is processed. static void obtainListItemData_XXXX(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } The parameter ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. The parameter ZKListView::ZKListItem *pListItem is the pointer of the list item, corresponding to the Item in the UI file The parameter int index is the index value of pListItem in the entire list. It has a certain range,For example: getListItemCount_XXXX function returns a value of 10, which means there are 10 items in the list, so the range of index is [0, 9], Combining pListItem and index, you can know where the set list item is in the entire list. In this function, you can set the display content of each item separately according to index.For example: The commented statement in the function means: each list item displays its corresponding index number. Similar to the button control, the list control also has a click event, but it judges which list item is currently clicked based on the index value. static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } When the list control is clicked, the system will determine which list item the touch point falls on according to the coordinates of the touch. After calculating the index number of the list item, the system will automatically call this function. The parameter ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. The parameter int index is the index value of the currently clicked list item in the entire list control The parameter int id is the plastic id of the currently clicked control. Note that this id is different from the ID name in the attribute table.Its specific macros are defined in the corresponding Activity.h file. For example in mainActivity.h The function of this id parameter is that when there are multiple sub-items in the list item, it can be used to distinguish which sub-item is currently clicked.For example: As shown in the figure below, I added two list items to the list item and added a picture decoration as a switch button.The attribute ID names are SubItem1 and SubItem2 respectively. When I click on SubItem1, by judging the equality relationship between the parameter id and ID_MAIN_SubItem1 and ID_MAIN_SubItem2,You can determine which switch was clicked.Specific code: static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"Clicked the first subitem of item %d in the list\", index); break; case ID_MAIN_SubItem2: //LOGD(\"Clicked on the second subitem of item %d in the list\", index); break; } } Finally, we use a picture to summarize the rules between them: Other controls and so on [!Note] ### Skill: Quickly jump to related functions powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"editor_tip.html":{"url":"editor_tip.html","title":"Common Skills of Development Tools","keywords":"","body":"Development tool common settings Quickly jump to related functions When we add too many controls to the UI file, multiple associated functions will also be generated in the Logic.cc file. If you want to find the associated function of a certain control is quite time-consuming. Fortunately, the tool provides a function to quickly jump from the UI control to the relevant code.On the preview, select a control, right-click, and select Jump to Related Code in the pop-up menu to open the corresponding Logic.cc file, and position the cursor to the position of the associated function of the control. Note: This function is only valid for control types that will automatically generate associated functions, such as the control types mentioned above. If you choose other control types, the function will only jump to the corresponding Logic.cc File and position the cursor at the bottom of the file. Modify font/font size On the menu bar of the tool, select Window -> Preferences In the pop-up box, select according to the following figure in turn to set the font. Code smart completion When editing the code, you first need to enter the starting part, and then type Alt + / to turn on the code completion function.As shown in the figure below, I input the two letters UA , and then type Alt + / shortcut key, you can see that there are multiple completion options, which can be selected with the up and down arrow keys. Enter key confirms the selection. Rebuild index If the code completion function fails, or the editor prompts a code error, but there is no problem with the compilation, please try to rebuild the index. The steps to rebuild the index are as follows: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"ctrl_common.html":{"url":"ctrl_common.html","title":"Common Properties","keywords":"","body":"General attributes Before starting to introduce each control, let's have a basic understanding of some common properties and setting interfaces of the control; Control ID value The ID value is the unique identifier of the control. The control ID value in each ftu file is not allowed to have the same name. The control ID value in different ftu files is allowed to have the same name; after setting the ID value, it will be compiled in activity The corresponding macro definition is generated in the corresponding header file in the directory: Get the ID value of the control: /** * This interface is defined in the control base class ZKBase * Header file location: include/control/ZKBase.h * * Note: The following interfaces are defined in the ZKBase class unless otherwise specified * All controls directly or indirectly inherit the ZKBase class, so all controls can call the public interface in the ZKBase class */ int getID() const; /* Operation example: Click the button control to print the ID value of the control */ static bool onButtonClick_Button1(ZKButton *pButton) { int id = pButton->getID(); LOGD(\"onButtonClick_Button1 id %d\\n\", id); return false; } Control position We open any ftu file, select any control, in the property box, we can see the attribute coordinates, which determines the display position of the control: Where the coordinate value of the upper left corner is relative to the position of the upper left corner of the parent control; Set and get the position of the control through code: /* Interface Description */ // set location void setPosition(const LayoutPosition &position); //Get location const LayoutPosition& getPosition(); /* Operation example */ // Click the button control to set the button position static bool onButtonClick_Button1(ZKButton *pButton) { // Left: 0, Top: 0, Width: 100, Height: 200 LayoutPosition pos(0, 0, 100, 200); pButton->setPosition(pos); return false; } // Click the button control to get the button position static bool onButtonClick_Button2(ZKButton *pButton) { // The mLeft, mTop, mWidth, and mHeight variables of pos correspond to the coordinate values respectively LayoutPosition pos = pButton->getPosition(); return false; } Background color This is relatively simple, you can see the effect by modifying the color; Code to set the background color: /* When color is -1, the background is set to transparent; other color values are 0xRGB, and the color value does not support alpha */ void setBackgroundColor(int color); /* 操Operation example: Click the button control and set the background color to red */ static bool onButtonClick_Button1(ZKButton *pButton) { pButton->setBackgroundColor(0xFF0000); return false; } Background image After selecting the picture, you can see the effect Here we focus on explaining how to set the background image through code: /** * The pPicPath parameter can have the following two ways: * 1. Absolute path, such as: \"/mnt/extsd/pic/bg.png\" * 2. Relative resource directory path, just put the picture in the resources directory of the project, after compiling and packaging, you can use it, if there is a bg.png picture in the resources directory, just set \"bg.png\". */ void setBackgroundPic(const char *pPicPath); /* Operation example */ mButton1Ptr->setBackgroundPic(\"/mnt/extsd/pic/bg.png\"); // set absolute path mButton1Ptr->setBackgroundPic(\"bg.png\"); // Set the bg.png picture in the resources directory Show and hide Through this property, we can set the default display or hidden state of the control; double-click the control in the outline view to quickly modify the state: In addition, we can also dynamically set the control display and hide through code: void setVisible(BOOL isVisible); BOOL isVisible() const; /* Operation example */ mButton1Ptr->setVisible(TRUE); // Display button control mButton1Ptr->setVisible(FALSE); // hide button control /** * Window controls can also use the following interfaces, with the same functions * Header file location: include/window/ZKWindow.h */ void showWnd(); // show window void hideWnd(); // hide the window bool isWndShow() const; // Whether the window is displayed /* Operation example */ mWindow1Ptr->showWnd(); mWindow1Ptr->hideWnd(); Control state For Text、Button、list item , they have 5 states, here we need to explain: normal display state, pressed state, selected state, selected pressed state, invalid state After setting, it will affect the background color, text color and display picture of the corresponding state of the control; The pressed state does not need to be set by code, the touch control is the pressed state; Code operation interface of selected state and invalid state: // Set the selected state void setSelected(BOOL isSelected); BOOL isSelected() const; /* Operation example */ mButton1Ptr->setSelected(TRUE); mButton1Ptr->setSelected(FALSE); /** * Invalid state function description: when the control is set to the invalid state, the touch control has no effect, that is, it does not respond to the press and lift event */ // Set invalid state void setInvalid(BOOL isInvalid); BOOL isInvalid() const; /* Operation example */ mButton1Ptr->setInvalid(TRUE); mButton1Ptr->setInvalid(FALSE); Sample description We use the following small examples to understand the simple usage of related interface functions of common attributes. 1.Create controls First, we create a new Flythings project, double-click to open the main.ftu file under the project UI folder, and drag the button control and text control in the control bar. 2.Compile the project (If you are not sure about the specific operation, please see 《How to compile the FlyThings project》chapter) 3.Call control property function After the compilation is complete, open the jni/logic/mainLogic.cc file in the project and you can see that the onButtonClick_Button1 function is generated at the bottom of the file. We will call the getID() function in this function to get the ID value of the button control Button1, and call the setText() function to display it in the text control TextView1. (If you are not sure about the corresponding rules of the pointer variable name and the control ID in the UI file, click here) 4.Download and debug In the project manager, select the project name, right-click, and select Download and Debug in the pop-up menu to temporarily download the program to the screen and run it. After running, click the button to see the ID value of button control Button1 is 20001. Note: If you want to learn more about the setting interface functions of the common attributes of the control, you can open the /jni/include/control/ZKBase.h file, and the main attribute setting interface functions have been commented. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"textview.html":{"url":"textview.html","title":"Text","keywords":"","body":"Text class TextView Note If you are not sure how to modify the general properties of the text, please refer to《General attributes》 I need to display a text/label, what should I do? If you need to display text, you can quickly implement it with the existing Textview. The specific steps are as follows: Double click to open the main.ftu file Find the text control in the right control collection Left-click on the text control and hold it, then drag it to any position, release the left button, and you can see the automatically generated text control. How to dynamically update text content through code? In the use of the serial port screen, the text content is often updated dynamically. Then in the code, we can dynamically update the content of the text control through the pointer corresponding to the text control. The specific steps are as follows: First, you need to know the pointer variable corresponding to the text control in the code（If you are not clear about the corresponding rules of the pointer variable name and the control ID in the UI file, click here）, Here takes the text control with ID Textview1 as an example, its corresponding pointer variable is mTextview1Ptr, If we want to modify the text content of the Textview1 control to \"Hello World\", it can be achieved by calling the member method of the text control void setText(const char *text), in the corresponding Logic.cc file, The specific code is:mTextview1Ptr->setText(\"Hello World\"); Take an example based on actual usage. The function of the following code is: when the button with ID Button1 is pressed, the text with ID Textview1 is set to \"Hello World\"static bool onButtonClick_Button1(ZKButton *pButton) { mTextview1Ptr->setText(\"Hello World\"); return false; } In addition to setting strings, the text control also supports setting number and character: /* For interface definition, see the header file: include/control/ZKTextView.h */ void setText(int text); // Set number void setText(char text); // Set character /* Operation example */ mTextview1Ptr->setText(123); // Textview1 control will display the string \"123\" mTextview1Ptr->setText('c'); // The Textview1 control will display the'c' character How to modify the color of text? The default text is displayed in white, which usually cannot meet the requirements. You can modify the text color in the following two ways. Modify the color of the control directly in the property bar In the project explorer, select a UI file and double-click to open it; On the preview interface, find the control you want to modify, left-click on it, and you can see the corresponding attribute table of the control on the right side of the editor. At this time, you can fill in the custom attribute values as needed. As with Excel, find the attribute you need to modify, and then click Modify. In the text control, you can see that there are 3 table items related to the color attribute, namely Color setting This property can set the color value of the text in each state of the control separately Background color Set the background color of the entire rectangular area of the control (will not change according to the state of the control) Background color setting To extend the background color property, you can set the background color in each state of the control separately Specific examples: Effect picture: The above figure is a screenshot of the color part of the attribute table. The meaning is: the background color is set to black, and the text color is set to white. When the control is set to the selected state, the text color changes to red. Control color change through code Setting the color in the attribute table is intuitive and convenient, but it lacks flexibility. Therefore, in the code, the color can be dynamically controlled by calling the corresponding member method through the control pointer. Take the text control with ID Textview1 as an example, the following methods can achieve the purpose of modifying the color.（If you are not clear about the corresponding rules of the pointer variable name and the control ID in the UI file, click here） Take the text control with ID Textview1 as an example, the following methods can achieve the purpose of modifying the color. void setInvalid(BOOL isInvalid) /*Set the control Textview1 to the invalid state; if the `color when invalid` property in the property sheet is not empty, set it to the specified color, otherwise there is no change. */ mTextview1Ptr->setInvalid(true); void setSelected(BOOL isSelected) /*Set the control Textview1 to the selected state; if the `color when selected` property in the property sheet is not empty, set it to the specified color, otherwise there is no change. */ mTextview1Ptr->setSelected(true); void setPressed(BOOL isPressed) /*Set the control Textview1 to the pressed state; if the `color when pressed` property in the property sheet is not empty, set it to the specified color, otherwise there is no change. */ mTextview1Ptr->setPressed(true); void setTextColor(int color) //The parameter color represents the RGB color in hexadecimal //Set the control Textview1 to red.。 mTextview1Ptr->setTextColor(0xFF0000); How to display decimals The text control provides an interface for setting string. /** * @brief Set string text */ void setText(const char *text); If you want to display any number, you can first use the snprintf function to format the number into a string, and then set the string to achieve the purpose of displaying content at will.E.g: float n = 3.1415; char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%.3f\", n); /*Fixed display 3 decimal places, extra decimal places will be ignored, if not enough, 0 will be added*/ mTextView1Ptr->setText(buf); snprintf It is a C language standard function, you can search for relevant information on the Internet, or check thebrief introduction and usage examples here。 Realize frame-by-frame animation Since the text control can add a background image, we can use it to simply display a picture.One step closer, if we dynamically switch the background image of the text control in the code, as long as the switching time interval is short enough, the animation effect can be achieved. Picture resource preparationA smooth frame animation necessarily requires multiple image resources. Here we have prepared a total of 60 photos. You can see that each picture represents a frame and is named uniformly according to the serial number, which is mainly to facilitate subsequent use. Note: The system will consume more resources when loading pictures. In order to run the interface smoothly, it is strongly recommended that the pictures should not be too large. For example, the size of a single image in the example is only about 5KB Copy these pictures to the resources directory of the project. You can create subfolders under the resources directory to facilitate the sorting of various image resources. Create a text controlCreate a text control arbitrarily in the UI file. And set the background image of the text control to one of the images. Here I set the first picture as the background picture. This step is just to automatically adjust the width and height of the text control to the width and height of the picture, you can also choose not to set it.The complete attributes are shown in the figure: Compile the project, register the timer After adding the text control, compile the project again, register a timer in the generated Logic.cc file, and set the time interval to 50 ms. We use the timer to switch a picture every 50ms. How to compile the project? How to register the timer? Dynamically switch the background of the text controlIn the corresponding Logic.cc file, add the following function to switch the background image, and call it in the timer trigger function bool onUI_Timer(int id). static void updateAnimation(){ static int animationIndex = 0; char path[50] = {0}; snprintf(path, sizeof(path), \"animation/loading_%d.png\", animationIndex); mTextviewAnimationPtr->setBackgroundPic(path); animationIndex = ++animationIndex % 60; } We need to pay attention to two points in the above function: Switching the background image of the text control is implemented by the setBackgroundPic(char* path) function. The parameter of setBackgroundPic(char* path) function is the relative path of the picture. The path is relative to the resources folder in the project. For example: as shown in the figure below, our picture is placed under the folder resources/animation/ in the project, then the relative path of loading_0.png is animation/loading_0.png The setBackgroundPic(char* path) function can also accept absolute paths. For example: if you put the image example.png in the root directory of TF, its corresponding absolute path is /mnt/extsd/example.png, where /mnt/extsd/ is the link of the TF card Load catalog.We recommend that all image resources be placed in the project's resoources folder or its subfolders, because image resources in other paths will not be automatically packaged into the software. Download and run，View effect Complete sample download Use of special character sets We know that, according to the definition of asc code, there is a correspondence between character char and integer int. For example, the asc code of the character 0 is 48. The special character set is a function of mapping the asc code to the picture. After setting this function, when we display a string, the system will try to map each character in the string to a specified picture, and finally display a string of pictures on the screen. Setting method Find the Special Character Set Setting in the text control, click on the More option on the right, a special character set selection box will pop up. Select the import button in the upper right corner to add the picture to the character set. After adding the picture, you can modify the corresponding asc code or character as the mapping character of the picture. Then click Save If you want to verify whether the special character set is added successfully, you can modify the text, and the preview effect will be synchronized on the preview.Note: If you set a special character set, the system will try to map each character to a picture specified in the character set; if a character is not set to a picture, then this character will not be displayed on the screen. Specific use In the above special character set setting box, we have mapped the characters 0-9 and: colon to pictures respectively. Then in the code, set the string through the setText(char* str) function. Since we set a special character set in the TextTime text control, the characters are converted to corresponding pictures. The renderings are as follows: static void updateTime() { char timeStr[20]; struct tm *t = TimeHelper::getDateTime() sprintf(timeStr, \"%02d:%02\", t->tm_hour, t->tm_min); mTextTimePtr->setText(timeStr); } If you only need to display a single character, you can directly set the asc code or character without converting it into a string.E.g: mTextTimePtr->setText((char)48); //Set the asc code directly, it needs to be converted to char mTextTimePtr->setText('0'); //Set characters directly Sample code As there are many properties of text controls, please refer to the TextViewDemo project in Sample codefor more property effects. Preview effect picture: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"button.html":{"url":"button.html","title":"Button","keywords":"","body":"Button class I need a button/button, how to add and modify attributes? If you need a button/button, you can quickly implement it using the existing Button control. The specific steps are as follows: Double-click to open the UI file. Find the Button control in the control set on the right. Left-click the Button control and hold it, then drag it to any position, release the left button, and you can see the automatically generated button control. Left-click the button control you just created, and you can see the related properties of the control on the right side of the editor. In this attribute form, you can freely modify the attributes like filling in an Excel sheet! How to modify the button/button color? Reference How to modify the color of text How to add more animation effects to the button? Reference How to use pictures to enrich the style of buttons/keys How to use pictures to enrich the style of buttons/keys The default button control is pure color, which looks a bit boring. But you can add pictures to beautify the buttons. Here are the specific steps: First add a button control to the UI file.How to add button controls Left-click to select the button control you just added, and you can see the button's attribute table in the attribute column on the right side of the editor.It is observed that among all the attributes, the attributes related to the picture are: Picture settings This attribute can set the pictures in each state of the button, so that the button can automatically switch the corresponding picture according to the change of the state Picture location By default, the picture is centered and zoomed to fill the entire button rectangle. You can adjust the position of the picture and zoom in or out. Background image Set the picture as the background of the button. The picture will cover the entire rectangular area of the button and automatically zoom. Specific examples: Effect picture: The above figure is a screenshot of the parameter part of the attribute table image, and its meaning is: The button displays on.png by default, and it displays off.png when the button is selected; The four parameters of the left, top, width, and height of the picture determine the display area of the picture (in pixels), the upper left corner of the button rectangle area is the starting point coordinates (0, 0), right and downward is the positive direction, The end point coordinates are (67, 31). If the actual width and height of the picture are not equal to the specified width and height parameters, the picture will be scaled according to the specified width and height: Understand the hierarchical relationship of button controls For general button controls, it will draw four levels of content, which are from top to bottom: The text of the button Button picture Button background image Button background color How to add picture buttons/buttons? Reference How to add more animation effects to buttons When this key/button is pressed, where or how can I add my own operation code? In actual development, Button is a kind of control that is used very frequently. Often after the button click event occurs, some processing is done, such as writing to the serial port or refreshing the UI content. To respond to the click time of the button is very simple. The following are the specific steps: First create a Button control, and name the property ID as Button1. How to create a button control In the Project Explorer, select the current project, right-click, and select the Compile FlyThings option in the pop-up menu。The function of this step is to automatically generate template code 。 Learn more about code generation details Take the UI file main.ftu as an example,After the previous step is completed, the file jni/logic/mainLogic.cc will be generated under the current project folder, as shown below: Note： main.ftu corresponds to mainLogic.cc,the prefixes of both are the same. Learn more about code generation details Double-click to open mainLogic.cc , you should see the following function at the end of the file, static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); return false; } When the Button control is clicked on the serial port screen, the system will automatically call the associated function. So, if you need to add your own processing code, just write it directly in the associated function. It can be seen that the function name is generated according to certain rules. Take the Button control as an example, its function name generation rule is onButtonClick_XXXX(ZKButton *pButton),where XXXXwill be replaced with the control ID, So multiple button controls will generate different associated functions. Learn more about related functions of controls System Button In addition to the ID value defined by the button, the button also retains two system button values:sys_back and sys_home,From the name, we can roughly know their functions: Back Button 和 Home button ; Click the back button, the interface will return to the previous interface, if you enter a multi-level interface, click the Home button to directly return to the main interface (start interface). We only need to set the ID value to sys_back or sys_home in the attribute box of the button to achieve the corresponding function. Learn more about interface interaction How to deal with long key press events If you need to handle the long press event of the button, you need to manually add the long press event listener. Specific steps are as follows: In the attribute table of the button,set the long press event trigger time and long press event cycle trigger interval two attributes; in the figure below, I set them to 1000 respectively , 1000, the unit is milliseconds. After setting the properties, compile and open the corresponding Logic.cc file; at the top of the file, declare class LongClickListener,and inherit the ZKBase::ILongClickListenerclass to implement the virtual void onLongClick(ZKBase *pBases) method. namespace { //Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at runtime //Implement the long press monitoring interface class LongClickListener : public ZKBase::ILongClickListener { virtual void onLongClick(ZKBase *pBase) { LOGD(\"Trigger long press event\"); static int count = 0; char buf[128] = {0}; snprintf(buf, sizeof(buf), \"long press event trigger times %d\", ++count); //Each time a long press event is triggered, modify the text of the button mLongButtonPtr->setText(buf); } }; } Next, instantiate the monitor class defined in the previous step and declare it as a static type static LongClickListener longButtonClickListener; Register button long press monitoring in static void onUI_init() function static void onUI_init(){ //Long press the registration button to monitor mLongButtonPtr->setLongClickListener(&longButtonClickListener); } Cancel the button long press monitoring in the static void onUI_quit() function static void onUI_quit() { //Cancel button long press to monitor mLongButtonPtr->setLongClickListener(NULL); } After adding the code, compile, download the program to the machine, and long press to test; you can see that the text of the button has been modified and the onLongClick function successfully responded. For specific implementation, please refer to Sample Code How to handle key touch events If you need to respond when the button press or lift , you can register the touch monitoring interface to do so. Specific steps are as follows: Implement your own touch monitoring interface: namespace { // Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at runtime // Implement touch monitoring interface class TouchListener : public ZKBase::ITouchListener { public: virtual void onTouchEvent(ZKBase *pBase, const MotionEvent &ev) { switch (ev.mActionStatus) { case MotionEvent::E_ACTION_DOWN: mTouchButtonPtr->setText(\"press\"); break; case MotionEvent::E_ACTION_UP: mTouchButtonPtr->setText(\"lift up\"); break; default: break; } } }; } 2.Next, instantiate the monitor class defined in the previous step and declare it as a static type static TouchListener sTouchListener; 3.Register the button touch monitor in the static void onUI_init() function static void onUI_init() { //Register button touch monitor mTouchButtonPtr->setTouchListener(&sTouchListener); } 4.Cancel button touch monitoring in static void onUI_quit() function static void onUI_quit() { //Cancel button touch monitoring mTouchButtonPtr->setTouchListener(NULL); } 5.After adding the code, compile, download the program to the machine, click touch test; you can see that the text of the button has been modified. For specific implementation, please refer to Sample Code Sample code Since there are many button control attributes, please refer to the ButtonDemo project in Sample Code for more attribute effects. Sample preview effect diagram: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"checkbox.html":{"url":"checkbox.html","title":"Checkbox","keywords":"","body":"CheckBox The check box is a control based on the button. If you need a switch button, or a check button, using a check box control is more suitable and easier to use.When the control is clicked, it will automatically switch to the selected state, and click again to switch to the non-selected state. While switching the state, it will automatically switch according to the picture and color set in the properties. how to use Double-click to open the UI file Find the Checkbox control in the control collection on the right Left-click the Checkbox control and hold it, then drag it to any position, release the left button, and you can see the automatically generated check box control. Left-click the check box control just generated, and you can see the related properties of the control on the right side of the editor. Set the pictures of each state and the color of each state as needed. Pay attention to the picture and color when selected. If you set a picture and find that the size of the picture is displayed abnormally, you can adjust the position and size of the picture in the Picture Position property.Normally, we adjust the picture to the left of the rectangular area and the text to the right of the rectangular area. Compile after the properties are set, and its associated functions will be generated in the correspondingLogic.cc.When you click the control, the associated function will be called by the system, and the parameter bool isChecked indicates the selected state. static void onCheckedChanged_Checkbox1(ZKCheckBox* pCheckBox, bool isChecked) { if (isChecked) { //The checkbox is selected LOGD(\"selected\"); } else { //Checkbox is not selected LOGD(\"Not selected\"); } } Download and debug, check the effect. Sample code Please refer to the CheckBoxDemo project in Sample Code.Sample preview effect diagram: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"radiogroup.html":{"url":"radiogroup.html","title":"Single selection group","keywords":"","body":"Single selection group RadioGroup For multiple options, single selection, we can directly use the RadioGroup control.When one of the options is clicked, the option will automatically switch to the selected state, and other options in the same group will become non-selected. While these options are switching states, they will also be automatically switched according to the pictures and colors set in the properties. How to use Double click to open the UI file Find the RadioGroup control set in the control set on the right Click the left mouse button on the Radio Group control and hold it, then drag it to any position, release the left button, and you can see a rectangular area is automatically generated.It represents a container that can hold the option control. You can use the same drag and drop operation to add multiple option controls to the rectangular area just now. Left-click the added option control, and you can see its related properties on the right side of the editor.You can set the picture of each state of each option and the color of each state according to your needs. Here, pay attention to the image and color attributes when selected. If you set a picture and find that the size of the picture is displayed abnormally, you can adjust the position and size of the picture in the Picture Position property.We can also set selected or unselected in the default state property Compile after the properties are set, and its associated functions will be generated in the corresponding Logic.cc.When you click on one of the options, the associated function will be called by the system, where the parameter int checkedID represents the ID of the selected option.We can determine which option is currently clicked based on this ID value. This ID is a macro-defined integer value. After the UI file is compiled, each control will automatically generate the corresponding macro ID. (For more information about the macro, please refer to its naming rules)，The macro ID of each option can be found in the corresponding Activity.h header file. E.g Then in the correlation function, the clicked item can be judged. static void onCheckedChanged_RadioGroup1(ZKRadioGroup* pRadioGroup, int checkedID) { LOGD(\"ID of selected item = %d\", checkedID); switch (checkedID) { case ID_MAIN_RadioButton1: LOGD(\"The first item is selected\"); break; case ID_MAIN_RadioButton2: LOGD(\"The second item is selected\"); break; case ID_MAIN_RadioButton3: LOGD(\"The third item is selected\"); break; default: break; } } Download and debug, check the effect. Sample code Please refer to the RadioGroupDemo project in Sample CodeSample preview effect diagram: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"seekbar.html":{"url":"seekbar.html","title":"Progress Bar/Slider","keywords":"","body":"Slider/progress bar How to use the slider control? In many cases, we will use the progress bar, for example:volume adjustment Using a few simple pictures, we can quickly achieve this effect. First, we prepare four resource pictures Background image Effective graph Slider Slider pressed In the editor, create a slider control If you don’t understand how to create controls,Reference to create a button control The default slider style is transparent, and we must add enough image resources for it to work properly. In the attribute table, we set the effective image, the image that the slider often displays, the image when the slider is pressed, and the background image image After the previous step is completed, the creation of a slider is basically completed. How to preview the sliding effect of the slider in the tool, you can modify it Maximum value property and default progress value property. In the real-time preview, you can see the position change of the slider cursor. How to control the progress of the slider in the code? How to get the current progress of the slider? If we use a slider to implement a volume bar, we must know the progress value of the current volume bar, and once the volume bar changes, we must also adjust the volume simultaneously.So, we have the following 3 functions to solve these problems. Progress value change monitoring functionIf you create a slider control in the UI file, this function will be automatically added to the corresponding XXXXLogic.cc file after compiling FlyThings.When sliding the progress bar on the touch screen, or when the current value of the progress bar changes, the system will automatically call this function.static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { //LOGD(\"The progress value of the XXXX slider changes to %d !\\n\", progress); } void setProgress(int progress)Used to set the current progress of the slider. E.g: //Set the slider progress to 28 mSeekbarPtr->setProgress(28) int getProgress()Used to get the progress value of the current slider. E.g: int progress = mSeekbarPtr->getProgress(); LOGD(\"The current progress value of the slider %s\", progress); Sample code For more use of slider controls, please refer to SeekBarDemo project in Sample Code Sample preview effect diagram: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"pointer.html":{"url":"pointer.html","title":"Pointer/Meter","keywords":"","body":"Pointer instrument control Features If we want to achieve an instrument or clock rotation similar effect, this control can be easily achieved. This control is specially designed to handle graphics rotation. Thinking If we want to realize an instrument, we can disassemble it into two parts, the static background image as the dial and the pointer image that rotates on the background image.Therefore, after selecting the background image and the pointer image, we only need to determine the center coordinates of the pointer rotation. How to use We first create an instrument control, you can see that it has the following properties: If you still don’t know how to create a control, you can refer to How to create a button controlIn the attribute map, you can see that I have added pointer image and background image The adding process is shown in the animation: Judging from the final preview image above, no problems were found, and the background image and pointer position looked normal. However, after the program actually runs, it is wrong. For quick and easy adjustment, we can set the starting angle property to other degrees (default is 0), here we adjust it to 120, we can find that after the pointer is rotated by 120°, the result of the pointer rotation is not what we expect Like that.The reason for this is that the coordinates of the center of the circle where the pointer rotates are incorrect.There are two properties that determine the coordinates of the pointer rotation center, they are rotation point coordinates and pointer fixed point coordinates Rotation point coordinatesThe coordinates are in reference to the entire control rectangular area. The upper left corner of the control rectangular area is [0,0], in pixels. For such an instrument, obviously the coordinates of the rotation point we want are in the center of the dial , Then the specific coordinates of the corresponding picture are （250，250），As shown below: Pointer fixed point coordinatesThe coordinates refer to the pointer picture, the upper left corner of the picture is [0,0], and the unit is pixel. For such a pointer picture, the fixed point coordinates of the pointer we want is (30, 210) After filling the two coordinates into the attribute table, you can see that the pointer rotates to the correct position The starting angle supports negative numbers. In the above example, if change the starting angle to -120, the pointer just points to the dial 0 position. Tips on pointer fixed points In the above example, the coordinate of the fixed point of the pointer is located in the pointer picture. In fact, this coordinate can also exceed the range of the picture to achieve the effect of the cursor. As shown in the figure below, the white in the red box is actually a pointer picture, which is relatively small, but in the properties on the right, I set the pointer fixed point coordinates far beyond the real size of the picture, and then adjust the rotation coordinates to achieve a circle The effect of the ring cursor. Operation method The most common method for this type of control is to adjust the rotation angle of the pointer through code. //Adjust the pointer to 90 degrees mPointer1Ptr->setTargetAngle(90.0); Sample code For the use of specific instrument controls, refer to the PointerDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"listview.html":{"url":"listview.html","title":"List","keywords":"","body":"List control Features The list button is often used when a page cannot display all the information, and there are some consistent attribute classifications in each unit information Scenes WiFi list, device list, table information How to use Open the UI file, create a list control, and add two list item controls to the list. Then you can intuitively see the appearance style of the list. The specific operations are as follows: Select the list, you can see that it has the following properties You can try to modify each attribute, and then download the program to the machine to view the specific changes. Now go to the outline view You can see that an Item node is generated by default under the list, which represents a row or column of the list, and the Item contains the two ListSub nodes we added.You can click to select each node to view their respective attributes, and the scope of their effects can be seen on the preview. Note: Each list control can add up to 32 list items. The properties of Item and List Item controls are similar to the Key controls. You can modify their properties separately and adjust the style. The revised results on my side are as follows: After adjusting the general appearance of the list in the UI file, compile(How to compile the FlyThings project)。In the automatically generated correlation function, we need to add specific logic code to draw the specific content of the list. After compiling, in the corresponding Logic.cc source file, each list control will generate three related functions. int getListItemCount_ListView1(): Get the length of the list to be drawn For example: there are 100 data to be displayed, then 100 is returned. void obtainListItemData_List1: specifically set the display content of each item in the list See the follow-up document for specific examples The above two functions jointly control the display content of the list. More specific function call flow. onListItemClick_List1: the click event of the list control When clicking on an item in the list, the system will call this function, and the parameter index represents the index value of the currently clicked list item. List drawing process When we want to draw a list, the system first needs to know how many items it has in total, so we provide the int getListItemCount_ListView1() function, which will be called by the system to get the length of the list (the total number of items) ), note that this function is dynamically obtained. During the running of the program, we can return different values according to business needs, and then we can dynamically control the length of the list. Next, the system will call void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) this function multiple times. For each call, we can use the pointer provided by the parameter to control the details in this function. Each item is specifically displayed. Example 1. Set the display content of the list itemstatic void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //pListItempointer represents a list item, this pointer can only be used in this function char buf[32] = {0}; //Parameter index indicates which item of the list is currently drawn, starting from 0. //Here, we format the index value into a string snprintf(buf, sizeof(buf), \"Item %d\", index); //Display the string as text in the list item area pListItem->setText(buf); //如If you have configured the list item \"Picture when selected\" in the ui file, //Then, by setting the selected state of the list item through the following line of code, you can control the list item to display the corresponding state picture pListItem->setSelected(true); } Example 2. Set the display content of the list itemIf we use the list item, we can get the pointer of the list item by the following method, and then manipulate the list item through the newly obtained pointer. static void obtainListItemData_ListView1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { char buf[32] = {0}; //Parameter index indicates which item of the list is currently drawn, starting from 0. //Here, we format the index value into a string snprintf(buf, sizeof(buf), \"The first child of item %d\", index); //We can get the pointer of the list item through the findSubItemByID() function and the ID of the list item //Same as the pListItem pointer, the list item pointer found can only be used in this function ZKListView::ZKListSubItem* subitem1 = pListItem->findSubItemByID(ID_MAIN_SubItem1); if (subitem1 != NULL) { //Set the text of the list item 1 subitem1->setText(buf); } snprintf(buf, sizeof(buf), \"The second child of item %d\", index); ZKListView::ZKListSubItem* subitem2 = pListItem->findSubItemByID(ID_MAIN_SubItem2); if (subitem2 != NULL) { //Set the text of the list item 2 subitem2->setText(buf); } } List of ideas In our system, the list is a mapping of a series of rule data. If we want to modify the list, such as adding a piece of data, or modifying a certain item, we should modify the data first, and then trigger a refresh. Then the system automatically calls the obtainListItemData_ListView1 function, in which the display content of the list is set according to the latest data. This idea is reflected in the following example. Sample code We provide a sample list control, refer to the ListViewDemo project in Sample Code. Sample explanation Create a list control We create two list controls in turn and try to set different properties and appearances. CycleList control： Turn on the cycle list option Compile the project This step will automatically generate the code related to the list to the corresponding Logic.cc file.For specific operations, please refer to《How to compile the FlyThings project》 Create the data structure needed for the List1 listIn general, we will define a structure as a model for each data item in the list typedef struct { //The text displayed in the list item const char* mainText; //The text to be displayed in list item 1 const char* subText; //Open/close logo bool bOn; } S_TEST_DATA; We define another structure array to simulate list data static S_TEST_DATA sDataTestTab[] = { { \"Test data 1\", \"testsub1\", false }, { \"Test content 2\", \"testsub2\", false }, { \"Test data 3\", \"testsub3\", false }, { \"Test test 4\", \"testsub4\", true }, { \"Test data 5\", \"testsub5\", false }, { \"Test data 6\", \"testsub6\", true }, { \"Test data 7\", \"testsub7\", false }, { \"Test data 8\", \"testsub8\", false }, { \"Test data 9\", \"testsub9\", false }, { \"Test data 10\", \"testsub10\", false }, { \"Test data 11\", \"testsub11\", false } }; Add list function code static int getListItemCount_List1(const ZKListView *pListView) { //Use the length of the array as the length of the list return sizeof(sDataTestTab) / sizeof(S_TEST_DATA); } static void obtainListItemData_List1(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) { //Get the pointer of list item 1, named psubText ZKListView::ZKListSubItem* psubText = pListItem->findSubItemByID(ID_MAIN_ListSub1); //Get the pointer of list item 2 and name it psubButton ZKListView::ZKListSubItem* psubButton = pListItem->findSubItemByID(ID_MAIN_ListSub2); pListItem->setText(sDataTestTab[index].mainText); //Use index as the subscript, get the corresponding structure from the array, get the text that needs to be displayed from the structure, and finally set it to the corresponding list item psubText->setText(sDataTestTab[index].subText); //In the UI file, we set the selected image attribute for the list item 2. //Here, according to the `bOn` value of the structure, set the selected state of the list item, so that if the member `bOn` is true, it is set to be selected, and the system will automatically display the previously set selected picture psubButton->setSelected(sDataTestTab[index].bOn); } static void onListItemClick_List1(ZKListView *pListView, int index, int id) { //When you click the index item of the list, modify the bOn variable to reverse bOn. In this way, every time you click on the list, the picture will switch once //Note that the operation of picture switching is completed in the obtainListItemData_List1 function, and now we only modify the value of this variable. sDataTestTab[index].bOn = !sDataTestTab[index].bOn; //The last code modified the structure data, now we want to refresh the list immediately, and call refreshListView to force a refresh //After triggering the refresh, the system will call the two functions getListItemCount_List1 and obtainListItemData_List1 again, so that the modified data corresponds to the list display. mList1Ptr->refreshListView(); } After adding the code, you can run it to see the actual effect. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"diagram.html":{"url":"diagram.html","title":"Waveform graph","keywords":"","body":"Waveform Use this control to easily draw a curve or broken line waveform. How to use First create a waveform control in the UI file, which specifies the drawing area of the waveform, and then add a Wave control to the area just created, you should be able to see it immediately A rough preview of the waveform. The specific creation process is as follows: You can add multiple waveforms to the waveform graph and adjust their appearance.Note：Since we cannot directly select a single waveform control on the preview image, when we need to adjust the specified waveform properties, we need to select on the outline view. Check the properties of the Wavrform and Waveform controls respectively, you can find that Waveform graph determines the value range of the x-axis and y-axis of the waveform, and the drawing area of the waveform. The Waveform determines the appearance style of each waveform. Among them, the two properties of step and refresh interval in the properties of Waveform need to be explained. step It represents the value of the advance of the waveform image every time you add a piece of data to the waveform. This value will be affected by the x-axis zoom property. Refresh intervalIndicates the width of the Vacant part when the waveform is refreshed The above two properties are only valid when the waveform data is added using the void addData(int index, float data) function. Coordinate axis and zoom The image scaling of the entire waveform is done automatically, we don't need to care about it, we only need to determine the x-axis range, y-axis range, and the rectangular display area of the entire waveform image in the attribute table. Note: The x-axis zoom and y-axis zoom properties in the waveform control will multiply the business value you added by the ratio and then draw it on the screen. The default is 1.0, which means no zoom. The coordinate axis of the waveform is determined by x-axis minimum, x-axis maximum, y-axis minimum, and y-axis maximum For example, the default x-axis range is [0, 100], y-axis range is [0,100], then the coordinate axis they form is Generally, the value of the x-axis minimum value attribute input is less than the value of the x-axis maximum value attribute input. But if the input minimum value and maximum value are reversed, the waveform image drawn with the same data will be reversed; If you use thevoid setData(int index, const MPPOINT *pPoints, int count)function to add waveform data, the refresh direction will be reversed. Similarly, for the y-axis, drawing a waveform image will cause upside down. Code operation Similarly, the UI file only helps us quickly modify the appearance of the waveform, and the specific waveform data must be added through code. In the public function of the project's jni/include/control/ZKDiagram.h file, you can see all the supported operations. Note: Unlike other controls, the Wave control we added has ID attribute, but it does not generate independent pointer variables. Only the Wave Graph control that contains Wave will generate pointer variables. Therefore, to operate a certain waveform, you need to use the Waveform graph pointer, and then use the index value to indicate which Waveform is operated. The value of index starts from 0. void setPenWidth(int index, int width)Set the wavy line width, corresponding to the line width property on the property sheet void setPenColor(int index, ARGB color)Set the waveform color, corresponding to the wave color property on the property sheet void setXScale(int index, double xScale)Set the x-axis zoom, corresponding to the x-axis zoom property on the property sheet, void setYScale(int index, double yScale)Set the y-axis zoom, corresponding to the y-axis zoom property on the property sheet void setData(int index, const MPPOINT *pPoints, int count) typedef struct _MPPOINT { float x; float y; }MPPOINT; The MMPOINT structure contains the x and y values of a single data. The function means to plot the count points in the pPointsarray onto the indexth waveform. Note: The count value cannot be greater than the actual size of the pPoints array, otherwise the array will be out of bounds.The idea of using this function to draw a waveform is: First, fill the data to be displayed into the sPoints array, and then draw the points in the array on the waveform at one time. Therefore, if you want to achieve the animation effect of the waveform moving to the left or right, you need to manually offset the value in the array by a subscript as a whole, and then display it on the waveform, and then shift it by a subscript as a whole, and then Displayed on the waveform, and so on. Usually such a loop is implemented through a timer.So this method will cause the entire waveform image will be refreshed。 void addData(int index, float data) Add a single data to the waveform, data bis the y value, you may wonder why there is no x value, because this function number is local waveform graph refresh, when you call this function to set the y value every time, The system will automatically offset a certain x value, and the size of this offset is the same as the set step property.Comparing void setData(int index, const MPPOINT *pPoints, int count) and void addData(int index, float data) two ways to refresh the waveform, it can be concluded that if the amount of data is large, the second This method will have higher refresh efficiency. void clear(int index) to clear the waveform data Add the method of wave movement As mentioned above, if you use the void setData(int index, const MPPOINT *pPoints, int count)method to draw waveforms, you usually need to offset the values in the array by yourself. static void movePoints(MPPOINT* p,int size){ for(int i =0;i Add timer to refresh waveform data regularly Under normal circumstances, add a timer to match the waveform to facilitate regular refresh Sample code Effect pictureFor the specific use of waveform control, please refer to the DiagramDemo project inSample Code. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"circlebar.html":{"url":"circlebar.html","title":"Circle bar","keywords":"","body":"Circular progress bar In some cases, we need to display a Loading animation. Then the circular progress bar is very suitable. How to use First, open the UI file, create a Circular Entry Ba, and then set the Valid Image property. A basic circular progress bar is created.All its properties are as follows: The circular progress bar essentially displays the fan-shaped area corresponding to the current progress. This area is a crop of the effective image. For example:If the properties are set according to the above figure, the maximum value is 100, the starting angle is 0, and the rotation direction is clockwise, then when we set the progress of 25, only the 90° fan-shaped area in the upper right corner is displayed. If the progress value is 100, then all valid graphs are displayed. Note: The display area of this sector is only cropped for the effective image, the background image will not be cropped. Code operation The operation function provided by the circular progress bar is very simple. //Set the current progress void setProgress(int progress); //Get the current progress value int getProgress()； //Set the maximum progress void setMax(int max); //Get the maximum progress int getMax()； Sample code In the example, if you slide the upper slider, the progress of the two circular progress bars at the bottom will change accordingly.For the specific use of the circular progress bar control, refer to the CircleBarDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"qrcode.html":{"url":"qrcode.html","title":"QR code","keywords":"","body":"QR code How to add a QR code? If you need to display a two-dimensional code, you can quickly implement it using the existing two-dimensional code control. The specific steps are as follows: Double click to open the UI file Find the QR code control in the control set on the right Left-click the QR code control and hold it, then drag it to any position, release the left button, and you can see the control of the automatic QR code. Select the QR code control just generated, and in the property bar on the right side of the editor, you can modify the content of the QR code, and you can see that the QR code image will change simultaneously. Dynamically update the QR code In addition to setting the QR code content through the tool, we can also dynamically set the QR code content through the code: bool loadQRCode(const char *pStr); Sample code Effect picture For the specific use of the QR code control, please refer to the QrCodeDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"video.html":{"url":"video.html","title":"Video","keywords":"","body":"Video FlyThings also provides controls for video playback. [!Note] The video playback function is not supported by all versions of the machine! If you need to use this function normally, please purchase a machine version with multimedia functions. Use controls to rotate videos First, create a Video Control, the default background color is black. View the attribute table of Video Among them, one attribute is Whether it is a carousel video typeIf you choose Yes, then every time you enter this UI interface, it will automatically read the configuration file in the TF card directory and play the video specified in the configuration file in a loop. Exit the page and automatically stop playing. This attribute is very suitable for scenarios where only the video needs to be played without user intervention, such as carousel advertising machines, automatic playback of a short video, etc.If you select No, only a rendering area of the video will be created, and there will be no other operations. Then, you need to operate the video playback yourself. Create a video profile As mentioned above, if it is a Video carousel type, the video configuration file will be automatically read. You need to create it yourself.This configuration file needs to be located in the root directory of the TF card, the file name is XXXX_video_list.txt XXXX represents the corresponding UI file prefix name.For example: I added a video control to main.ftu, then the corresponding configuration file name is main_video_list.txtThe configuration file is in line units, Each line is the absolute path of the video file. If the video file is also located in the root directory of the TF card, just fill in /mnt/extsd/and add the video file name. Note: To prevent encoding problems from causing video file reading failures, please try to name the video file in English. After the program runs, you can automatically rotate the videos in the configuration file. Play the specified video file Create a Video control Set the attribute Whether it is a carousel video type to No. Add code to control the playback logicPlay //Play the test.mp4 file, starting from time 0 mVideoView1Ptr->play(\"/mnt/extsd/test.mp4\", 0); Pause //Pause playback mVideoView1Ptr->pause(); Resume playback //Resume playback mVideoView1Ptr->resume(); Stop play mVideoView1Ptr->stop(); Jump to the specified time to play //Jump to the 10 second position mVideoView1Ptr->seekTo(10 * 1000); Set playback volume, range 0~1.0 //Set the volume to 0.5 mVideoView1Ptr->setVolume(0.5); Determine if it is playing bool state = mVideoView1Ptr->isPlaying(); if （state) { LOGD(\"Now Playing\"); } Get the total duration of the video, in milliseconds int n = mVideoView1Ptr->getDuration(); Get the current playback position of the video, in milliseconds int n = mVideoView1Ptr->getCurrentPosition(); The video is played asynchronously, and the automatically generated associated function will notify us of the status of the video playback static void onVideoViewPlayerMessageListener_VideoView1(ZKVideoView *pVideoView, int msg) { switch (msg) { case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_STARTED: LOGD(\"Video starts playing\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_COMPLETED: LOGD(\"End of video playback\"); break; case ZKVideoView::E_MSGTYPE_VIDEO_PLAY_ERROR: LOGD(\"Video playback error\"); break; } } Implementation of a complete video player If you have higher requirements for video playback, you need to control play/pause, drag the video progress bar, etc.You can refer to the VideoPlayerDemo project in Sample Code, which implements a complete player. Sample Code In this example, the loop playback of the video and the adjustment of the video volume are realized.For specific implementation, refer to the VideDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"edittext.html":{"url":"edittext.html","title":"Edit box","keywords":"","body":"Edit/input box I need a numeric keyboard, and I need the user to manually input Chinese, what should I do? How to add edit/input box How to add edit/input box If you need numeric and Chinese input, you can quickly implement it using the existing Edit/input box control. The specific steps are as follows: Double click to open the main.ftu file Find the Edit/input Boxcontrol in the control set on the right Left-click the edit/input boxcontrol and hold it, then drag it to any position, release the left button, you can see the control of the automatic edit/input box. In the properties on the right, select Text Type as needed. If you need to enter Chinese, then select Text Type as Full Texy, and in the Project Properties Enable Pinyin input method in. When the download is running on the machine, click the Edit/input control, and a built-in input method or numeric keyboard will be automatically opened, so that you can enter text or numbers. Built-in Pinyin input method Screenshot Built-in numeric keyboard input screenshot The default edit/input box is white, you can customize the appearance style in the attribute table on the right. Among them, the related attributes of the edit/input box are as follows: Is it a password box input If you choose Yes, when you simulate keyboard input, the character you are typing will be displayed as the specified password character, otherwise no change Password CharactersIf you select Yes for password input, the character you are typing will be displayed as the specified password character, otherwise no change Text TypeThere are two options for this attribute, namely Full text Means that you can enter Chinese, English and numbers without restriction. Numbers only Indicates that only numbers can be input, others are restricted. Prompt text When the content in the simulated keyboard is empty, the prompt text will be displayed automatically. Prompt text colorWhen the content in the simulated keyboard is empty, the prompt text will be displayed automatically, and the text color is the specified color. How to get the input content of the simulated keyboard? When the edit/input box is successfully created, select compile FlyThings , its associated function will be automatically generated,Open the jni/logic/****Logic.cc file (****represents the UI file name) in the project directory, and find the automatically generated function （XXXX represents the control ID name）Learn more about the relation function of the control static void onEditTextChanged_XXXX(const std::string &text) { //LOGD(\"The content currently entered is %s \\n\", text.c_str()); } When the simulated keyboard input is finished, the system will automatically call this function, and the parameter text is the complete string on the current simulated keyboard.std::string is a string of C++ language type. You can also get the string pointer in C language through the following statement. const char* str = text.c_str(); How to convert a string to a number? In the associated function of the edit box, we can only get the string, so when we input the number, we need to convert the number string to the number. atoifunction can convert a string to a corresponding number, for example, “212” can be converted to an integer 213If illegal characters are encountered, the conversion will fail or the parsing will be interrupted. E.g:atoi(\"213abc\"); return 213atoi(\"abc\"); return 0static void onEditTextChanged_EditText1(const std::string &text) { int number = atoi(text.c_str()); LOGD(\"string to number = %d\", number); } atof function can convert a string to a corresponding floating point number, for example “3.14” can be converted to a floating point number 3.14If illegal characters are encountered, the conversion will fail or the parsing will be interrupted. E.g:atoi(\"3.14abc\"); return 3.14atoi(\"abc\"); return 0static void onEditTextChanged_EditText1(const std::string &text) { // The atof function can convert a string to a corresponding floating point number, for example, \"3.14\" can be converted to an integer 3.14 //If the parameters are not standardized, the conversion will fail, and the number 0 will be returned uniformly double f = atof(text.c_str()); LOGD(\"String to floating point = %f\", f); } How to customize the input method? In addition to using the default input method, we can also customize the input method. Sample Code Package provides a demo example ImeDemoproject.Currently only supports the customization of numbers and letters input, and the interface with Chinese input method cannot be customized. There are some differences between the implementation of the input method interface and the ordinary interface: The normal interface is implemented by inheriting Activity , and the input method needs to inherit IMEBaseApp; In addition, the registration method is different. The normal interface registration method: REGISTER_ACTIVITY(****Activity);, the input method interface registration method: REGISTER_SYSAPP(APP_TYPE_SYS_IME, ****Activity);(****indicates the UI file name) These differences have been modified in the ImeDemo project, just migrate to your own project: Copy the UserIme.ftu file in the ui directory to the ui directory of your own project; Copy the files UserImeActivity.h and UserImeActivity.cpp in the activity directory to the activity directory of your own project; Copy the UserImeLogic.cc file in the logic directory to the logic directory of your own project; The subsequent operation is consistent with the normal interface programming, and the logic is written in UserImeLogic.cc; powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"window.html":{"url":"window.html","title":"Window Container","keywords":"","body":"Window Function description The window is actually a container part. It can contain all the controls, or it can contain a new window again. Can be used in the following scenarios Show and hide a control combination When you need to complete the tab page, you can switch between different windows through multiple windows Pop-up dialog Pop up floating box How to use Create a window Control，The default window is transparent. You can add a background image or modify the background color according to your needs; you can also add other controls to the window. In the attribute table above, there are two attributes that need to be explained: Whether it is a modal windowIf it is modal, when this window control is displayed, click outside the window, the window will be automatically hidden. If it is non-modal, the display/hide of the window control must be controlled by itself. Automatically hide window after timeoutIf it is a modal window, the window will start counting from the beginning of the display and will be automatically hidden after the specified time. The unit is seconds; if the value is -1, it means that it will not be hidden automatically. If it is non-modal, then this parameter has no effect. Code manipulation For window controls, we generally involve the following functions //Display window void showWnd(); //Hide window void hideWnd(); Determine whether the window is displayed bool isWndShow(); Dynamically set background If we spread the window all over the screen and then set the background of this window, we can achieve the effect of modifying the screen background. Related interface /** * @brief set background image * @param pPicPath picture path */ void setBackgroundPic(const char *pPicPath); /** * @brief Set background color * @param color -1, the background is set to transparent; other color values are 0x RGB, and the color value does not support alpha */ void setBackgroundColor(int color); Usage example //Set the image of the path /mnt/extsd/bg.png as the background image of this window control mWindow1Ptr->setBackgroundPic(\"/mnt/extsd/bg.png\"); //Set the background color of the window with ID window1 to red mWindow1Ptr->setBackgroundColor(0xff0000); //Set the background color of the window with ID window1 to green mWindow1Ptr->setBackgroundColor(0x00ff00); //Set the background color of the window with ID window1 to blue mWindow1Ptr->setBackgroundColor(0x0000ff); Many controls have interfaces for setting background color and background image, and the methods are the same. Sample code Demonstrates the use of modal/non-modal window controls For the use of specific window controls, refer to the WindowDemo project in the Sample code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"slidewindow.html":{"url":"slidewindow.html","title":"Slide Window","keywords":"","body":"Sliding window The sliding window control is similar to the interface effect of sliding left and right on the main interface of the mobile phone. Consists of a sliding main window and multiple icons. How to use First create a sliding main window control in the UI file, and then add multiple sliding window icon controls to the main window control. When adding a sliding window icon control, it will automatically arrange the icons in order. If you add a full page, continue adding it will automatically turn the page. All the added icon controls can be found in Outline View. If you want to adjust the position of the sliding window icons, you can select the node in the outline view, and then directly adjust it by dragging. Note the operation of the outline view in the lower left corner of the animation below. In the outline view, select the sliding window icon control, you can add pictures and modify text separately; select the entire sliding main window to adjust the number of rows and columns, and you can also adjust it uniformly Font size, icon size. Code manipulation If you add a sliding window control, then after compilation, the associated function will be automatically generated. Refer to the function description Sliding window correlation function In general, we only need to scroll up and down by touching and sliding. However, we also provide the corresponding page turning function. Switch to the next page// Switch to the next page with animation mSlideWindow1Ptr->turnToNextPage(true); // Switch to the next page, no animation mSlideWindow1Ptr->turnToNextPage(false); Switch to the previous page// Switch to the previous page with animation mSlideWindow1Ptr->turnToPrevPage(true); // Switch to the previous page, no animation mSlideWindow1Ptr->turnToPrevPage(false); We can also monitor which page the sliding window has turned to through the code: namespace { /* Add an anonymous scope to prevent multiple source files from defining the same class name and conflict at runtime*/ // Implement your own listening interface class MySlidePageChangeListener : public ZKSlideWindow::ISlidePageChangeListener { public: virtual void onSlidePageChange(ZKSlideWindow *pSlideWindow, int page) { LOGD(\"Now switch to page %d\", page); } }; } // Define the listening object static MySlidePageChangeListener sMySlidePageChangeListener; static void onUI_init() { mSlidewindow1Ptr->setSlidePageChangeListener(&sMySlidePageChangeListener); } Get the current page int i = mSlideWindow1Ptr->getCurrentPage(); LOGD(\"Current page %d\", i); Sample code Effect picture For the specific use of sliding window controls, please refer to the SlideWindowDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"painter.html":{"url":"painter.html","title":"Canvas","keywords":"","body":"Canvas The canvas control provides a simple geometric drawing interface. How to use Create a canvas control, the default canvas control is transparent. You can add a background image or modify the background color according to your needs. Code manipulation Through the pointer of the canvas control, you can call the interface to draw graphics. Almost all functions of this control require code implementation. The example is as follows. static void onUI_init() { /** * Draw a rounded rectangle border */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0x7092be); mPainter1Ptr->drawRect(10, 10, 430, 230, 5, 5); /** * Draw an arc */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xadc70c); mPainter1Ptr->drawArc(80, 80, 40, 40, -20, -120); /** * Draw a sector */ mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0x008ecc); mPainter1Ptr->fillArc(80, 80, 40, 40, -20, 120); /** * Draw triangle */ mPainter1Ptr->setLineWidth(4); mPainter1Ptr->setSourceColor(0xff804f); mPainter1Ptr->drawTriangle(200, 40, 160, 90, 240, 90);//Hollow triangle mPainter1Ptr->fillTriangle(300, 40, 260, 90, 340, 90); //Solid triangle /** * Draw a straight line */ MPPOINT points1[] = { {50 , 150}, {150, 150}, {70 , 200}, {100, 120}, {130, 200}, {50 , 150} }; /** Connect to a line according to the provided coordinates of multiple points */ mPainter1Ptr->setLineWidth(2); mPainter1Ptr->setSourceColor(0x88cffa); mPainter1Ptr->drawLines(points1, TABLESIZE(points1)); /** * Draw a curve */ MPPOINT points2[] = { {250, 150}, {350, 150}, {270, 200}, {300, 120}, {330, 200}, {250, 150} }; mPainter1Ptr->setLineWidth(3); mPainter1Ptr->setSourceColor(0xe28ddf); /** Connect as a curve according to the provided multiple point coordinates */ mPainter1Ptr->drawCurve(points2, TABLESIZE(points2)); } Sample code Demonstrates the use of the canvas control For the specific usage of the canvas control, please refer to the PainterDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"camera.html":{"url":"camera.html","title":"Camera","keywords":"","body":"camera FlyThings provides camera controls. [!Note] Not all versions of the camera support the camera function! If you need to use this function normally, please purchase a version that supports the USB camera function. How to use First, create a camera control, the default background color is black. View the attribute table of camera Set Auto Preview to OnAccording to the connected camera model, select CVBS signal or not Connect the camera to the screen, then download and run the program, you can see the camera preview screen. Start/stop preview We can start/stop the preview screen through code control Start previewmCameraView1Ptr->startPreview(); Stop previewmCameraView1Ptr->stopPreview(); Camera to take pictures Implement the camera callback interface class PictureCallback : public ZKCamera::IPictureCallback { public: virtual void onPictureTakenStarted() { mTextView1Ptr->setText(\"Start taking pictures\"); } virtual void onPictureTakenEnd() { mTextView1Ptr->setText(\"Picture is over\"); } virtual void onPictureTakenError() { mTextView1Ptr->setText(\"Picture error\"); } virtual const char* onPictureSavePath() { //Photo save path return \"/mnt/extsd/camera.jpg\"; } }; Instantiate the interface and register //Defined as a global static variable static PictureCallback picture_callback; Register the camera callback interface static void onUI_init(){ mCameraView1Ptr->setPictureCallback(&picture_callback); } static void onUI_quit() { //Remember to empty the registration interface when the interface exits mCameraView1Ptr->setPictureCallback(NULL); } Add a button, when you click the button, request a photstatic bool onButtonClick_Button3(ZKButton *pButton) { //Request a photo mCameraView1Ptr->takePicture(); return false; } Sample code In this example, the camera preview and camera functions, and album functions are implemented.For specific implementation, refer to Sample Code CameraDemo project powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"digital_clock.html":{"url":"digital_clock.html","title":"Digital Clock","keywords":"","body":"Digital clock The digital clock is a control dedicated to time display. In many scenarios, we need to display the time. This control will automatically display according to the system time. How to use Double-click to open the UI file Find the digital clock control in the control set on the right Left-click the digital clock control and hold it, then drag it to any position, release the left button, and you can see the digital clock control. Select the digital clock control just generated, in the property bar on the right side of the editor, you can modify its property content, mainly modify the following five properties. Clock display format This attribute sets the display format of the time, you can choose a 24-hour system or a 12-hour system, and control whether the seconds are displayed. Whether it beating This attribute controls whether the : in the clock is static or beating. Clock color This attribute sets the color display of the clock text. font size The text size of the attribute digital clock Special character set settings We know that, according to the definition of asc code, there is a correspondence between character char and integer int . For example, the asc code of the character 0 is 48. The special character set is a function of mapping the asc code to the picture. After setting this function, when we display a string, the system will try to map each character in the string to a specified picture, and finally display a string of pictures on the screen. For specific usage, please refer to Use of special character sets. Save, download and debug, after running, you can see the effect. If you want to modify the time, you can refer to the System Time document to modify. Sample code Refer to the DigitalClockDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"relation_function.html":{"url":"relation_function.html","title":"Relation function introduction","keywords":"","body":"Explanation of the associated function automatically generated by the control Some controls will automatically generate associated functions. The specific explanation of the associated functions generated by these controls is as follows: [!Note] The XXXX in the function represents the control ID, please replace it yourself in the actual process Button control static bool onButtonClick_XXXX(ZKButton *pButton) { return false; } When the button is clicked, this function is called. The parameter ZKButton *pButton is the pointer of the clicked button, and a series of operations can be performed on the control through the member functions of the pointer. This pointer is the same object as the object pointed to by the global variable mXXXXPtr. Edit input box control static void onEditTextChanged_XXXX(const std::string &text) { } When the text in the input box changes, the system will automatically call this function. The parameter std::string &text is the complete string in the current input box. Slider control static void onProgressChanged_XXXX(ZKSeekBar *pSeekBar, int progress) { } When the current progress value of the slider changes, the system will automatically call this function. The parameter ZKSeekBar *pSeekBar is the pointer of the slider control, and a series of operations can be performed on the control through the member functions of the pointer. The parameter int progress is the progress value of the current slider Sliding window control static void onSlideItemClick_XXXX(ZKSlideWindow *pSlideWindow, int index) { } When you click an icon in the sliding window control, the system will automatically call this function. The parameter ZKSlideWindow *pSlideWindow is the pointer of the sliding window control, and a series of operations can be performed on the control through the member functions of the pointer. The parameter int index is the index value of the currently clicked icon. For example, a total of 10 icons are added to the sliding window, and the index value range is [0, 9] List control The list control is the most complex control, it will create three associated functions. Although there are many functions, it is very easy to understand according to the following steps. First, if the system wants to draw a list control, it needs to know how many items it has. So there is the following correlation function static int getListItemCount_XXXX(const ZKListView *pListView) { return 0; } The parameter const ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. The return value is an integer, which means how many items there are in the list, which can be defined according to your needs. After the system knows the number that needs to be drawn, it is not enough. It also needs to know what content you display for each item. So with the following function, it will be called multiple times, allowing you to set the display content of each item until each item is processed. void obtainListItemData_XXXX(ZKListView *pListView, ZKListView::ZKListItem *pListItem, int index) { //pListItem->setText(index) } The parameter ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. The parameter ZKListView::ZKListItem *pListItem is the pointer of the list item, corresponding to the Item in the UI file The parameter int indexis the index value of pListItem in the entire list. It has a certain range, For example: the return value of getListItemCount_XXXX function is 10, it means there are 10 items in the list, then the range of index is [0, 9], combined with pListItem and index, you can know this set now Where is the list item in the entire list. In this function, you can set the display content of each item separately according to index.For example: The commented statement in the function means: each list item displays its corresponding index number as text. Similar to the button control, the list control also has a click event, but it judges which list item is currently clicked based on the index value. static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); } When the list control is clicked, the system will determine which list item the touch point falls on according to the coordinates of the touch. After calculating the index number of the list item, the system will automatically call this function. The parameter ZKListView *pListView is the pointer of the list control, which points to the same object as the global variable mXXXXPtr. The parameter int index is the index value of the currently clicked list item in the entire list control The parameter int id is the plastic id of the currently clicked control. Note that this id is different from the ID name in the attribute table. Its specific macros are defined in the corresponding Activity.h file. For example in mainActivity.h The function of this id parameter is that when there are multiple sub-items in the list item, it can be used to distinguish which sub-item is currently clicked.For example: As shown in the figure below, I added two list sub-items to the list item, and added a picture decoration, as the switch button, the attribute ID names are SubItem1, SubItem2,When I click on SubItem1, by judging the equal relationship between the parameter id and ID_MAIN_SubItem1 and ID_MAIN_SubItem2, I can determine which switch I clicked.Specific code: static void onListItemClick_XXXX(ZKListView *pListView, int index, int id) { //LOGD(\" onListItemClick_ Listview1 !!!\\n\"); switch(id) { case ID_MAIN_SubItem1: //LOGD(\"Clicked the first subitem of item %d in the list\", index); break; case ID_MAIN_SubItem2: //LOGD(\"Clicked on the second subitem of item %d in the list\", index); break; } } [!Note] Skill: Quickly jump to related functions] powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"first_app.html":{"url":"first_app.html","title":"First start screen","keywords":"","body":"When we create a new project, there is a Main.cpp file in the generated template code, path: jni/Main.cpp; the template code is as follows: The code in the red box is the startup interface code, and the interface is mainActivity . The corresponding UI resource file is main.ftu. Specifically, we can look at the code in jni/activity/mainActivity.cpp. It is clear which UI resource is corresponding: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"open_close_app.html":{"url":"open_close_app.html","title":"Open/close application interface","keywords":"","body":"We have already learned about the startup interface. After entering the startup interface, we can open other interfaces, enter the second and third levels, etc.; next we will learn how to open and close other interfaces; Open the application interface For example, now we want to open the interface corresponding to sub.ftu. According to the description of the previous analysis of the startup interface, we can know that the interface object corresponding to the UI resource is subActivity, which are automatically generated by the tool for us. Code, we don’t need to pay attention to too many details, just understand it briefly, then we can start the interface with the following code: EASYUICONTEXT->openActivity(\"subActivity\"); If we want to jump to the sub.ftu interface through a button click, we can call the above statement in the callback interface of the button click event: static bool onButtonClick_Button1(ZKButton *pButton) { // Jump to the sub.ftu interface EASYUICONTEXT->openActivity(\"subActivity\"); return false; } Under normal circumstances, the above calling code is sufficient. If some information needs to be passed between the interface and the interface, such as the payment page, we need to use the second parameter of openActivity to pass parameters: Intent *pIntent = new Intent(); pIntent->putExtra(\"cmd\", \"open\"); pIntent->putExtra(\"value\", \"ok\"); EASYUICONTEXT->openActivity(\"subActivity\", pIntent); In this way, you can receive it in the onUI_intent callback of subLogic.cc: static void onUI_intent(const Intent *intentPtr) { if (intentPtr) { // Key value analysis std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } Note： 1. The new Intent does not need to be manually deleted, it is automatically deleted within the framework; 2. putExtra only provides the key-value pair method of string. If you need to pass int or other types of values, you need to convert to string type, and then do the corresponding conversion after receiving it in onIntent Close application interface Through the open Activity method above, we opened the tabActivity interface. At this time, we want to go back to the original interface, what should we do? We can return to the previous interface through the following code: EASYUICONTEXT->goBack(); If the return is triggered by a button, we can directly use the tool to set the ID value of the button to sys_back, and the system will also respond to the return function; If we enter a more hierarchical interface and want to directly go back to our first startup interface, we can achieve it with the following code: EASYUICONTEXT->goHome(); It returns to the main interface.In addition, if it is also triggered by a button, we can also use the tool to set the button ID value to sys_home, and the system will respond to the function of returning to the main interface; Finally, we can also close the application interface through the closeActivity method of EasyUIContext, for example, we want to close the subActivity interface: EASYUICONTEXT->closeActivity(\"subActivity\"); This method requires the caller to know the name of the application to be closed; in addition, this method cannot close the startup interface, which is always present. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"activity_life_cycle.html":{"url":"activity_life_cycle.html","title":"Interface activity cycle","keywords":"","body":"Interface activity cycle Before introducing the activity cycle of the interface, let's first understand the hierarchical relationship of the interface First of all, after our application is started, we will first enter the interface corresponding to mainActivity which is the startup interface, and then open the interface corresponding to subActivity through the openActivity method, and then enter the interface corresponding to thirdActivity, It forms the hierarchical effect seen in the figure above;The interface opened later is at the upper level of the hierarchy, and a relationship of Stack is formed between them; Activity flow when opening the interface Let's take a look at the process of the program after calling the openActivity method. Here are two situations: Does not exist the interface to be opened in the interface stack; Let’s first take a look at subLogic.cc in onUI_init function，Only when the interface does not exist in the interface stack, this function will be used when it is opened for the first time. Going here means that all control pointers are initialized. In this function, we can start to perform some operations on them. as follows： static void onUI_init() { //Tips :Add the display code of UI initialization here, such as:mTextView1Ptr->setText(\"123\"); LOGD(\"sub onUI_init\\n\"); mTextView1Ptr->setText(\"123\"); } When the interface is opened, data is passed over and received and processed in the， onUI_intent callback function: static void onUI_intent(const Intent *intentPtr) { LOGD(\"sub onUI_intent\\n\"); // Judge not empty if (intentPtr) { // Key value analysis std::string cmd = intentPtr->getExtra(\"cmd\"); // \"open\" std::string value = intentPtr->getExtra(\"value\"); // \"ok\" ...... } } Interface display completion callback onUI_show function; There is the interface to be opened in the interface stack; In this case, only the corresponding interface in the interface stack is moved to the top level, and the onUI_init process is not followed; Open to display an interface, which means that the previous top-level interface is hidden; assuming that The mainActivity interface opens the subActivity interface, and their activity flow is as follows: Here we focus on the mainActivity interface hide ------> subActivity interface display process; Activity flow when closing the interface When we call the goBack() function, the top-level interface will pop up until the interface is started; When the interface is closed, the onUI_quit function will be called back. If some resources are requested after the interface is opened, remember to release it here; After exiting the top-level interface, the next-level interface will be displayed, that is, the onUI_show interface of the next-level interface will be called back; When we call the goHome() function, we will directly go back to the startup interface and pop up all other interfaces; When we call the closeActivity(\"xxx\") function, we can remove any interface except the startup interface; when the interface is not the top-level interface, the next-level interface will not goonUI_show; powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"internal_app.html":{"url":"internal_app.html","title":"System Built-in Interface","keywords":"","body":"In addition to the interface customized by the developer, our system also has several commonly used interfaces built in, such as the interface that appears when the card is upgraded, which is one of the built-in interfaces; In addition, there is a system setting interface, open method: EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); We can click on a button to jump to this interface to see the effect （the effects of several other built-in interfaces can be viewed in the following ways）： static bool onButtonClick_Button1(ZKButton *pButton) { EASYUICONTEXT->openActivity(\"ZKSettingActivity\"); return false; } After each item is clicked in, there is a new built-in interface, open the network settings: EASYUICONTEXT->openActivity(\"NetSettingActivity\"); Open WIFI settings: EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); If the target machine supports wifi, turn on the switch in the upper right corner, the searched wifi information will be displayed on the interface; Open the hotspot setting interface: EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); Back to the system setting interface just now, we click to open the language setting interface: EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); Touch calibration interface: EASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); Developer options interface: EASYUICONTEXT->openActivity(\"DeveloperSettingActivity\"); Currently there are only ADB debugging switch options. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"system_app.html":{"url":"system_app.html","title":"System Application","keywords":"","body":"System interface type The application interface introduced above is classified as a normal window interface, which is usually enough. When creating a new UI interface through the tool, the default window type is a normal window: If some scenes require a display area floating above the UI interface, then ordinary windows will not be able to do the job, and we need to use several other types of windows; In the Window Type option, there are three special types of window options, these three special types have special file names, respectively corresponding to Statusbar statusbar.ftu Navibar navibar.ftu Screensaver screensaver.ftu After clicking OK, the tool will automatically generate the corresponding code for us; the operations of these three types of windows are the same as those of ordinary windows; Status Bar Explanation: This status bar is consistent with the concept of the status bar of Android and iOS phones. It is a general display area floating above the UI interface. Usually used to display some common information, or to place the return button or home button, etc. The following effects: The system provides two interfaces that can be used to operate the status bar: Show status bar: EASYUICONTEXT->showStatusBar(); Hide the status bar: EASYUICONTEXT->hideStatusBar(); For the complete source code, see the StatusBarDemo project in the sample code package Navigation Bar Explanation: This navigation bar has the same concept as the navigation bar of Android phones. It is a general operation or display area floating above the UI interface, generally at the bottom of the page. Usually used to display some operation keys. The navigation bar is actually no different from the status bar. Show navigation bar: EASYUICONTEXT->showNaviBar(); Hide the navigation bar: EASYUICONTEXT->hideNaviBar(); Screensaver application Explanation: The screen saver application means that when the user no longer interacts with the system, the time exceeds a specified length of time. The system automatically opens a page. Right-click the project, select the Properties option, in the pop-up properties box, we can set the screen saver timeout time, the unit is seconds, -1 means not enter the screen saver; We can also make some settings through code, see jni/include/entry/EasyUIContext.h: Required header files #include \"entry/EasyUIContext.h\" Set the screen saver timeout period //Set the screen saver timeout time to 5 seconds EASYUICONTEXT->setScreensaverTimeOut(5); Set whether to allow screen saver EASYUICONTEXT->setScreensaverEnable(false); //Turn off screensaver detection EASYUICONTEXT->setScreensaverEnable(true); //Restore screensaver detection Application scenario: If the upgrade interface cannot enter the screen saver mode, you can turn off the screen saver detection in the upgrade application EASYUICONTEXT->setScreensaverEnable(false). Enter the screensaver now EASYUICONTEXT->screensaverOn(); Exit the screensaver immediately EASYUICONTEXT->screensaverOff(); Determine whether to enter the screen saver EASYUICONTEXT->isScreensaverOn(); For the complete source code, see the ScreensaverDemo project in the sample code package powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"timer.html":{"url":"timer.html","title":"Timer","keywords":"","body":"Timer In some cases, we may need to do some operations regularly. For example, send heartbeat packets at regular intervals, regularly query data to refresh the UI interface, or do some polling tasks. If you have these requirements, then the timer is a convenient choice. How to use the timer Register timerFor ease of use, we add a timer in the form of a filled structure.In the Logic.cc file, there will be such a structure array by default: /** * Register timer * Just add to this array */ static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = { //{0, 6000}, //Timer id=0, time interval is 6 seconds //{1, 1000}, }; If we want to add a timer, we only need to add a structure to this array.The definition of this structure is as follows:typedef struct { int id; // Timer ID, cannot be repeated int time; // Timer interval unit/ms }S_ACTIVITY_TIMEER; Add timer logic codeAfter registering the timer in the array, when a timer is triggered, the system will call the void onUI_Timer(int id) function in the corresponding Logic.cc file. All operation codes for this timer are Added to this function, the function is specifically defined as follows: /** * Timer trigger function * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh * @param id * The id of the currently triggered timer is the same as the id at registration * @return true * Keep running the current timer * false * Stop running the current timer */ static bool onUI_Timer(int id){ switch (id) { default: break; } return true; } This function is also generated by default with the Logic.cc file.Pay attention to the parameters of the function id ，It is the same as the id value defined in the structure array, and we can judge which timer is currently triggered based on the id value, so as to do some targeted operations. [!Note] Note: The timer of each interface is independent, and the id of the timer of different interfaces can be the same;Registered timer, as long as the interface is not destroyed（see interface activity cycle）, Will always be running; No need to manually stop after registration, it will stop automatically when the interface is destroyed. Specific example Next, we will describe the use of timers with a specific example.Suppose we need to implement such a function: There is an integer variable, every second, the variable is accumulated by 1, and the latest result is displayed on the screen.The specific implementation process is as follows: First, we add a text control to the UI file to display the accumulated result. Register the timer, add a structure to the timer array of mainLogic.cc, the timer id is 1, and the time interval is 1 second. Note that the time unit is milliseconds. In mainLogic.cc, define a static integer variable and initialize it to 0 In the void onUI_Timer(int id) function, add the accumulation code and display it in the text control. Compile and run Sample code See the TimerDemo project in the sample code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"how_to_register_timer.html":{"url":"how_to_register_timer.html","title":"Manual register/stop timer","keywords":"","body":"How to start and stop the timer arbitrarily We can add a preset timer in REGISTER_ACTIVITY_TIMER_TAB , but this method is not flexible enough to start/stop arbitrarily. Here is another way to add a timer. There are three methods about timers in the Activity class. The following describes how to use them. /** * Register timer */ void registerUserTimer(int id, int time); /** * Cancel timer */ void unregisterUserTimer(int id); /** * Reset the timer */ void resetUserTimer(int id, int time); In logic.cc, add a variable to identify whether the timer has been registered. /** * Whether the timer is registered */ static bool isRegistered = false; #define TIMER_HANDLE 2 We add two more buttons. In the click event of the button, we add codes for registering and canceling the timer respectively. static bool onButtonClick_ButtonTimerOn(ZKButton *pButton) { //If not registered, register the timer if (!isRegistered) { mActivityPtr->registerUserTimer(TIMER_HANDLE, 500); isRegistered = true; } return false; } static bool onButtonClick_ButtonTimerOff(ZKButton *pButton) { //If the timer is already registered, cancel the registration if (isRegistered) { mActivityPtr->unregisterUserTimer(TIMER_HANDLE); isRegistered = false; } return false; } [!Warning] The above-mentioned three functions registerUserTimer,unregisterUserTimer,andresetUserTimer cannot be called in the onUI_Timer function, which will cause deadlock. Sample code Refer to the TimerDemo project in Sample Code .Preview effect picture: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"linux_serial_programming.html":{"url":"linux_serial_programming.html","title":"Linux serial programming","keywords":"","body":"Linux serial port programming [!Note] The purpose of this document is to let everyone understand how the code of the serial port part of the FlyThings project goes from scratch to something, so that it is easier to understand the code flow of the serial port part we finally provide. After understanding, you can modify the source code according to your needs. This product is based on the Linux system, so we can completely use standard Linux programming to operate the serial port. The basic steps I divide Linux serial port programming into the following 5 steps: Open the serial port,Configure the serial port,Read the serial port,Write the serial port,Close the serial port. Open the serial port #include int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); openis a system function, responsible for opening a node The above code means: try to open the serial port /dev/ttyS0 in a readable and writable manner. If the opening is successful, it returns a non-negative value, which represents the serial port descriptor. If it fails, it returns a negative number, which is an error code. /dev/ttyS0 can be understood as the serial port number, similar to COM1 on Windows system. Configure the serial portAfter successfully opening the serial port, you need to configure the serial port and set the baud rate and other parameters. int openUart() { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); struct termios oldtio = { 0 }; struct termios newtio = { 0 }; tcgetattr(fd, &oldtio); //Set the baud rate to 115200 newtio.c_cflag = B115200 | CS8 | CLOCAL | CREAD; newtio.c_iflag = 0; // IGNPAR | ICRNL newtio.c_oflag = 0; newtio.c_lflag = 0; // ICANON newtio.c_cc[VTIME] = 0; newtio.c_cc[VMIN] = 1; tcflush(fd, TCIOFLUSH); tcsetattr(fd, TCSANOW, &newtio); //Set to non-blocking mode, this will be used when reading the serial port fcntl(fd, F_SETFL, O_NONBLOCK); return fd; } [!Note] The above is the default serial port configuration of this platform, with 8 data bits, 1 stop bit, and no parity. Please do not modify for non-special needs Limited by hardware and drivers, if you modify it to other configurations, it may be invalid. Read the serial port #include unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); readis a system function, which provides the function of reading the serial port. This function requires three parameters: The first parameter is the serial port descriptor, which is the return value of the openfunction in the step of opening the serial port. The second parameter is the buffer pointer, which is used to save the read serial port data. The third parameter is the length of the buffer, which also indicates the maximum number of bytes that can be read this time. Call the function,If the return value is greater than 0, it means that the serial port data has been received correctly, and the return value is equal to the number of bytes of data read.If the return value is less than or equal to 0, it means there is an error or no data is read temporarily. Send serial port #include unsigned char buffer[4] = {0}; buffer[0] = 0x01; buffer[1] = 0x02; buffer[2] = 0x03; buffer[3] = 0x04; int ret = write(fd, buffer, sizeof(buffer)); writeis a system function, which provides the function of sending serial port. This function requires three parameters: The first parameter is the serial port descriptor, which is the return value of the openfunction in the step of opening the serial port. The second parameter is the buffer pointer to be sent. The third parameter is the length of the buffer to be sent Call the function,If the return value is greater than 0, and the return value is equal to the third parameter passed, it means the transmission was successful.If the return value is less than or equal to 0, it means an exception. [!Note] The read function only reads the data stream received by the serial port sequentially, but it cannot guarantee that the complete data will be read once. For example, in a short period of time, the serial port received 1000 bytes of data, the length of the buffer is 1024, although 1024> 1000,But maybe we only read part of the data after the first read, so we need to read multiple times to ensure that the data read is complete. Close the serial port#include close(fd); close is a system function, and the required parameter is the serial port descriptor, that is, the return value of the openfunction in the step of opening the serial port. Comprehensive use The following is a complete example of a simple Linux serial programming. The basic steps mentioned above are all used. #include #include #include int main(int argc, char** argv) { int fd = open(\"/dev/ttyS0\", O_RDWR | O_NOCTTY); if (fd 0) { //Output the read data to the log in turn for (int i = 0; i How to ensure stable serial communication from the software When we try to apply the above examples to official products, we will inevitably encounter these problems: The serial port communication may be disturbed to some extent, and it is not reliable.Therefore, a communication protocol is usually formulated. This protocol generally includes frame header,frame end,frame content,check and other parts,The use of the protocol can ensure the integrity of the data to the greatest extent, making the serial port communication reliable.For example:If we define the protocol, it starts with 0xFF and 0x55, followed by 8 valid bytes for a complete frame. Then the code of the Linux serial communication example above will probably be modified to look like this: // Only the key parts are listed, the rest of the code is omitted while (true) { unsigned char buffer[1024] = {0}; int ret = read(fd, buffer, sizeof(buffer)); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if (ret == 10) { LOGD(\"Read a frame of data correctly\"); } else if (ret When we use the above code for actual testing and frequent sending and receiving, it is very likely that the protocol header is correct, but the frame length is wrong.why？Because of Linux system scheduling or other reasons, the read function cannot guarantee that all data received by the serial port will be returned to you at one time. In order to read the serial port data completely, you need to call the read 函function multiple times, then splice the received data before and after, and then check the data according to the protocol to find a valid frame.Although the code becomes complicated to do so, it is reasonable.Based on the analysis just now, modify the example code to look like this: //Improve the scope of the buffer array so that the data will not be cleared in the while loop unsigned char buffer[1024] = {0}; // Add a `legacy` variable to indicate the length of data left in the buffer int legacy = 0; while (true) { //According to the size of the legacy, adjust the start pointer and size of the buffer to prevent data overwriting int ret = read(fd, buffer + legacy, sizeof(buffer) - legacy); if (ret > 0) { if ((buffer[0] == 0xFF) && (buffer[1] == 0x55)) { if ((ret + legacy) == 10) { LOGD(\"Read a frame of data correctly\"); //清空legacy legacy = 0; } else if (ret In actual applications, we not only have to deal with serial communication, but also respond to the various buttons on the screen.In the above example, it starts with the main function, followed by a while loop, and then processes the serial port message all the time, and cannot do other things.The Linux system supports multithreading . Usually, we create a new child thread, and then put this while loop part in the child thread for processing, so as not to delay our other operations.How to modify, the code is not given here. To sum up In view of the serial communication programming on Linux, many detailed problems need to be dealt with. FlyThings provides a general code that solves the following problems: Open, close, read and write operations of the serial port The splicing of the agreement Provide a unified data callback interface The source code of this part is completely open source , you can create a new FlyThings project at will, the source code is in the uart folder of the project.If you compare the source code of the UartContext class, you should be able to see the shadow of this document. I hope that through this document, you can be familiar with the serial communication part of the FlyThings project. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"serial_introdoction.html":{"url":"serial_introdoction.html","title":"Introduction","keywords":"","body":"Introduction to the serial port The picture below is the simplest communication model; the screen and MCU communicate through the serial port, and they can interact with each other as long as the agreement is established. There is something to note here. The traditional serial screens are used as slave devices and control them by sending corresponding instructions through the MCU; while our serial screens are different, our screens are logical, and they can interact by themselves. As the host side here. If you develop this part of the communication code from scratch, the workload will be huge; in order to simplify the development process and enable developers to pay more attention to the development of business logic, our tool will automatically generate the serial communication code when building a new project. : At the same time, we also provide a callback interface for protocol data and interface interaction: Developers pay more attention to the display of data on the UI interface, and the communication part is automatically completed by our framework. The protocol analysis part of the communication framework needs to be changed according to the communication protocol used by the developer.Next Communication Framework Explanation In this chapter, we will focus on the principle and the parts that need to be modified, and deepen our understanding of this communication framework through some cases in this chapter of Communication Cases powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"serial_framework.html":{"url":"serial_framework.html","title":"Communication frame plus explanation","keywords":"","body":"Communication framework explanation This chapter focuses on the implementation principle of the communication framework. There are many theoretical things. The first time you can give a rough overview of the communication model, you will probably understand the communication model. The supporting case will do it yourself, and then go back to consolidate the principle. After playing it a few times, you can customize the protocol any way you want. Code frame The software APP part is divided into two layers Serial port HAL layer of uart protocol analysis and encapsulation UartContext: The physical control layer of the serial port, which provides the serial port switch, sending and receiving interfaces ProtocolData: Define the data structure of the communication, used to save the actual variables converted from the communication protocol; ProtocolSender: complete the encapsulation of data transmission; ProtocolParser: Complete the protocol parsing part of the data, and then put the parsed data into the ProtocolData data structure; at the same time, it manages the callback interface for the application to monitor serial data changes; APP application interface layer Register the serial port data receiving monitor through the interface provided by ProtocolParser to obtain the updated ProtocolData of the serial port. Send command information to MCU through the interface provided by ProtocolSender Let's refine this process: You can clearly see that the two processes of accept and send are up and down, and the functions of each layer are relatively clear; Specific to the process corresponding to the code: Regardless of whether it is a receiving or sending process, it is ultimately necessary to read and write to the serial port through the UartContext. This is a standardized process, so we basically do not need to modify the UartContext, and we can ignore how it is implemented. Yes, of course, you can check it out if you are interested. At this point, we have a general understanding of this communication model, and then we will look at the implementation of the specific code. How to use and modify the protocol receiving part Modification of communication protocol format Here we give an example of a more common communication protocol: Protocol header (2 bytes) Command (2 bytes) Data length (1 byte) Data (N) Check (1 byte optional) 0xFF55 Cmd len data checksum The CommDef.h file defines synchronization frame header information and minimum data packet size information: // When you need to print the protocol data, open the following macro //#define DEBUG_PRO_DATA // Support checksum verification, open the following macro //#define PRO_SUPPORT_CHECK_SUM /* SynchFrame CmdID DataLen Data CheckSum (Optional) */ /* 2Byte 2Byte 1Byte N Byte 1Byte */ // Minimum length with CheckSum: 2 + 2 + 1 + 1 = 6 // Minimum length without CheckSum: 2 + 2 + 1 = 5 #ifdef PRO_SUPPORT_CHECK_SUM #define DATA_PACKAGE_MIN_LEN 6 #else #define DATA_PACKAGE_MIN_LEN 5 #endif // Sync frame header #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 ProtocolParser.cpp file, configuration file command format: /** * Function: Analyze protocol * Parameters: pData protocol data, len data length * Return value: the length of the actual resolution protocol */ int parseProtocol(const BYTE *pData, UINT len) { UINT remainLen = len; // Remaining data length UINT dataLen; // Packet length UINT frameLen; // Frame length /** * The following parts need to be modified according to the protocol format to parse out the data of each frame */ while (remainLen >= DATA_PACKAGE_MIN_LEN) { // Find the data header of a frame of data while ((remainLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) { pData++; remainLen--; continue; } if (remainLen remainLen) { // Incomplete data content break; } // To print a frame of data, open the DEBUG_PRO_DATA macro in the CommDef.h file when needed #ifdef DEBUG_PRO_DATA for (int i = 0; i The above analysis process is a bit complicated. Let’s first give a picture, and then analyze it may be easier to understand; a packet of data may contain 0 to multiple frames of data, in the picture below, we have marked 3 frames of data, and There is still a frame of incomplete data, and there are 5 less data. The incomplete frame of data will be spliced into the next packet of data Protocol header needs to be modified /* 1.Modify the definition of the protocol header. If the length of the protocol header changes, pay attention to modifying the statement of the protocol header judgment part.*/ #define CMD_HEAD1 0xFF #define CMD_HEAD2 0x55 // 2.You need to modify this when the length of the protocol header changes. while ((mDataBufLen >= 2) && ((pData[0] != CMD_HEAD1) || (pData[1] != CMD_HEAD2))) Modification of changes in the position of the protocol length or the length calculation method // Here pData[4] represents the fifth data is the length byte, if it changes, please modify it here. dataLen = pData[4]; /* The frame length is generally the data length plus the head and tail length. If the length calculation method passed in the agreement changes, modify this part.*/ frameLen = dataLen + DATA_PACKAGE_MIN_LEN; When the verification changes /** * By default, we turn off checksum verification. If you need to support checksum verification, open the PRO_SUPPORT_CHECK_SUM * macro in the CommDef.h file * When the verification is different, the verification method needs to be modified. * 1.Check the content changes to modify this location * if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) * 2.Check the calculation formula changes to modify the content in the getCheckSum function */ /** * Get check code */ BYTE getCheckSum(const BYTE *pData, int len) { int sum = 0; for (int i = 0; i When the reception of a frame of data is completed, the program will call procParse to analyze // Support checksum verification, open the PRO_SUPPORT_CHECK_SUM macro in CommDef.h file when needed #ifdef PRO_SUPPORT_CHECK_SUM // Check code if (getCheckSum(pData, frameLen - 1) == pData[frameLen - 1]) { // Parse a frame of data procParse(pData, frameLen); } else { LOGE(\"CheckSum error!!!!!!\\n\"); } #else // Parse a frame of data procParse(pData, frameLen); #endif How to connect communication protocol data with UI controls Continuing the previous protocol framework, we enter the parsing part of procParse. The key code here is: ProtocolParser.cpp Open the file and find void procParse(const BYTE *pData, UINT len) /* * Protocol analysis * Input parameters: * pData: Start address of a frame of data * len: Length of frame data */ void procParse(const BYTE *pData, UINT len) { /* * Parse the Cmd value to obtain the data and assign it to the sProtocolData structure */ switch (MAKEWORD(pData[2], pData[3])) { case CMDID_POWER: sProtocolData.power = pData[5]; LOGD(\"power status:%d\",sProtocolData.power); break; } notifyProtocolDataUpdate(sProtocolData); } The above MAKEWORD(pData[2], pData[3]) represents the Cmd value in our protocol example; When the data analysis is completed, the page UI update is notified by notifyProtocolDataUpdate. For this part, please refer to the UI update part below data structure The above protocol is parsed into the sProtocolData structure. sProtocolData is a static variable used to save the data value sent by the MCU (or other device) serial port. This data structure is in the ProtocolData.h file. Here you can add communication variables that need to be used in the entire project typedef struct { // You can add protocol data variables here BYTE power; } SProtocolData; UI update The UI interface has completed the registerProtocolDataUpdateListener when the tool generates Activity.cpp, which means that the page program in the logic will receive the data when the data is updated. static void onProtocolDataUpdate(const SProtocolData &data) { // Serial data callback interface if (mProtocolData.power != data.power) { mProtocolData.power = data.power; } if (mProtocolData.eRunMode != data.eRunMode) { mProtocolData.eRunMode = data.eRunMode; mbtn_autoPtr->setSelected(mProtocolData.eRunMode == E_RUN_MODE_MANUAL); if (mProtocolData.eRunMode != E_RUN_MODE_MANUAL) { mbtn_external_windPtr->setText(mProtocolData.externalWindSpeedLevel); mbtn_internal_windPtr->setText(mProtocolData.internalWindSpeedLevel); } } ... } In the code, we see a variable ProtocolData, which is a static variable in the page. It will be initialized during onUI_init(). Such as: static SProtocolData mProtocolData; static void onUI_init() { //Tips : Add the display code of UI initialization here, such as: mText1->setText(\"123\"); mProtocolData = getProtocolData(); // Initialize the structure of the serial port data. // Start the UI display of the initial page } Serial data transmission Open ProtocolSender.cpp When the APP layer needs to send data to the MCU (or other devices), it is enough to call sendProtocol directly. The specific protocol encapsulation is completed by the sendProtocol method. Users can modify this part of the code according to their own protocol requirements. /** * Need to be spliced according to the protocol format, the following is just a template */ bool sendProtocol(const UINT16 cmdID, const BYTE *pData, BYTE len) { BYTE dataBuf[256]; dataBuf[0] = CMD_HEAD1; dataBuf[1] = CMD_HEAD2; // Sync frame header dataBuf[2] = HIBYTE(cmdID); dataBuf[3] = LOBYTE(cmdID); // Command byte dataBuf[4] = len; UINT frameLen = 5; // data for (int i = 0; i send(dataBuf, frameLen); } You can operate when a button is pressed on the interface: BYTE mode[] = { 0x01, 0x02, 0x03, 0x04 }; sendProtocol(0x01, mode, 4); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"serial_example.html":{"url":"serial_example.html","title":"Communication case actual combat","keywords":"","body":"Communication case actual combat Through the previous chapter Communication Framework Explanation, what may be seen is also in the cloud. Here we first summarize, serial communication mainly has the following 4 points: Receive data Analytical data Display data send data The analysis data part is more complicated and needs to be changed according to the specific communication protocol; in this chapter, we will not talk about the theoretical things, and give some practical cases. You can play it a few times. Case number one Here we still take the previous communication protocol as an example to implement a simple communication program of our own;For the complete code, please refer to the UartDemo project of the control sample in Sample CodeThe final effect we want to achieve is to send instructions through the serial port to control the rotation of the meter pointer on the display. The UI rendering is as follows: We only need to modify 3 places to control the rotation of the instrument pointer; 1). Revisit the protocol format introduced earlier, here we add our own protocol command CMDID_ANGLE corresponding to the value 0x0001: Protocol header (2 bytes) Command (2 bytes) Data length (1 byte) Data (N) Check (1 byte optional) 0xFF55 0x0001（See below CMDID_ANGLE） 1 angle checksum We add 1 variable to the protocol data structure, see ProtocolData.h: /******************** CmdID ***********************/ #define CMDID_POWER 0x0 #define CMDID_ANGLE 0x1 // Add ID /**************************************************/ typedef struct { BYTE power; BYTE angle; // Added variable to save pointer angle value } SProtocolData; 2). Since we are still using the previously defined protocol format, we do not need to make any changes to the protocol parsing part here, just process the corresponding CmdID value in procParse: /** * Analyze each frame of data */ static void procParse(const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; case CMDID_ANGLE: // New part, save angle value sProtocolData.angle = pData[5]; break; } // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } 3). Let's look at the callback interface of the interface receiving protocol data, see logic/mainLogic.cc: static void onProtocolDataUpdate(const SProtocolData &data) { // Serial data callback interface // Set the rotation angle of the meter pointer mPointer1Ptr->setTargetAngle(data.angle); } After completing the above process, we only need to send the corresponding instructions to the screen through the MCU to see the rotation of the indicator pointer; for simplicity, we do not do checksum verification in this program, and the protocol data is as follows: Frame header CmdID Data length Angle value 0xFF 0x55 0x00 0x01 0x01 angle We can open the DEBUG_PRO_DATA macro in the CommDef.h file to print the received protocol data: At this point, receive data ---> parse data ---> display data of the serial port, even if it is finished; Finally, let's simulate the serial port sending data; here, in the program we give, a timer is turned on and a data transmission is simulated every 2s: static bool onUI_Timer(int id) { // Simulate sending serial data BYTE data = rand() % 200; sendProtocol(CMDID_ANGLE, &data, 1); return true; } The above code is actually an analog setting of the angle value. We can realize spontaneous sending and receiving by shorting the TX and RX of the communication serial port on the screen, and we can also see that the indicator pointer rotates; At this point, our serial port demo program is introduced. Developers can first compile and burn the demo program to the machine to see the effect, and then add some protocols on this basis to become familiar with the entire communication process. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"serial_configuration.html":{"url":"serial_configuration.html","title":"Serial Configuration","keywords":"","body":"How to configure the serial port Selection of serial port number Due to the design compatibility of software and hardware, the serial number of the software may be different from the serial number identification on the hardware. The specific correspondence is as follows: Z11 series platform Software serial port number Hardware serial port number ttyS0 UART1 ttyS1 UART2 Z6 series platform Software serial port number Hardware serial port number ttyS0 UART0 ttyS1 UART1 ttyS2 UART2 A33 series platform Software serial port number Hardware serial port number ttyS1 UART1 ttyS2 UART2 ttyS3 UART3 Serial port baud rate configuration Configure the baud rate when creating a new project Project properties to modify the baud rate Right-click the project, select the Properties option in the pop-up box, and the following properties box will pop up Serial port open and close Open the source path jni/Main.cpp; we can see that the serial port is opened and closed when the program is initialized and destroyed. void onEasyUIInit(EasyUIContext *pContext) { LOGD(\"onInit\\n\"); // Open the serial port UARTCONTEXT->openUart(CONFIGMANAGER->getUartName().c_str(), CONFIGMANAGER->getUartBaudRate()); } void onEasyUIDeinit(EasyUIContext *pContext) { LOGD(\"onDestroy\\n\"); // Close the serial port UARTCONTEXT->closeUart(); } powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"multiuart.html":{"url":"multiuart.html","title":"Multi-serial configuration","keywords":"","body":"Multiple serial port configuration Conventional projects only support one serial port by default. If you want to use dual serial ports or even multiple serial ports, please download DoubleUartDemo sample, In this example, part of the serial port code is modified in the conventional project to support multiple serial ports. Change The changes are described below. Some codes of uart have been modified, so the serial port configuration in the project properties is invalid. Please refer to the init() function in the jni/uart/UartContext.cpp file to modify the serial port number and baud rate. void UartContext::init() { uart0 = new UartContext(UART_TTYS0); uart0->openUart(\"/dev/ttyS0\", B9600); uart1 = new UartContext(UART_TTYS1); uart1->openUart(\"/dev/ttyS1\", B9600); } Send data to the designated serial port unsigned char buf[2] = {1, 1}; sendProtocolTo(UART_TTYS1, 1, buf, 2); //Send to TTYS1 serial port unsigned char buf[2] = {0}; sendProtocolTo(UART_TTYS0, 1, buf, 2);//Send to TTYS0 serial port The way of receiving serial port data is the same as that of regular projectsIf you need to distinguish which serial port the data comes from, it is recommended to add a field to the SProtocolData structure to identify which serial port the frame comes from. modify uart/ProtocolData.h typedef struct { BYTE power; int uart_from; //From which serial port } SProtocolData; modify uart/ProtocolParser.cpp /** * Analyze each frame of data */ static void procParse(int uart, const BYTE *pData, UINT len) { // CmdID switch (MAKEWORD(pData[3], pData[2])) { case CMDID_POWER: sProtocolData.power = pData[5]; break; } sProtocolData.uart_from = uart; //Identify which serial port the frame comes from // Notify protocol data update notifyProtocolDataUpdate(sProtocolData); } Then in Logic.cc, you can use the uart_from field to determine which serial port the data comes from. static void onProtocolDataUpdate(const SProtocolData &data) { LOGD(\"onProtocol %d\", data.uart_from); char buf[128] = {0}; snprintf(buf, sizeof(buf), \"Received serial port %d data\", data.uart_from); mTextview1Ptr->setText(buf); } Sample code For the complete code, see the DoubleUartDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"wifi.html":{"url":"wifi.html","title":"wifi settings ","keywords":"","body":"Start the wifi setting interface EASYUICONTEXT->openActivity(\"WifiSettingActivity\"); Description of wifi operation interface Get WifiManager object #include \"net/NetManager.h\" WifiManager *pWM = NETMANAGER->getWifiManager(); // You can define a macro to facilitate the following interface calls #define WIFIMANAGER NETMANAGER->getWifiManager() Check whether the machine supports wifi WIFIMANAGER->isSupported(); Check if wifi is on WIFIMANAGER->isWifiEnable(); Switch wifi WIFIMANAGER->enableWifi(true); Scan wifi WIFIMANAGER->startScan(); Connect to wifi WIFIMANAGER->connect(ssid, pw); Disconnect wifi connection WIFIMANAGER->disconnect(); Check if wifi is connected WIFIMANAGER->isConnected(); Get connected wifi information WIFIMANAGER->getConnectionInfo(); Registration and anti-registration wifi information monitoring void addWifiListener(IWifiListener *pListener); void removeWifiListener(IWifiListener *pListener); Sample code See the NetDemo project in the sample code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"wifi_ap.html":{"url":"wifi_ap.html","title":"Hotspot settings ","keywords":"","body":"Launch hotspot setting interface EASYUICONTEXT->openActivity(\"SoftApSettingActivity\"); Hotspot operation interface description Get the SoftApManager object #include \"net/NetManager.h\" SoftApManager *pSAM = NETMANAGER->getSoftApManager(); // You can define a macro to facilitate the following interface calls #define SOFTAPMANAGER NETMANAGER->getSoftApManager() Switch hotspot SOFTAPMANAGER->setEnable(true); Whether the hotspot is open SOFTAPMANAGER->isEnable(); Get current hotspot status SOFTAPMANAGER->getSoftApState(); // There are several states E_SOFTAP_DISABLED // Disabled E_SOFTAP_ENABLING // During opening E_SOFTAP_ENABLED // Open successfully E_SOFTAP_DISABLING // During closing E_SOFTAP_ENABLE_ERROR // failed to open Modify hotspot name and password SOFTAPMANAGER->setSsidAndPwd(\"zkswe\", \"abcd1234\"); Get hotspot name and password SOFTAPMANAGER->getSsid(); SOFTAPMANAGER->getPwd(); Registration and anti-registration hotspot status monitoring void addSoftApStateListener(ISoftApStateListener *pListener); void removeSoftApStateListener(ISoftApStateListener *pListener); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"audio.html":{"url":"audio.html","title":"Audio playback","keywords":"","body":"Music player Create a ZKMediaPlayer object of type ZKMediaPlayer::E_MEDIA_TYPE_AUDIO static ZKMediaPlayer sPlayer(ZKMediaPlayer::E_MEDIA_TYPE_AUDIO); Register message monitoring // The message monitoring interface is as follows class PlayerMessageListener : public ZKMediaPlayer::IPlayerMessageListener { public: virtual void onPlayerMessage(ZKMediaPlayer *pMediaPlayer, int msg, void *pMsgData) { switch (msg) { case ZKMediaPlayer::E_MSGTYPE_ERROR_INVALID_FILEPATH: case ZKMediaPlayer::E_MSGTYPE_ERROR_MEDIA_ERROR: // Error message break; case ZKMediaPlayer::E_MSGTYPE_PLAY_STARTED: // Start message break; case ZKMediaPlayer::E_MSGTYPE_PLAY_COMPLETED: // End of play message break; } } }; static PlayerMessageListener sPlayerMessageListener; // Register message monitoring sPlayer.setPlayerMessageListener(&sPlayerMessageListener); Operation interface description sPlayer.play(\"/mnt/extsd/music/test.mp3\"); // Play the file in the specified path sPlayer.pause(); // Pause playback sPlayer.resume(); // Resume playback sPlayer.seekTo(int msec); // Jump to msec time to play, msec unit: ms sPlayer.stop(); // stop playing sPlayer.isPlaying(); // Whether it is playing, return bool type sPlayer.getDuration(); // Get the total time of the currently playing song sPlayer.getCurrentPosition(); // Get the current playing time of the currently playing song sPlayer.setVolume(0.5, 0.5); // Set media volume, volume range: 0.0 ~ 1.0 [!Note] The audio file to be played cannot be too short, too short time may cause normal playback. For the complete code, seeSample Code MusicDemo project in the control sample powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"thread.html":{"url":"thread.html","title":"Thread","keywords":"","body":"Thread The system supports pthread threads. If you know the pthread interface, you can also use the posix interface to implement threads.In addition, we also provide a wrapper class for pthread. This category includes the following three parts Thread.h：Thread class Mutex.h：Lock class Condition.h：Condition variable class Use of threads Introduce the header file, inherit the Thread class, implement the virtual bool threadLoop() function, and choose to implement the readyToRun function as needed. #include class MyThread: public Thread { public: /** * After the thread is created successfully, this function will be called, and some initialization operations can be done in this function * return true Continue thread * false Exit thread */ virtual bool readyToRun() { LOGD(\"Thread Has been created\"); return true; } /** * Thread loop function * * return true Continue thread loop * false Launch thread */ virtual bool threadLoop() { LOGD(\"Thread loop function\"); //Check if there is a request to exit the thread, if so, return false and exit the thread immediately if (exitPending()) { return false; } //Accumulate the count and display it on the screen loop_count += 1; mTextView2Ptr->setText(loop_count); //To facilitate observation, add sleep 500ms here usleep(1000 * 500); //Return true, continue the next thread loop return true; } }; Instantiate thread object static MyThread my_thread; Start thread //The thread can be started by calling the run function of the thread class, //The parameter is the thread name, which can be arbitrarily specified. my_thread.run(\"this is thread name\"); Stop thread The Thread class provides two functions for requesting to exit the thread. The difference between synchronous and asynchronous is used as follows: void requestExitAndWait() //Request to exit the thread, and wait until the thread completely exits, the function does not return my_thread.requestExitAndWait(); void requestExit() /*Request to exit the thread, the function returns immediately after the request is sent, but at this time, it does not mean that the thread has also exited */ my_thread.requestExit(); After calling any of the above two functions, in the threadLoop function, we can use the bool exitPending() member function to determine whether there is a request to exit the thread. virtual bool threadLoop() { LOGD(\"Thread loop function\"); //Check if there is a request to exit the thread, if so, return false and exit the thread immediately if (exitPending()) { return false; } return true; } [!Note] Note that the above function just adds a mark requesting to exit the thread, not forcibly terminating the thread.If you have been performing certain operations in the threadLoop function, and the threadLoop function has never been able to end, then the thread will not stop.The correct approach is to check the thread exit request in threadLoop, or check a termination condition, and then return false. [!Warning] It is forbidden to call the requestExitAndWait and requestExit functions in the threadLoop function, which may cause deadlock. Determine whether the thread is still running if (my_thread.isRunning()) { mTextView4Ptr->setText(\"running\"); } else { mTextView4Ptr->setText(\"stopped\"); } Thread flow chart After the explanation of the above steps, combined with the flowchart, you should have a deeper understanding. Sample code See the ThreadDemo project in the sample code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"mutex.html":{"url":"mutex.html","title":"Mutex","keywords":"","body":"Mutex/lock When threads are introduced into our program, in some cases other problems will arise, leading to program bugs. In multi-threaded programming, this situation is very common: A thread assigns a value to a variable, and then B thread reads the value.For the convenience of explanation, we translate this situation into the following code.Define a struct Student global variable, and define two threads, the A thread is responsible for assigning values to the student variable; The B thread makes a copy of the student variable, reads out the various members of the variable, and displays it on the log.Excuse me: If two threads are started at the same time, what will be the result of the log of thread B? #include struct Student { char name[24]; //name int age; //age int number; //student ID }; struct Student student = {0}; class AThread: public Thread { public: virtual bool threadLoop() { snprintf(student.name, sizeof(student.name), \"xiaoming\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { struct Student s = student; LOGD(\"name：%s\", s.name); LOGD(\"age：%d\", s.age); LOGD(\"student ID：%d\", s.number); return true; } }; static AThread athread; static BThread bthread; First of all, the result we want is the output in the log name：xiaoming age：10 student ID：20200101 In fact, if the number of tests is large enough, most of the output may be the same as we expect, and the following results may be output: name： age：0 student ID：0 name：xiaoming age：0 student ID：0 name：xiaoming age：10 student ID：0 If there is an \"abnormal\" result in the program, it must be regarded as a bug. Analyze the reasons When there are multiple threads in the program, the thread execution order is flexibly scheduled by the system. It may happen that thread A executes a part of the instructions, then transfers to the B thread to execute some instructions, and then transfers to the A thread to execute the instructions. For the above example, there are three statements in thread A to complete the complete assignment of the student variable. When only the first statement is executed, only the assignment of name is completed, and the system switches to B thread, Then in the B thread, reading the student variable at this time, it will appear that the name field is valid, and the age and number are 0. Other abnormal results are the same. How to solve From the reason, as long as we ensure that all assignment operations of student in thread A are completed, thread B reads the student variable again, so there is no problem. How to achieve In programming, there is a mutual exclusion lock concept to ensure the integrity of shared data operations. Each object corresponds to a tag that can be called a \"mutual exclusion lock\". This tag is used to ensure that at any one time, only one thread can access the object. If you are familiar with Linux programming, you can use standard implementation. Here we introduce the use of our encapsulated mutex class. Define a mutex static Mutex mutex1; Where locking is needed, define a local Mutex::Autolock class instance to lock.This class utilizes the life cycle of local variables and the structure and destructor of C++ classes to automatically implement locking and unlocking operations.Mutex::Autolock _l(mutex1); Combining the above A and B thread examples, the modified code is as follows: #include struct Student { char name[24]; //name int age; //age int number; //student ID }; struct Student student = {0}; //Define mutex static Mutex mutext1; class AThread: public Thread { public: virtual bool threadLoop() { //Lock the statement of the function, and automatically unlock after the function ends Mutex::Autolock _lock(mutext1); snprintf(student.name, sizeof(student.name), \"xiaoming\"); student.age = 10; student.number = 20200101; return true; } }; class BThread: public Thread { public: virtual bool threadLoop() { //Lock the statement of the function, and automatically unlock after the function ends Mutex::Autolock _lock(mutext1); struct Student s = student; LOGD(\"name：%s\", s.name); LOGD(\"age：%d\", s.age); LOGD(\"student ID：%d\", s.number); return true; } }; static AThread athread; static BThread bthread; In the code, we lock the operations related to student in threads A and B.When the A thread is executed, the Mutex::Autolock _lock(mutext1); statement will obtain the mutex1 mutex. When the A thread is not unlocked, it turns to execute the B thread,Executed to the Mutex::Autolock _lock(mutext1); statement in the B thread, it also wants to obtain the mutext1 mutex, but this mutex has been obtained by the A thread first, and now the B thread wants to obtain it , Can only wait, wait until A thread releases mutext1, B thread can obtain the mutext1 mutex normally, and then continue to execute the next statement.After using the mutex, the locked code part can be executed mutually and the integrity is guaranteed. In our project, there is also an example of using mutex, see the source code jni/uart/ProtocolParser.cpp ： void registerProtocolDataUpdateListener(OnProtocolDataUpdateFun pListener) { Mutex::Autolock _l(sLock); LOGD(\"registerProtocolDataUpdateListener\\n\"); if (pListener != NULL) { sProtocolDataUpdateListenerList.push_back(pListener); } } If you don’t understand the concept of mutex enough, you can get more information about mutexes from the Internet. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"screenshot.html":{"url":"screenshot.html","title":"Screenshot","keywords":"","body":"Screenshot After the product is developed, when writing the manual, you may need a screenshot of the running interface. You can refer to the following code screenshot. Ready Downloadscreenshot.h source files, save them in the project jni directory. Use Reference header file#include \"screenshot.h\" Call the interface to take a screenshot static bool onButtonClick_Button1(ZKButton *pButton) { //Capture the current screen, save it as a bmp picture, and save it to the TF card directory //Each time this function is called, the name of the saved picture is incremented //E.g screenshot01.bmp、screenshot02.bmp、screenshot03.bmp Screenshot::AutoSave(); return false; } The default picture is saved to the TF card, so try to plug in the TF card and take a screenshot. If you need to save it to another location, you can modify the source code yourself. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"data.html":{"url":"data.html","title":"Data Storage","keywords":"","body":"Data storage In some application scenarios, it is necessary to permanently store some information (save data after power-off), such as account numbers, passwords or other configuration information. The characteristics of these data are: the total amount is small, but it needs flexible access. In such cases, there is no need to use a database. We provide a set of simple data storage interfaces, which are stored in the form of key-value pairs. Required header files #include \"storage/StoragePreferences.h\" Main interface // Storage interface static bool putString(const std::string &key, const std::string &val); static bool putInt(const std::string &key, int val); static bool putBool(const std::string &key, bool val); static bool putFloat(const std::string &key, float val); // delete the specified key static bool remove(const std::string &key); // Clear storage data static bool clear(); // Get the interface, if the corresponding key value is not obtained, return the default value of defVal static std::string getString(const std::string &key, const std::string &defVal); static int getInt(const std::string &key, int defVal); static bool getBool(const std::string &key, bool defVal); static float getFloat(const std::string &key, float defVal); [!Warning] This interface saves the data in the flash as a file, so do not write frequently to cause damage to the flash. The size of the partition is limited. The size of the partition varies depending on the model of the screen. Try to keep the data size within 512KB. Usage example Save //Save the string, use \"username\" as the alias, and the value is the name string const char* name = \"zhang san\"; StoragePreferences::putString(\"username\", name); //Save the boolean variable, use \"power\" as the alias, the value is true StoragePreferences::putBool(\"power\", true); //Save the floating point number, using \"temperature\" as the alias, the value is 30.12 StoragePreferences::putFloat(\"temperature\", 30.12); //Save the integer, use \"age\" as the alias, the value is 20 StoragePreferences::putInt(\"age\", 20); Read //Read the value of the \"username\" key, if there is no value, return an empty string std::string name = StoragePreferences::getString(\"username\", \"\"); //Log print the string read LOGD(\"username %s\\n\", username.c_str()); //Read Boolean variable, if there is no value, then specify to return false bool power = StoragePreferences::getBool(\"power\", false); //Read floating point number, if there is no value, specify to return 0 float temperature = StoragePreferences::getFloat(\"temperature\", 0); //Read the integer, if there is no value, return 18 int age = StoragePreferences::getInt(\"age\", 18); Delete//Clear a value individually StoragePreferences::remove(\"username\"); StoragePreferences::remove(\"power\"); StoragePreferences::remove(\"temperature\"); StoragePreferences::remove(\"age\"); //Clear all values StoragePreferences::clear(); Modify If you need to modify a value, just save the key value repeatedly, and the old value will be automatically overwritten powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"vireeprom.html":{"url":"vireeprom.html","title":"Emulated EEPROM","keywords":"","body":"Emulate EEPROM function EEPROM (Electrically Erasable Programmable Read-Write Memory) is a user-changeable read-only memory (ROM), which can be erased and reprogrammed (rewritten) by a higher voltage than normal. Simulation principle This system is based on Linux, with its own file system and balanced erasing algorithm. Write the saved data to NorFlash(Not less than 100,000 erasing and writing times, pay attention not Nandfalsh，NandFlash There are various risks after bad blocks appear). FlyThings OS has reserved /data Partition, Used for user data, in order to facilitate the use of users who are familiar with the operation of the microcontroller,We create a file under the /data partition to simulate an EEPROM space. (The size of the /data partition ranges from 1M or several hundred KB, depending on the specific system version)Does it feel particularly like the STC Dafa MCU that comes out of the domestic alchemy furnace? Scenes to be used Save data after power failure. Implementation steps First create a header file in the jni directory of the project. Select jni under the project, click the right mouse button，Select the header file option in the pop-up context menu，Then name it vireeprom.h and click Finish. Copy the following code completely into the header file just added. (When the header file was created just now, some content may be automatically added and deleted) These codes realize the emulation function of EEPROM. #ifndef JNI_VIREEPROM_H_ #define JNI_VIREEPROM_H_ #include #include #include /** * The storage size of the simulated EEPROM, in bytes, it is recommended not to be too large */ #define EEPROM_SIZE 1024 /** * Actually saved as a file /data/eeprom.eep */ #define EEPROM_FILE \"/data/eeprom.eep\" class VirEEPROM { public: VirEEPROM() { memset(buff_, 0, sizeof(buff_)); file_ = fopen(EEPROM_FILE, \"rb+\"); if (file_) { fread(buff_, 1, EEPROM_SIZE, file_); fseek(file_, 0, SEEK_END); int f_size = ftell(file_); //Adjust the file to a suitable size if (f_size != sizeof(buff_)) { ftruncate(fileno(file_), sizeof(buff_)); fseek(file_, 0, SEEK_SET); fwrite(buff_, 1, sizeof(buff_), file_); fflush(file_); sync(); } } else { file_ = fopen(EEPROM_FILE, \"wb+\"); //Adjust the file to a suitable size ftruncate(fileno(file_), sizeof(buff_)); } } virtual ~VirEEPROM() { if (file_) { fflush(file_); fclose(file_); sync(); } } /** * Return value: less than 0 is failure,greater than 0 is the actual number of bytes written * Parameter: The data pointer that value needs to save, which can be a structure pointer, char*, int*..., size is the size of the data to be saved * Examples of use: * const char buff[]=\"12345678\"; * VIREEPROM->WriteEEPROM(0,buff,sizeof(buff); */ int Write(int addr, const void* value, int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //Oversize return -2; } memcpy(buff_ + addr, value, size); if (0 != fseek(file_, addr, SEEK_SET)) { return -3; } int n = fwrite((char*)value, 1, size, file_); fflush(file_); sync(); return n; } /** * Return value: less than 0 is a failure, greater than 0 is the number of bytes actually read * Parameter: the data pointer to be read by value, which can be a structure pointer, char*, int*..., size is the size of the data to be read *Application examples: * char buff[9]; * VIREEPROM->ReadEEPROM(0,buff,sizeof(buff); */ int Read(int addr,void* value,int size) { if (file_ == NULL) { return -1; } if ((addr >= EEPROM_SIZE) || ((addr + size) > EEPROM_SIZE)) { //Oversize return -2; } memcpy(value, buff_ + addr, size); return size; } /** * return value: * 0 success * Less than 0 failed */ int Erase() { if (file_ == NULL) { return -1; } if (0 != fseek(file_, 0, SEEK_SET)) { return -2; } memset(buff_, 0, sizeof(buff_)); if (sizeof(buff_) != fwrite(buff_, 1, sizeof(buff_), file_)) { return -3; } fflush(file_); sync(); return 0; } static VirEEPROM* getInstance() { static VirEEPROM singleton; return &singleton; } private: unsigned char buff_[EEPROM_SIZE]; FILE* file_; }; #define VIREEPROM VirEEPROM::getInstance() #endif /* JNI_VIREEPROM_H_ */ So far the preparation work has been completed, we will write some examples to test whether it is normal.Open the mainLogic.cc source file and quote the header file just now at the top of the file. #include \"vireeprom.h\" Test code static void onUI_init(){ //The value array, starting from address 0, is written sequentially char value[4] = {1, 2, 3, 4}; VIREEPROM->Write(0, value, sizeof(value)); //Start reading from address 0, read 4 bytes in sequence, and save the read content in buf char buf[4] = {0}; VIREEPROM->Read(0, buf, sizeof(buf)); //Output log LOGD(\"Data read: %02x, %02x, %02x, %02x\", buf[0], buf[1], buf[2], buf[3]); //Clear all eeprom to 0 VIREEPROM->Erase(); } powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"brightness.html":{"url":"brightness.html","title":"Screen backlight operation ","keywords":"","body":"Screen backlight operation Required header files #include \"utils/BrightnessHelper.h\" Dimming Adjust the backlight brightnessThe brightness range is 0 ~ 100 (Note: 0 does not mean turning off the screen) //Adjust the screen brightness to 80 BRIGHTNESSHELPER->setBrightness(80); Get the current brightness valueBRIGHTNESSHELPER->getBrightness(); Switch screen backlight Turn off the screen BRIGHTNESSHELPER->screenOff(); Open screen BRIGHTNESSHELPER->screenOn(); Memory brightness When the system is turned on, the default is to memorize the last adjusted brightness value. If you want to modify it to not remember the brightness or set a fixed brightness value, you can open the properties of the project to modify: powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"system_time.html":{"url":"system_time.html","title":"System Time ","keywords":"","body":"System time Required header files #include \"utils/TimeHelper.h\" Explanation of each field of tm structure struct tm { int tm_sec; /* Seconds-the value range is [0,59] */ int tm_min; /* Minutes-the value range is [0,59] */ int tm_hour; /* Hour-the value range is [0,23] */ int tm_mday; /* The day of the month-the value range is [1,31] */ int tm_mon; /* Month (starting from January, 0 means January)-the value range is [0,11] */ int tm_year; /* Year, its value starts from 1900 */ ... } Get the current date struct tm *t = TimeHelper::getDateTime(); Display time code sample static void updateUI_time() { char timeStr[20]; static bool bflash = false; struct tm *t = TimeHelper::getDateTime(); sprintf(timeStr, \"%02d:%02d:%02d\", t->tm_hour,t->tm_min,t->tm_sec); mTextTimePtr->setText(timeStr); // Pay attention to modify the control name sprintf(timeStr, \"%d year %02d month %02d day\", 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday); mTextDatePtr->setText(timeStr); // Pay attention to modify the control name static const char *day[] = { \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" }; sprintf(timeStr, \"Week %s\", day[t->tm_wday]); mTextWeekPtr->setText(timeStr); // Pay attention to modify the control name } Set time code sample // Use tm structure to set time static void setSystemTime() { struct tm t; t.tm_year = 2017 - 1900; //Year t.tm_mon = 9 - 1; //Month t.tm_mday = 13; //Day t.tm_hour = 16; //Hour t.tm_min = 0; //Minute t.tm_sec = 0; //second TimeHelper::setDateTime(&t); } // Or use a string to set the time date str format: 2017-09-13 16:00:00 TimeHelper::setDateTime(\"2017-09-13 16:00:00\"); For the complete source code, see the DateDemo project in the sample code package powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"machine_unique_id.html":{"url":"machine_unique_id.html","title":"Equipment unique ID ","keywords":"","body":"Device unique ID code How to read Required header files#include \"security/SecurityManager.h\" Read device ID // device id is 8 bytes unsigned char devID[8]; // Returns true on success, false on failure bool ret = SECURITYMANAGER->getDevID(devID); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"tf.html":{"url":"tf.html","title":"TF Card","keywords":"","body":"TF card When the TF card is inserted, the system will automatically mount as the /mnt/extsd directory.If you want to read and write files in the TF card, you can read and write the directory. File path If there is a test.txt file in the root directory of your TF card, then on our machine, the absolute path of this file is /mnt/extsd/test.txt. Notes for writing TF card To write files to the TF card, try to follow the following operation sequence, otherwise it may cause the situation that it cannot be written. Insert card->Power on->Open file->Read and write files->fflush()->Close file->sync()->Unplug card In other words, if there is a need to write to a TF card, try to ensure that the TF card has been inserted before turning on the computer, rather than temporarily inserting the TF card when it is turned on. And after writing, pay attention to synchronization issues. Determine whether to mount the TF card #include \"os/MountMonitor.h\" if (MOUNTMONITOR->isMount()) { //TF card has been mounted } else { //TF card is not mounted } [!Note] The /mnt/extsd directory always exists, regardless of whether the TF card is insertedWithout the TF card inserted, if you read and write the directory, the content will be saved in the memory, but it will disappear if the power is off. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"mount.html":{"url":"mount.html","title":"Plug-in/out card monitoring","keywords":"","body":"TF card plug-in monitor By registering the monitoring interface, we can know the status of the TF card; here we first need to implement our own monitoring class: #include \"os/MountMonitor.h\" class MyMountListener : public MountMonitor::IMountListener { public: virtual void notify(int what, int status, const char *msg) { switch (status) { case MountMonitor::E_MOUNT_STATUS_MOUNTED: // Insert // msg is the mount path LOGD(\"mount path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF card has been inserted\"); break; case MountMonitor::E_MOUNT_STATUS_REMOVE: // Remove // msg is the uninstall path LOGD(\"remove path: %s\\n\", msg); mMountTextviewPtr->setText(\"TF card has been removed\"); break; } } }; Define the listening object: static MyMountListener sMyMountListener; Register to listen: MOUNTMONITOR->addMountListener(&sMyMountListener); When we no longer need to monitor, we need to remove the monitor: MOUNTMONITOR->removeMountListener(&sMyMountListener); For specific operations, please refer to the MountDemo project in Sample Code powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"gpio.html":{"url":"gpio.html","title":"GPIO operation ","keywords":"","body":"GPIO operation [!Note] If you purchased SV50PB module or SV50PC module, you need to enable it in Module Configuration GPIO function, and then re-upgrade the system, it can be used normally. More Usage Tutorial。 Introducing header files #include \"utils/GpioHelper.h\" Operation function class GpioHelper { public: /** * Set the pin to input mode and return to the high and low state of the pin * @param pPin pin name * @return -1 operation failed * 1 high level * 0 low level */ static int input(const char *pPin); /** * Set the pin to output mode, and specify the output high or low level * @param pPin pin name * @param val 1 high level * 0 low level * @return -1 failed * 0 success */ static int output(const char *pPin, int val); }; Definition of the name of each platform operable pin Z11S platform Currently the platform only retains 3 groups of io ports for operation. // 3 groups of io port definitions #define GPIO_PIN_B_02 \"B_02\" #define GPIO_PIN_B_03 \"B_03\" #define GPIO_PIN_E_20 \"E_20\" #include \"utils/GpioHelper.h\" // read B02 io port status GpioHelper::input(GPIO_PIN_B_02); // B02 io port outputs high level GpioHelper::output(GPIO_PIN_B_02, 1); SV50PB module The following 12 groups of io ports can be operated: // SV50PB #define SV50PB_PIN7 \"PIN7\" #define SV50PB_PIN8 \"PIN8\" #define SV50PB_PIN9 \"PIN9\" #define SV50PB_PIN10 \"PIN10\" #define SV50PB_PIN11 \"PIN11\" #define SV50PB_PIN12 \"PIN12\" #define SV50PB_PIN13 \"PIN13\" #define SV50PB_PIN14 \"PIN14\" #define SV50PB_PIN23 \"PIN23\" #define SV50PB_PIN24 \"PIN24\" #define SV50PB_PIN26 \"PIN26\" #define SV50PB_PIN27 \"PIN27\" #include \"utils/GpioHelper.h\" // ead PIN7 io port status GpioHelper::input(SV50PB_PIN7); // PIN7 io port outputs high level GpioHelper::output(SV50PB_PIN7, 1); SV50PC module The following 25 groups of io ports can be operated: // SV50PC #define SV50PC_PIN2 \"PIN2\" #define SV50PC_PIN3 \"PIN3\" #define SV50PC_PIN4 \"PIN4\" #define SV50PC_PIN5 \"PIN5\" #define SV50PC_PIN6 \"PIN6\" #define SV50PC_PIN7 \"PIN7\" #define SV50PC_PIN8 \"PIN8\" #define SV50PC_PIN9 \"PIN9\" #define SV50PC_PIN10 \"PIN10\" #define SV50PC_PIN11 \"PIN11\" #define SV50PC_PIN13 \"PIN13\" #define SV50PC_PIN14 \"PIN14\" #define SV50PC_PIN15 \"PIN15\" #define SV50PC_PIN16 \"PIN16\" #define SV50PC_PIN17 \"PIN17\" #define SV50PC_PIN18 \"PIN18\" #define SV50PC_PIN22 \"PIN22\" #define SV50PC_PIN24 \"PIN24\" #define SV50PC_PIN25 \"PIN25\" #define SV50PC_PIN26 \"PIN26\" #define SV50PC_PIN27 \"PIN27\" #define SV50PC_PIN28 \"PIN28\" #define SV50PC_PIN29 \"PIN29\" #define SV50PC_PIN30 \"PIN30\" #define SV50PC_PIN31 \"PIN31\" #include \"utils/GpioHelper.h\" // read PIN7 io port status GpioHelper::input(SV50PC_PIN7); // PIN7 io port outputs high level GpioHelper::output(SV50PC_PIN7, 1); 86 boxes The following 4 groups of io ports can be operated: // 86 Box #define Z6X86BOX_PIN7 \"PIN7\" // corresponds to IO1 on the hardware #define Z6X86BOX_PIN8 \"PIN8\" // IO2 #define Z6X86BOX_PIN9 \"PIN9\" // IO3 #define Z6X86BOX_PIN10 \"PIN10\" // IO4 #include \"utils/GpioHelper.h\" // read PIN7 io port status GpioHelper::input(Z6X86BOX_PIN7); // PIN7 io port outputs high level GpioHelper::output(Z6X86BOX_PIN7, 1); Sample The complete source code can be found in the GpioDemo project in Sample Code Package powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"spi.html":{"url":"spi.html","title":"SPI operation ","keywords":"","body":"SPI operation [!Note] Currently only SV50PB module supports this function. Before use, you need to enable the SPI function in the module configuration and upgrade with the generated new system package before it can be used normally. More about the module Using Tutorial。 Introduce header files #include \"utils/SpiHelper.h\" Specific operation // Required header files #include \"utils/SpiHelper.h\" static void testSpi() { uint8_t tx[512], rx[512]; /** * Define variables * * Parameter 1: SPI bus number * Parameter 2: Mode, optional values: SPI_MODE_0, SPI_MODE_1, SPI_MODE 2, SPI_MODE_3 * Parameter 3: SPI clock frequency, 50M is set here * Parameter 4: How many bits does a word have, default value: 8 * Parameter 5: Bit order, true: means low bit first, false: means high bit first; default value: false, high bit first */ SpiHelper spi(1, SPI_MODE_0, 50*1000*1000, 8, false); memset(tx, 0, 512); memset(rx, 0, 512); tx[0] = 0x4B; /** * Simplex write * * Parameter 1: Write data address * Parameter 2: Data length */ if (!spi.write(tx, 5)) { LOGD(\"spi tx error!\\n\"); } /** * Simplex read * * Parameter 1: Read data address * Parameter 2: Data length */ if (!spi.read(rx, 8)) { LOGD(\"spi rx error!\\n\"); } for (int i = 0; i For other interface operations, please refer to the header file notes. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"i2c.html":{"url":"i2c.html","title":"I2C operation ","keywords":"","body":"I2C operation [!Note] Currently only SV50P series modulessupport this function. Before use, you need to enable the TWI function in Module Configuration, and upgrade with the new system package generated before it can be used normally. MoreUsage Tutorialabout modules. Introducing header files #include \"utils/I2CHelper.h\" Specific operations #include \"utils/I2CHelper.h\" #define CFG_L 0x47 #define CFG_H 0x80 #define VER_L 0x41 #define VER_H 0x81 static void testI2C() { uint8_t tx[512], rx[512]; memset(tx, 0, 512); memset(rx, 0, 512); /** * Define variables * * Parameter 1: i2c bus number * Parameter 2: Slave address, be sure to pay attention to the 7bit address * Parameter 3: Timeout time, unit: ms * Parameter 4: Number of retries: ms */ I2CHelper i2c(0, 0x5e, 1000, 5); tx[0] = CFG_H; tx[1] = CFG_L; /** * Simplex writing * * Parameter 1: Write data address * Parameter 2: Data length */ if (!i2c.write(tx, 2)) { LOGD(\"i2c tx cfg error!\\n\"); } /** * Single work * * Parameter 1: Read data address * Parameter 2: Data length */ if (!i2c.read(rx, 1)) { LOGD(\"i2c rx cfg error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", CFG_H, CFG_L, rx[0]); memset(rx, 0, 512); /** * Half-duplex transmission, that is, shared read and write, no stop signal in the middle * * Parameter 1: Write data address * Parameter 2: Write data length * Parameter 3: Read data address * Parameter 4: Read data length */ if (!i2c.transfer(tx, 2, rx, 1)) { LOGD(\"i2c i2c_transfer cfg error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", CFG_H, CFG_L, rx[0]); tx[0] = VER_H; tx[1] = VER_L; if (!i2c.write(tx, 2)) { LOGD(\"i2c tx ver error!\\n\"); } if (!i2c.read(rx, 1)) { LOGD(\"i2c rx ver error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", VER_H, VER_L, rx[0]); memset(rx, 0, 512); if (!i2c.transfer(tx, 2, rx, 1)) { LOGD(\"twi i2c_transfer ver error!\\n\"); } LOGD(\"i2c reg[0x%x%x]=%x\\n\", VER_H, VER_L, rx[0]); } For other interface operations, please refer to the header file notes. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"adc.html":{"url":"adc.html","title":"ADC operation ","keywords":"","body":"ADC operation [!Note] Currently only SV50P series modules support this function. Before use, you need to enable the ADC function in Module Configuration and upgrade with the new system package generated before it can be used normally. More Usage Tutorial。 Introduce header files #include \"utils/AdcHelper.h\" Specific operation #include \"utils/AdcHelper.h\" static void testAdc() { /** * Set the adc enable state * * @param true enable * false forbidden * The default is the enabled state */ AdcHelper::setEnable(true); for (int i = 0; i powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"reboot.html":{"url":"reboot.html","title":"Reboot system","keywords":"","body":"Reboot the system The following code can be used to actively restart the system machine. Required header files #include #include Code //Synchronize data and save cached data to prevent data loss sync(); reboot(RB_AUTOBOOT); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"i18n.html":{"url":"i18n.html","title":"Multi-language translation","keywords":"","body":"Multi-language translation FlyThings provides multi-language translation function to facilitate internationalization. How to add translation First, create a translation file through the new wizard. After creation, a subfolder named i18n will be generated under the project, and the default tr translation file will be added. The file name of each tr file represents the corresponding language (do not modify the file name at will). Double-click to open the tr file, you can see that the content is in xml format. Each string tag represents a translation. The name attribute is used to give this translation an alias (it is recommended to name it as a combination of English, numbers, and underscores), and then use the alias to represent the string in the code. Note: In the same configuration file, the alias cannot be repeated. Hello World! Hello, FlyThings If you want to wrap in the string, use &#x000A;escape, as follows: The first line &#x000A;The second line As shown above, we will alias the string “Hello, world!” as hello_world, and alias the string hello, FlyThings as hello_flythings, if we want to add For more translations, we just need to add the string tag according to the example. Since it is a multi-language translation, we need to add the same name tag to each language. In this way, when we switch languages, the system will replace the content according to the name attribute. After the configuration file is added, we can use it in the ui file and code. Open the ui file, we can enter @hello_world in the text property (we use the @ symbol followed by the alias in the configuration file to indicate that this string needs to be translated). Then, we download and run, you can see that the content of the text has been automatically translated into Hello, world！ We can also translate strings in the code. Previously, we used the setText() member method to set the string. If we need automatic translation, we need to use the setTextTr() member method. E.g: /** * Triggered when the interface is constructed */ static void onUI_init() { //The setTextTr parameter is the name value in the translation configuration file. Note: The string passed in here does not need to be preceded by the @ symbol mTextview1Ptr->setTextTr(\"hello_world\"); } Download and run, we can see that the content has been replaced with the corresponding string. We can also get the value corresponding to the current language name, and then do some operations similar to splicing, etc.: #include \"manager/LanguageManager.h\" static bool onButtonClick_Button1(ZKButton *pButton) { //LOGD(\" ButtonClick Button1 !!!\\n\"); std::string hello = LANGUAGEMANAGER->getValue(\"hello\"); std::string world = LANGUAGEMANAGER->getValue(\"world\"); std::string ret = hello + \" \" + world; LOGD(\"ret: %s\\n\", ret.c_str()); return false; } How to switch languages The default language of the system is zh_CN （Simplified Chinese）。 You can open the system's built-in language switch interface to select a language. Add the following code to open the interface. EASYUICONTEXT->openActivity(\"LanguageSettingActivity\"); Or use the following API to switch languages freely. EASYUICONTEXT->updateLocalesCode(\"zh_CN\"); //Set to Chinese EASYUICONTEXT->updateLocalesCode(\"en_US\"); //Set to Englisg EASYUICONTEXT->updateLocalesCode(\"ja_JP\"); //Set to Japanese Font requirements Multilingual translation requires font support. If the text does not exist in the font, it will be displayed abnormally. Therefore, the font must contain text in multiple languages. The default font of the system is a simplified version, it is recommended to add a custom font, see font cutting。 Sample For the complete source code, please see the TranslationDemo project in Sample Code Package powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"adb_debug.html":{"url":"adb_debug.html","title":"ADB debugging ","keywords":"","body":"ADB fast download and debug FlyThings can quickly download programs to the machine via USB cable or WIFI. Specific steps are as follows: First, make sure that the computer and the machine are successfully connected. There are two ways to connect: [!Note] Note: If you buy a version with WIFI function, you can only connect via WIFI, and the USB cable cannot be used; The Ethernet version prefers to use the USB cable connection. If the USB connection is unsuccessful, the WIFI connection (ie network connection) is used. If the connection fails, please contact us. Similarly, if you buy a version without WIFI function, you can only connect via USB cable. You can see if the USB cable is connected successfully Use a USB cable to connect the computer and the machine. If the computer can recognize the machine as an Android device, the connection is normal. If you can't connect normally, the computer prompts a driver problem, you can try Download Update Driver。 Connect via WIFI. (This method requires the machine to support WIFI function.)First enter the WIFI setting interface of the machine, and connect the machine to the same network as the computer, that is, the computer and the machine must be connected to the same WIFI. (If a different network will cause the subsequent download procedure to fail). After the network connection is successful, click the menu button in the upper right corner of the WIFI setting interface to view the IP address of the machine, then open the FlyThings IDE development tool, and on the menu bar, select the menu Debug Configuration -> ADB IP Configuration, Fill in the machine IP and select OK. The tool will try to connect with the machine. If it prompts that the connection is successful, it means normal. If the prompt fails, you need to check whether the IP is correct? Is the machine connected to WIFI normal? WIFI setting interface Operation process animation Download and debug After completing the previous step, you can download the program directly. In the Project Explorer, select the project name, right-click, and select the Download and Debug menu in the pop-up menu. After selection, it will automatically compile once. After the compilation is successful, download the program to the machine. If an error is prompted, then you can see that the machine program has been updated. Similarly, after selecting the item, you can also use the shortcut keys Ctrl + Alt + R to download and debug. View print log Precautions If an Android phone is connected to the computer, it may conflict with the machine and cause the download to fail. When using it, it is recommended to disconnect the Android phone temporarily. Note ： Run the program in this way, and the program cannot be solidified into the machine. If you unplug the TF card or restart after a power failure, the program will automatically resume. If you want the firmware to be stored in the device, you can select make upgrade image and then upgrade. Use ADB on the command line We can quickly view the status and log of the device through ADB commands.First select an item arbitrarily, then find the menu bar at the top, and select Debug Configuration -> Open System Command Line, Now we can enter the command we want to execute in the pop-up command line. Then press Enter to execute the command.Here are some commonly used commands. adb logcat -v time powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"logcat.html":{"url":"logcat.html","title":"View print log ","keywords":"","body":"View log Add log Required header files#include \"utils/Log.h\" FlyThings' printing uniformly calls LOGD or LOGE macro output, and the usage method is the same as that of C language printf; there are examples (commented out by default, open when needed) of calling in the code generated by default: ```c++ static bool onButtonClick_Button1(ZKButton *pButton) { LOGD(\"onButtonClick_Button1\\n\"); return true; } ``` View print log View via command line (recommended) Find the top menu of the software, and then open the menu Debug configuration->Open system command line If you use a USB cable to connect to the device, directly enter adb shell logcat -v time in the command line and then enter the Enter key. If the computer is connected to the device normally, you will see all the log information of the device.If you are using a network connection, such as WIFI, Ethernet, you have to check the device first, get the device's IP address, and then enter adb connect 192.168.1.123 in the command line (change the IP address yourself), and then Enter the Enter key, if the IP is correct and the connection is normal, you will see this message: connected to 192.168.1.123:5555,After the normal connection, enter adb shell logcat -v time and enter the Enter key to see all the log information. You can use the Ctrl + C key combination to stop the log display. View in UI interface (deprecated) After connecting ADB , you can view the print log of the program through our tool. The specific steps are as follows: On the menu bar, select Debug Configuration -> Switch Log Window, the tool will switch to another interface. 在In the lower left corner of the new interface, select LogCat, if the connection is normal, in the red box area on the right, you will see the machine's print log. If you want to return to the code editing interface, click the FlyThings icon in the upper right corner of the tool. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"start_from_sdcard.html":{"url":"start_from_sdcard.html","title":"Start the program from TF card ","keywords":"","body":"Start the program from the TF card When we cannot use ADB to download the program, we can also download the program to the TF card and start the program from the TF card. [!Note] Note: TF card only supports FAT32 format Specific steps First we have to configure the output directory of the program. Find this button on the toolbar Click the black drop-down arrow next to it, and select Path Configuration in the pop-up menu In the pop-up box, select the drive letter of the TF card (please ensure that the TF card can be used normally), and click OK. In the above steps, we have configured the output directory, and now click the button in the figure below to start compiling, and it will package and output the compiled results to the configured drive letter. After the operation is successful, directories and files such as EasyUI.cfg, ui, lib, and font will be generated under the configured drive letter. Pull out the TF card, insert it into the machine, and power on the machine again. At this time, when the system detects the file in the TF card, it will start the program in the card instead of the program in the system. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"update_logo.html":{"url":"update_logo.html","title":"Upgrade boot LOGO ","keywords":"","body":"Boot LOGO Update boot logo First prepare a boot LOGO picture, the picture must meet the following conditions: The picture name is fixed as boot_logo.JPG. Note that the file suffix is capitalized JPG; other names will not be recognized. Users of Windows system computers must open the \"Show Extensions\" function of the Explorer to ensure that the complete file name is correct. The picture resolution must be exactly the same as the screen resolution, in pixels. The picture should not be too large, otherwise the upgrade will fail. It is best to keep it within 100KB , but the size supported by different system versions is also different.Since the supported compression algorithms are limited when the system is turned on, the size displayed on the computer does not represent the occupied size after decompression and recompression in the system. During the upgrade, if it prompts \"The image is larger than the partition size\", it means that the picture is still too large for the system version. The boot LOGO picture should be as simple as possible It is strongly recommended to use a solid color as the background, plus simple icons or text, which can effectively reduce the picture size.; Copy boot_logo.JPG to the root directory of the TF card Insert the TF card into the machine, and the device will automatically pop up an upgrade prompt. Select boot_logo and click upgrade. The system will shut down and restart after the upgrade is complete. Pull out the TF card at this time. Prevent the system from being upgraded again. Richer \"boot LOGO\" The boot LOGO has limited functions. If you have more abundant needs, you can use the following methods to achieve Use a pure black picture to upgrade to the boot LOGO. The first interface of the application is regarded as your \"boot LOGO\" Try not to have time-consuming operations on the first interface of the application, otherwise it will slow down the startup time of the program. Extend the display time of the boot LOGO The time to turn on the LOGO depends on the startup time of the application. After the first interface of the application is fully loaded, the boot LOGO will be overwritten. So as long as the sleep operation is added to the onUI_init function of the first interface, the display time of the boot LOGO can be extended in disguised form. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"make_image.html":{"url":"make_image.html","title":"Make upgrade image file ","keywords":"","body":"Make upgrade image file In the previous tutorial, we used the Download and Debug menu to run the program, but it does not solidify the program into the device. If you unplug the TF card or power off and restart, the program will Automatic recovery. If you want to firm the program into the device, we can package the program into an upgrade file. After the device is upgraded, the program can be solidified inside the device. Once the power is turned on, the program will be started by default. Operation specific steps First we need to configure the output directory of the mirror. Find this button on the toolbar Click the black drop-down arrow next to it, and select Path Configuration in the pop-up menu In the pop-up box, select the output directory of the image file, and click OK. In the above steps, we have configured the output directory. Now click the button in the figure below to start compiling. It will package the compilation result and generate the update.img file and output it to the configured directory. fter the update.img file is successfully generated, copy it to the TF card (Note: Before use, please format the TF card in FAT32 format), and insert the TF card into the machine. Power on again. At this time, when the system detects the files in the TF card, it will start the upgrade program. In the interface shown in the figure below, check the upgrade items and click Upgrade. After the upgrade is completed, remove the upgrade card in time to prevent repeated upgrades. [!NOTE] Note: TF card only supports FAT32 format If the screen is damaged or the touch is inaccurate, which makes it impossible to upgrade by clicking the button, then in this case, we can useAuto Upgradethis way Upgrade our system. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"autoupgrade.html":{"url":"autoupgrade.html","title":"Autoupgrade","keywords":"","body":"Automatic card upgrade In the case of screen damage or inaccurate touch, if we want to upgrade the system, we can create a file in the root directory of the TF card zkautoupgrade （Note: The file has no extension） In this way, the machine will automatically check the upgrade item after the card is inserted, and the upgrade will start after 2s by default; if you need to control other time before starting the upgrade, we can open the zkautoupgrade file and fill in the corresponding number, the unit is seconds; after the upgrade is complete , The system restarts, remember to pull out the TF card to prevent automatic upgrade again. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"sd_boot.html":{"url":"sd_boot.html","title":"Making a swipe card ","keywords":"","body":"Make credit card [!Warning] **Note: The capacity of the TF card supports up to 16G. The oversized machine cannot recognize the TF card and cannot be upgraded.For the latest software flashing package, please go to QQ group: 371608200 group sharing to download, pay attention to find the software of the corresponding version of your machine, see label on the back of the machine, otherwise the upgrade may cause an abnormality! Download the computer flashing tool Select the TF card drive letter on the computer Specify the upgraded image file Click to burn After the programming is successful, pull out the TF card, insert the machine, and then power on again to upgrade [!Warning] Note: After the upgrade progress bar is completed, you need to pull out the TF card in time to prevent repeated upgrades after the machine restarts Recovery card steps Select the TF card drive letter on the computer Click to restore card After formatting, the card will resume normal use powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"remote_update.html":{"url":"remote_update.html","title":"Remote Update","keywords":"","body":"Remote upgrade Currently, the system does not have an interface for direct remote upgrade.But we can understand the TF card detection and upgrade mechanism, and then add some of our own code to achieve the purpose of remote upgrade.We first introduce the general upgrade process of inserting a TF card. TF card detection upgrade process When the system is started or the TF card is inserted, if TF card is mounted normally, The system will check whether there is an update.img file in the TF card root directory (in the system, the TF card root directory is mapped to /mnt/extsd).If it exists, further verify whether the file meets the requirements. If it passes the verification, an upgrade prompt interface will pop up, and the user can choose to upgrade.If it does not exist, the detection process ends and there is no action on the interface. Implementation steps First we have to download the upgrade image update.img.Under normal circumstances, downloading files through the HTTP protocol is the easiest way, of course, you can also choose other protocols according to the actual situation.After downloading, save the image file to the TF card directory /mnt/extsd/. [!Note] If there is no TF card inserted in the machine, this directory can still be written because it is stored in the memory. Limited by the memory size, if the image file is too large, it will cause abnormal device operation or upgrade failure.If you have inserted a TF card, you can ignore the memory size problem. Call upgrade detection functionFirst download the UpgradeMonitor.h source file and save it to the jni/include/os directory of the project. Then call the interface to detect the upgrade. #include \"os/UpgradeMonitor.h\" //Actively detect whether there is a correct update.img file in the /mnt/extsd directory, //If yes, an upgrade prompt box will pop up, //If not, nothing happens UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd\"); After the upgrade prompt interface pops up, the user can choose whether to upgrade.So far, the remote upgrade function has been fully realized. Automatically update after downloading the file If you want to force the update after downloading the upgrade file, you only need to refer to the Auto Upgrade document and create the zkautoupgrade file with the code. Avoid repeated upgrades In the above steps, we save the image file in the /mnt/extsd/ directory. After a successful upgrade, the machine will automatically restart. At this time, the system will perform the regular upgrade detection process. Due to the existence of the image file, the upgrade prompt interface pops up again, resulting in repeated upgrades. Solution When downloading the image file, save it to a directory other than /mnt/extsd/, for example: /mnt/extsd/temp/, In addition, the parameters of the call detection function are also modified synchronously. UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); Sample reference Complete sample downloadThe sample simply implements the http client to download files, refer to the http part of the source code. Downloading files is a time-consuming operation, it is recommended to put them in a separate thread, so as not to affect the immediate response of the interface. Key code class DownloadThread : public Thread { protected: virtual bool threadLoop(){ http::HttpClient http; mTextview1Ptr->setText(\"download the upgrade file\"); //Create a save path for the upgrade file system(\"mkdir /mnt/extsd/temp\"); //Modify here to the real service IP string err = http.Download(\"192.168.1.1/update.img\", 80, \"/mnt/extsd/temp/update.img\"); mTextview1Ptr->setText(err); if (err.empty()) { UpgradeMonitor::getInstance()->checkUpgradeFile(\"/mnt/extsd/temp\"); } mButton1Ptr->setInvalid(false); return false; }; }; Server implementationFor the convenience of testing, the example includes a http.exe, which is a static file service. Put the made upgrade image file update.img and http.exe in the same folder, then double-click on the computer to execute http.exe, as long as the network is normal, you can download the file in the same directory through the website Mirror file.E.g:http://192.168.1.1/update.img(Please pay attention to modify the IP address to the current IP of the computer) After the server is started, run the sample code to test the remote upgrade. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"demo_download.html":{"url":"demo_download.html","title":"Code sample","keywords":"","body":"Sample download [!Note] Please download the sample code of the platform corresponding to the screen first. If it is not, you can download a copy, and then refer to Convert Project Platform to convert by yourself Z6S or z6 platform 480x272 control sample 480x854 control sample 800x480 control sample 1024x600 control sample Third-party library migration code sample(Modbus、Sqlite、CURL HTTP、Mqtt) Scenario application sample(calendar, form, file browser) Z11S platform 480x272 control sample 480x854 control sample 800x480 control sample 1024x600 control sample Third-party library migration code sample (Modbus、Sqlite、CURL HTTP、Mqtt) Scenario application sample (calendar, form, file browser) A33NOR platform 480x272 control sample 480x854 control sample 800x480 control sample 1024x600 control sample Third-party library migration code sample (Modbus、Sqlite、CURL HTTP、Mqtt) Scenario application sample (calendar, form, file browser) Factory sample code Code sample powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"file_read_write.html":{"url":"file_read_write.html","title":"File read and write","keywords":"","body":"File read and write f you are familiar with file reading and writing in standard C language, you can read and write files in standard C language. For some commonly used file read and write operations, we made a simple package based on the C language file read and write interface, which is convenient to use. If necessary, you can follow the steps to integrate the source code into your own project. /** * Write a file, if the file exists, it will be overwritten, if the file does not exist, create a new file and write the content * Return true if successful */ bool WriteFile(const char* filename, const void* data, int len); /** * Append content at the end of the file, if the file does not exist, create a new file first, and then write the content * Return true if successful */ bool AppendFile(const char* filename, const void* data, int len); /** * 读文件 * Read file * Success, save the file in the data of string in binary form, read the binary content with string.data() * Return an empty string on failure */ string ReadFile(const char* filename); Porting steps Create a new folder under the jni folder of the project and name it io Downoad ioutil.h 、ioutil.cpp Two files, save them in the io folder. How to use Introduce header files#include \"io/ioutil.h\" Write file //Write the string \"0123456789\" into the file 123.txt const char* filename = \"/mnt/extsd/123.txt\"; //The path where the file is saved const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); Additional files //Append the content to the end of the file, if the specified file does not exist, create a new file. const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); Read file const char* filename = \"/mnt/extsd/123.txt\"; //Read all the contents of the file and save it in content string content = ioutil::ReadFile(filename); //Output each byte read to the log in hexadecimal for (size_t i = 0 ; i [!Warning] The ioutil::ReadFilefunction reads all the contents of the file into the memory. If the specified file is too large, it will cause insufficient memory and may cause an exception. Write files continuously, suitable for writing large files const char* filename = \"/mnt/extsd/123.txt\"; const char* append_str = \"abcdefgh\"; ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i Continuous reading, suitable for processing large files const char* filename = \"/mnt/extsd/123.txt\"; ioutil::Reader r; if (r.Open(filename)) { char buf[1024] = {0}; while (true) { int n = r.Read(buf, sizeof(buf)); if (n > 0) { //There is read content, output every byte for (int i = 0; i Test code /** * Triggered when the interface is constructed */ static void onUI_init() { //Write file const char* filename = \"/mnt/extsd/123.txt\"; const char* str = \"0123456789\"; ioutil::WriteFile(filename, str, strlen(str)); string content = ioutil::ReadFile(filename); LOGD(\"Read bytes%d, content:%s\", content.size(), content.c_str()); //Append file const char* append_str = \"abcdefgh\"; ioutil::AppendFile(filename, append_str, strlen(append_str)); content = ioutil::ReadFile(filename); LOGD(\"Read bytes%d, content:%s\", content.size(), content.c_str()); ioutil::Writer w; if (w.Open(filename, false)) { for (int i = 0; i 0) { //There is read content, output every byte for (int i = 0; i powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"net.html":{"url":"net.html","title":"Socket Programming","keywords":"","body":"socket network programming If you are familiar with Linux socket programming, you can perform network programming according to the standard Linux socket programming interface. For some commonly used socket programming implementation operations, for example, to establish a TCP client, we have made a simple package based on the standard interface of Linux, which is convenient to use. If necessary, you can follow the steps to integrate the source code into your own project. Porting steps Create a new folder under the jni folder of the project and name it net Download net.h 、net.cpp Two files, save them to the net folder. How to use TCP client Introduce header files#include \"net/net.h\" Usage example /*Use TCP protocol to connect to port 80 of the domain name www.baidu.com, and change the domain name to IP.*/ net::Conn* conn = net::Dial(\"tcp\", \"www.baidu.com:80\"); //net::Conn* conn = net::Dial(\"tcp\", \"14.215.177.38:80\"); if (conn) { byte buf[2048] = {0}; const char* req = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"; //send conn->Write((byte*)req, strlen(req)); while (true) { //Read, timeout 1000ms int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"Read %d bytes: %s\", n, buf); } else if (n == 0) { LOGD(\"Normal disconnection\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"Read timeout\"); } else { LOGD(\"Error\"); break; } } //Close the connection conn->Close(); //Release memory delete conn; conn = NULL; UDP client Introduce header files #include \"net/net.h\" Usage example//Use udp protocol to connect IP: 192.168.1.100 port 8080 net::Conn* conn = net::Dial(\"udp\", \"192.168.1.100:8080\"); if (conn) { byte buf[2048] = {0}; const char* req = \"hello\"; conn->Write((byte*)req, strlen(req)); while (true) { //Read, timeout 1000ms int n = conn->Read(buf, sizeof(buf) - 1, 1000); if (n > 0) { buf[n] = 0; LOGD(\"Read %d bytes: %s\", n, buf); } else if (n == 0) { LOGD(\"Normal disconnection\"); break; } else if (n == net::E_TIMEOUT) { LOGD(\"Read timeout\"); //Set timeout here to exit break; } else { LOGD(\"Error\"); break; } } //Close the connection conn->Close(); //Release memory delete conn; conn = NULL; } powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"http.html":{"url":"http.html","title":"HTTP","keywords":"","body":"HTTP If you need to implement HTTP Get, POST requests, libcurl is a good choice, it is a C language open source library. For ease of use, we have compiled the library. Directly download the CURLDemo project in the third-party transplant code sample of Sample Code. [!Note] Be sure to download the version corresponding to the screen platform, otherwise it will not run. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"transcoding.html":{"url":"transcoding.html","title":"Transcoding","keywords":"","body":"UTF-8 encoding Currently, the system only supports UTF-8 encoding, such as text boxes and other controls, and can only display UTF-8 encoded strings normally. If you want to display other codes normally, you need to transcode by yourself. sconv Sconv is an open source library for transcoding. We use it to convert between utf-8 and gbk. Ready Download sconv source files，And unzip it to our project jni folder. UTF-8 to GBK Reference header file #include #include \"utf8cover/sconv.h\" Add function string utf8_to_gbk(const char* utf8_str) { int size = sconv_utf8_to_unicode(utf8_str, -1, NULL, 0); wchar *unicode = new wchar[size / 2 + 1]; size = sconv_utf8_to_unicode(utf8_str, -1, unicode, size); unicode[size / 2] = 0; size = sconv_unicode_to_gbk(unicode, -1, NULL, 0); char *ansi_str = new char[size + 1]; size = sconv_unicode_to_gbk(unicode, -1, ansi_str, size); ansi_str[size] = 0; string gbk(ansi_str, size); delete[] ansi_str; delete[] unicode; return gbk; } Use the function just now to perform encoding conversion, an example is as follows:const char* utf8_str = \"This is utf8 encoding\"; string gbk = utf8_to_gbk(utf8_str); LOGD(\"After conversion, a total of %d bytes\", gbk.size()); for (size_t i = 0; i GBK to UTF-8 Reference header file #include #include \"utf8cover/sconv.h\" Add function string gbk_to_utf8(const char* gbk_str) { int size = sconv_gbk_to_unicode(gbk_str, -1, NULL, 0); wchar *unicode_str = new wchar[size / 2 + 1]; size = sconv_gbk_to_unicode(gbk_str, -1, unicode_str, size); unicode_str[size / 2] = 0; size = sconv_unicode_to_utf8(unicode_str, -1, NULL, 0); char *utf8_str = new char[size + 1]; size = sconv_unicode_to_utf8(unicode_str, -1, utf8_str, size); utf8_str[size] = 0; string utf8(utf8_str, size); delete[] unicode_str; delete[] utf8_str; return utf8; } Use the function just now to perform encoding conversion, an example is as follows://To facilitate testing, here is a gbk encoding array whose content is \"This is gbk encoding\" const char gbk_str[] = {0xd5, 0xe2, 0xca, 0xc7, 0x67, 0x62, 0x6b, 0xb1, 0xe0, 0xc2, 0xeb,0}; string utf8 = gbk_to_utf8(gbk_str); LOGD(\"After conversion, a total of %d bytes\", utf8.size()); LOGD(\"The content is: %s\", utf8.c_str()); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"json.html":{"url":"json.html","title":"JSON","keywords":"","body":"JSON construction and analysis The default project already includes the open source cppjson library, which can be used directly. Steps for usage Quote header file #include \"json/json.h\" Construct JSON string Json::Value root; //Add integer value root[\"int\"] = 1; //Add string root[\"str\"] = \"hello\"; /*Due to the accuracy printing problem of floating-point numbers, it is not recommended to use them, try to convert to integers*/ root[\"float\"] = 3.14f; //Add array Json::Value array; array.append(\"123\"); array.append(\"456\"); array.append(\"789\"); root[\"array\"] = array; //json nesting Json::Value sub; sub[\"int\"] = 1; sub[\"str\"] = \"sub str value\"; root[\"subJson\"] = sub; LOGD(\"The generated json string is: \"); LOGD(\"%s\", root.toStyledString().c_str()); Parse JSON //Parse json Json::Reader reader; Json::Value root2; //For convenience, the constructed json string is used as the input for parsing json std::string test_json_string = root.toStyledString(); if (reader.parse(test_json_string, root2, false)) { LOGD(\"Analysis successful\"); /*When parsing json, be sure to check the legitimacy of the input more to avoid program crash caused by illegal input.*/ if (root2.isMember(\"int\")) { LOGD(\"int = %d\", root2[\"int\"].asInt()); } if (root2.isMember(\"str\")) { LOGD(\"str = %s\", root2[\"str\"].asString().c_str()); } if (root2.isMember(\"array\")) { Json::Value obj = root2[\"array\"]; if (obj.isArray()) { for (Json::ArrayIndex i = 0; i powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"cpp_base.html":{"url":"cpp_base.html","title":"C++ Foundation ","keywords":"","body":"c++ basic knowledge This chapter is mainly for students who do not have C++ foundation, mainly to explain the common C++ grammar and common classes in our system; Class When it comes to C++, you have to mention the Class first. Don't think about it too complicated. Just think of it as a structure in the C language. For example: // C struct Position { int left; int top; int width; int height; }; // c++ class Position { public: int left; int top; int width; int height; }; Define variables: // C struct Position pos; // c++ Position pos; Operating variables: // C is the same as c++ pos.left = 0; Class Chas more concepts of inheritance, polymorphism, overloading and access permissions than the structure in C language. For students who are only familiar with C language, they don’t need to pay too much attention to these details, as long as they master how to use it; In addition, functions can be directly defined in Class. The structure in C language is to define function pointers. This is a bit different. After Class defines the function, it can be used like operating variables. Here Give an example commonly used in our framework: // Set the text content, where mTextView1Ptr is a pointer variable of type ZKTextView mTextView1Ptr->setText(\"Hello\"); Commonly used classes string class The string class actually encapsulates the string and provides a lot of functions. Students who are only familiar with the C language only need to know one function: c_str(), this function will return the characters in the string class String data, here is also an example commonly used in our framework: // Input box callback interface static void onEditTextChanged_Edittext1(const std::string &text) { // The return value type of c_str() function: const char * const char *pStr = text.c_str(); // Then you can operate like ordinary strings, such as getting the strlen(pStr), etc. } Give another example of obtaining the content of a text control: // std is the namespace, std::string means to use the string class under std, don’t worry too much // When encountering the string class, we can refer to the following definition std::string text = mTextView1Ptr->getText(); // The subsequent operations are the same const char *pStr = text.c_str(); Formatted output function snprintf Function prototype: int snprintf(char* dest_str,size_t size,const char* format,...); Features: The variable parameters (...) are formatted into a string according to format, and then copied to str. (1) If the length of the formatted string is (2) If the length of the formatted string >= size, only (size-1) characters in it will be copied to str, and a string terminator('\\0')will be added after it, and return The value is the length of the string to be written. Required header files: #include Formatting parameters Specifier%d decimal signed integer%u decimal unsigned integer%f floating point number%s string %c single character%p pointer value%e exponential floating point number%x, %X unsigned integer in hexadecimal%o Unsigned integer in octal%g outputs the output value according to the smaller output length in %e or %f type%p output address character%lu 32-bit unsigned integer%llu 64-bit unsigned integer Description (1).A number can be inserted between “%” and a letter to indicate the maximum field width. For example: %3d means to output a 3-digit integer, which is not enough to be right-justified. %9.2f represents a floating-point number with a field width of 9, where the decimal place is 2 and the integer place is 6, The decimal point occupies one digit, which is not enough for 9 digits to be right aligned. %8s means output a string of 8 characters, which is not enough to right-justify 8 characters. If the length of the string or the number of integers exceeds the specified field width, it will be output according to its actual length. But for floating-point numbers, if the number of integers exceeds the specified width of integers, it will be output as actual integers; If the number of decimal places exceeds the specified width of decimal places, the output will be rounded according to the specified width. In addition, if you want to add some zeros before the output value, you should add a zero before the field width term. For example: %04d means that when outputting a value less than 4 digits, 0 will be added to the front to make the total width 4 digits. If a floating point number is used to represent the output format of characters or integers, the number after the decimal point represents the maximum width, and the number before the decimal point represents the minimum width. For example: %6.9s means to display a string with a length not less than 6 and not greater than 9. If it is greater than 9, the content after the 9th character will be deleted. (2). You can add a lowercase letter l between \"%\" and the letter, indicating that the output is a long number. For example: %ld means output long integer %lf means output double floating point number (3). You can control the output to be left-aligned or right-aligned, that is, add a \"-\" sign between \"%\" and the letter, Explain that the output is left-justified, otherwise it is right-justified. For example: %-7d means that the output 7-bit integer is left-justified %-10s means output 10 characters left-justified Special specifier\\n newline\\f Clear screen and change page\\r Enter\\t Tab character Examples Direct output integer char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%d\", 314); LOGD(\"%s\", buf);//log output buf The log output is 314 Control the number of integers char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%05d\", 314); //Format to 5 digits, less than 5 digits, add 0 in front LOGD(\"%s\", buf);//Log output buf string The log output is 00314 Directly output floating point numbers char buf[64] = {0}; snprintf(buf, sizeof(buf), \"%f\", 3.14); LOGD(\"%s\", buf);//Log output buf string The log output is 3.140000 Control output floating point number format char buf[64] = {0}; //Output decimals, a total of 6 characters width (including the decimal point), 3 decimal places, two integer digits, and 0 if the integer is less than two digits snprintf(buf, sizeof(buf), \"%06.3f\", 3.14); LOGD(\"%s\", buf);//Log output buf string The log output is 03.140 powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"touchcalibration.html":{"url":"touchcalibration.html","title":"Touch Calibration ","keywords":"","body":"Touch calibration After the resistance screen machine is flashed, the system will perform a touch calibration the first time it is powered on. The calibration interface is as follows: Click the \"cross icon\" to calibrate; we want to calibrate again later, we have the following 3 methods: Modify the project properties through the tool, and check the Start touch calibration program option, so that each time the power is turned on, the touch calibration interface will be entered first: Create a file zktouchcalib (note: the file does not have a suffix) in the root directory of the TF card , after inserting the card, it will enter the touch calibration interface Start the touch calibration interface by codeEASYUICONTEXT->openActivity(\"TouchCalibrationActivity\"); powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"font_setting.html":{"url":"font_setting.html","title":"Font Library Setting Instructions ","keywords":"","body":"Font library settings The default font library packaged by FlyThings system is Siyuan HeiTi font, we can view the project properties: The font option is checked by default, and the compiled upgrade file will be packaged in the fzcircle.ttf font librery in the font directory of the corresponding platform in the tool installation directory This font library is the Siyuan HeiTi font library, we made some cuts and renamed it fzcircle.ttf; If we want to use other font libraries, just remove the default options and import a new font library （note that this font library only supports ttf format）： Z6S and later platforms Our system has built-in fzcircle.ttf font library directly, the purpose is to speed up the boot speed, if any fonts are missing, we need to customize an extended font library by ourselves, the same as Siyuan Heibody Font, the name of the font library is also fzcircle.ttf, the import method is the same as above, so that when the system loads fonts, the built-in fonts in the system will be loaded first, and the corresponding fonts in the extended font library will be loaded if the loading fails; if you want to use other fonts Library, the name of the imported font library is not fzcircle.ttf , so the loaded fonts are all external fonts. To summarize: Z11S platform : Because the platform system does not have a built-in font library, the system directly uses the font library packaged by the tool, and there is no extension of the font library. Remember, the default package is Siyuan bold font fzcircle .ttf fzcircle.ttf； Z6S and later platforms : The system has a built-in fzcircle.ttf font library, supports extended font library, the same as Siyuan HeiTi font , the name of the font library must be fzcircle.ttf; When using other font libraries, the imported font library name cannot be fzcircle.ttf; powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"font_cut_tool.html":{"url":"font_cut_tool.html","title":"Cut font ","keywords":"","body":"Font cropping In the project, custom fonts may be used, but the full font of 10M is not suitable for use in the project. Moreover, usually we only use a small part of the font, cutting out the unnecessary characters, which can greatly save the space consumption of the font, and also speed up the startup speed of the screen. Use of font cutting tools In the menu bar of the development tools, you can find the font cropping tool. ， First select the font cropping method. The purpose of this step is to determine which characters in the font are retained. Regular expressionSupport java regular expressions, for example \\d means all numbers Specify textSpecify a text file, Ensure that the file encoding is UTF-8 , all text in the file content means the text that needs to be retained. （Recommended method: simple and intuitive） Set the fontSpecify the path of the full font. Set the output pathSpecify the save path of the new font after the font is cropped. If the file already exists, it will be overwritten. After setting the above parameters, click Crop If the prompt is completed, the cutting is successful, and the newly generated font file can be seen in the output path. It can be found that the cropped font file is smaller than the complete font. Example Create a new txt file, the content of the file is only “Hello” one word, Save the code as UTF-8 . After setting the parameters and cutting, the final generated ttf file size is less than 10KB. The cropped font can be verified in Online Font Editor which characters it contains. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"hardware.html":{"url":"hardware.html","title":"Hardware Instructions ","keywords":"","body":"Hardware instructions Precautions before use Make sure the power supply voltage must be 4.5-5.5V. If the power supply exceeds or falls below this range, the machine cannot work normally. If the power supply voltage is too high, the module screen will be damaged. Determine whether the serial port level is RS232 or TTL or RS485, and choose according to the requirements in conjunction with the fourth point. Pay attention to the interface definition instructions of the power interface socket, and do not connect it wrongly. Module function interface diagram z11s z6s Power interface description PH2.0-8PIN seat interface definition | 1PIN | 2PIN |3PIN | 4PIN | 5PIN | 6PIN | 7PIN | 8PIN | | --- | --- | --- | --- |--- | --- |--- | --- | | DC5V | RESET | CTS | TXOUT/B | RXIN/A | RTS | GND | GND ||DC power input 4.5-5.5V |Module RESET, the default is NC |Flow control CTS |Serial TX or RS485-B. (Connect to external equipment RX/RS485B) |Serial RX or RS485-A (connect to external equipment TX/RS485A) | Flow control RTS| Power ground | Power ground | 10PIN1.0FPC socket interface definition | 1/2/3PIN | 4PIN | 5PIN | 6PIN | 7PIN | 8/9/10PIN | | --- | --- | --- | --- |--- | --- | | DC5V | RTS | RXIN/A | TXOUT/B | CTS | GND | |DC power input 4.5-5.5V | Flow control RTS | Serial port RX or RS485-A (connect to external device TX/RS485A) | Serial port TX or RS485-B. (Connect to external equipment RX/RS485B) | Flow control CTS | Power ground | Serial output mode selection As illustrated0R resistance is TTL, 0R is not RS232. The module screen corresponds to the external device interface diagram Sample distribution power cord description The power cord is a white-blue or white-red cord with a single-ended PH2.0-8PIN 10CM buckle. As shown powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"problems.html":{"url":"problems.html","title":"common problem ","keywords":"","body":"Common problem The project created by the old tool is imported into the new tool, the compilation prompt ndk-build not found If you install the new tool and delete the old tool, the project created by the old tool is imported into the new tool, the compilation may prompt ndk-build not found.It can be solved by manually replacing the following files.Download z11s project configuration file, unzip, copy all the contents of the folder to the project folder, Note: This operation will cover a total of three files, please pay attention to backup. After overwriting the file, restart the tool to solve it. Time-consuming operations in the UI main thread cause the card to not display the upgrade interface The refresh display of the interface is handled in the main UI thread. If there are some time-consuming operations or an infinite loop of the program in the main UI thread, it will affect the refresh of the UI and cause the card to not display the upgrade interface; onUI_init、onUI_intent、onUI_show、onUI_hide、onUI_quit、onUI_Timer and some control-related callback interfaces, these functions are all called in the UI main thread, so if this happens, first check if there is any time-consuming operation in these functions; In this case, the machine can only be restarted by plugging in the card. After the system is up, it will first check whether the upgrade is needed, so that the upgrade interface can be displayed normally. Unable to download and debug/download and debug failed First confirm that the computer and the screen are connected correctly. If it is a screen with WIFI, it only supports WIFI connection and cannot use the USB cable connection; similarly, if it is a screen without WIFI, then it can only be connected via a USB cable, if it is connected by USB Normally, the computer will recognize it as a USB device.After confirming the supported connection mode, go to the development tool menu bar, select Debug Configuration -> ADB Configuration, set the corresponding connection mode, and save.Try to download again.How to download and debug via ADB The program suddenly restarts by itself or gets stuck First, when an unexpected situation occurs in the program, you must check the log (How to view the log), try to reproduce the problem repeatedly, and determine the problem code based on the log.If the program crashes and restarts, a similar log will generally appear on the log. These logs will be output when the program is started and initialized, so you can use this to determine whether the program has restarted. Most of the causes of program crashes can be attributed to incorrect usage of pointers. E.g Null pointer Array out of bounds Did not pay attention to the life cycle of the pointer, but the memory is still in use after the release etc.As the project uses C language and C++ language programming, in terms of pointer memory, it is inevitable to deal with raw pointers, which requires us to be extra careful. There is another kind of crash, which may be caused by not paying attention to the error of Divisor cannot be 0. If the program is stuck, from the log, there is no restart phenomenon, then we can check from thread deadlock, whether the code loops indefinitely, there is a long time-consuming operation, causing the stuck The illusion of death analyze these situations. For more questions, please go to Forum Search or ask powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"install_adb_driver.html":{"url":"install_adb_driver.html","title":"Install ADB Driver","keywords":"","body":"How to use the Android ADB driver installer for Windows XP/Vista/7/8/10 First download the driver installation program。 Connect the Android device to the computer via USB. In the ADB driver installer, click the Install button to continue. If the system prompts that Windows cannot verify the publisher of this driver software, please select ”Always install this driver software“ The universal android usb driver will be automatically installed on your computer. Finally, ADB Driver Installer will show that the installation was successful windows xp users are recommended to restart after installing the driver. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"convert_platform.html":{"url":"convert_platform.html","title":"Convert Project Platform","keywords":"","body":"Conversion project platform In order to facilitate the use of the same project source code on different hardware platforms, the function of Conversion and Compilation Platform is provided. Steps: Select the project name, right-click, and select Convert Compilation Platform in the pop-up context menu to quickly switch platforms. For the conversion function, you need to pay attention to the following points: The conversion function is essentially to reconfigure the compilation environment such as the compilation tool chain, without any changes to the source code. The hardware of different platforms is different, so the hardware-related settings such as serial port and GPIO need to be modified manually. Due to differences in toolchain versions, compilation failures may occur after conversion. This also requires manual modification of Makefile or standard source code to solve. powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"board_tag_explain.html":{"url":"board_tag_explain.html","title":"Product specification model description ","keywords":"","body":"Product specification model description There is a model label on the back of the board, and the model description is as follows: For example, SW80480070A_CWM is a 7-inch 800*480 capacitive WIFI multimedia version powered by Gitbooklast modified: 2021-06-09 09:56:26 "},"core_module.html":{"url":"core_module.html","title":"Core Module Usage Tutorial ","keywords":"","body":"Core Module The core module needs to generate its own mirror image and flash the machine before using the various functions of the module. Tutorial Register and log in to the website https://superv.flythings.cn Select the hardware version Select the function of each pin Note：Capacitive touch PIN:CTPSCL、CTPSDA、CTPINT、CTPRST esistive touch PIN：RTPY2、RTPY1、RTPX2、RTPX1 Select the screen resolution; if necessary, adjust the screen parameters again Select touch type Note： The touch type should correspond to the PIN pin. Capacitive touch PIN：CTPSCL、CTPSDA、CTPINT、CTPRST Resistive touch PIN：RTPY2、RTPY1、RTPX2、RTPX1 After all the above settings are completed, click Submit, and the new system image will be downloaded according to the configuration. After the new image is downloaded, refer to the How to make a flashing card, to flash the device. After successfully flashing, you can view FlyThings Development Document vfor application development. powered by Gitbooklast modified: 2021-06-09 09:56:26 "}}